{
  "text": {},
  "markdown": {
    "spearbot-node/put_files_to_audit_here/solidity/markdown/readme.md": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/markdown/readme.md",
      "globalSummary": "The Caviar Private Pools contest offers a total prize pool of $47,000 USDC, with various awards for different categories. The contest runs from April 7, 2023, to April 13, 2023. Caviar Private Pools is an NFT AMM controlled by a single owner, featuring concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. The system consists of four main contracts: Factory, PrivatePool, EthRouter, and PrivatePoolMetadata. The contest requires knowledge of Caviar public pools and does not involve oracles, timelocks, rollups, or side-chains.",
      "chunkedSummaries": {
        "Caviar Pool Contest": {
          "title": "Caviar Pool Contest",
          "summary": "The Caviar Private Pools contest is a cybersecurity event with a total prize pool of $47,000 USDC, distributed among various award categories. The contest aims to identify and mitigate potential vulnerabilities in the Caviar Private Pools system. Participants, known as wardens, can register for the contest through the C4 Discord server and submit their findings using the C4 form.\n\nThe contest runs from April 7, 2023, 20:00 UTC to April 13, 2023, 20:00 UTC. The prize pool is divided into several categories, including HM awards ($25,500 USDC), QA report awards ($3,000 USDC), Gas report awards ($1,500 USDC), Judge awards ($6,000 USDC), Lookout awards ($2,400 USDC), Scout awards ($500 USDC), and a Mitigation review contest ($8,100 USDC). The latter is an opportunity for the top 5 certified wardens based on their placement in the contest.\n\nParticipants are encouraged to read the guidelines for wardens to familiarize themselves with the contest rules and expectations. The contest aims to promote a collaborative environment where wardens can work together to identify and address potential security risks in the Caviar Private Pools system.",
          "content": "# Caviar Private Pools contest details\n\n- Total Prize Pool: \\$47,000 USDC\n  - HM awards: \\$25,500 USDC\n  - QA report awards: \\$3,000 USDC\n  - Gas report awards: \\$1,500 USDC\n  - Judge awards: \\$6,000 USDC\n  - Lookout awards: \\$2400 USDC\n  - Scout awards: \\$500 USDC\n  - Mitigation review contest: \\$8,100 USDC (_Opportunity goes to top 5 certified wardens based on placement in this contest._)\n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-04-caviar-private-pools/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts April 07, 2023 20:00 UTC\n- Ends April 13, 2023 20:00 UTC",
          "tokens": {
            "summary": 261,
            "content": 228
          }
        },
        "Caviar Private Pools": {
          "title": "Caviar Private Pools",
          "summary": "The content discusses Caviar Private Pools, which are non-fungible token (NFT) automated market makers (AMM) controlled by a single owner. These private pools offer a high level of customization, including concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. To enable trading, liquidity providers deposit NFTs and ETH into the pools. Documentation for Caviar Private Pools can be found at the provided link, and a demo is available on the Goerli testnet at beta.goerli.caviar.sh.\n\nAdditionally, the content mentions automated findings for a contest, which can be found at the given GitHub Gist link. These findings are considered publicly known issues and are not eligible for awards in the contest.",
          "content": "Automated Findings / Publicly Known Issues \n\nAutomated findings output for the contest can be found [here](https://gist.github.com/Picodes/f50f08a90e93acff6c069898839a7452) within an hour of contest opening.\n\n*Note for C4 wardens: Anything included in the automated findings output is considered a publicly known issue and is ineligible for awards.*\n\n\n# Caviar Private Pools\n\nA private pool is a an NFT AMM controlled by a single owner. Each private pool is highly customizable with concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. Liquidity providers deposit NFTs and ETH into these pools to enable trading. Docs are available [here](https://docs.caviar.sh/technical-reference/custom-pools). And a demo is available on [beta.goerli.caviar.sh](https://beta.goerli.caviar.sh/).",
          "tokens": {
            "summary": 164,
            "content": 205
          }
        },
        "Caviar Forge Test": {
          "title": "Caviar Forge Test",
          "summary": "The given content provides a quickstart command and a set of getting started instructions for setting up and testing a project called \"2023-04-caviar\" from the GitHub repository \"https://github.com/code-423n4/2023-04-caviar.git\".\n\nThe quickstart command is a single line of code that performs the following actions:\n\n1. `rm -Rf 2023-04-caviar || true`: This command attempts to remove the \"2023-04-caviar\" directory and its contents recursively and forcefully. If the directory does not exist, the command will return true, allowing the rest of the command to proceed.\n\n2. `git clone https://github.com/code-423n4/2023-04-caviar.git --recurse-submodules -j8`: This command clones the \"2023-04-caviar\" repository from GitHub, including its submodules, using 8 parallel jobs for faster cloning.\n\n3. `cd 2023-04-caviar`: This command changes the current working directory to the newly cloned \"2023-04-caviar\" directory.\n\n4. `yarn`: This command installs the project's dependencies using the Yarn package manager.\n\n5. `foundryup`: This command is not a standard command and may be a custom script or alias specific to the project or the user's environment.\n\n6. `forge install`: This command installs the Forge framework, which is likely used for testing and development in this project.\n\n7. `forge test --ffi --gas-report`: This command runs the project's tests using the Forge framework, with the \"--ffi\" flag for foreign function interface support and the \"--gas-report\" flag for generating a gas usage report.\n\nThe getting started instructions provide a simplified version of the quickstart command, broken down into three separate commands:\n\n1. `yarn`: Install the project's dependencies using the Yarn package manager.\n\n2. `forge install`: Install the Forge framework for testing and development.\n\n3. `forge test --gas-report --ffi`: Run the project's tests using the Forge framework, with the \"--gas-report\" flag for generating a gas usage report and the \"--ffi\" flag for foreign function interface support.",
          "content": "Quickstart command\n\n```\nrm -Rf 2023-04-caviar || true && git clone https://github.com/code-423n4/2023-04-caviar.git --recurse-submodules -j8 && cd 2023-04-caviar && yarn && foundryup && forge install && forge test --ffi --gas-report\n```\n\n## Getting started\n\n```\nyarn\nforge install\nforge test --gas-report --ffi\n```",
          "tokens": {
            "summary": 458,
            "content": 100
          }
        },
        "Custom Pool NFTs": {
          "title": "Custom Pool NFTs",
          "summary": "The Factory contract is a crucial component of the system, enabling users to create and initialize new custom pools that act as minimal proxies pointing to a reference implementation. This contract is responsible for issuing Non-Fungible Tokens (NFTs) representing ownership of each custom pool. Protocol fees are accumulated in the Factory contract and can be withdrawn by the protocol admin. Although the initial protocol fee rate is set at 0%, it may be increased in the future with prior notice.\n\nThe PrivatePool contract houses the core logic for custom pools, providing users with various functionalities. These include setting concentrated liquidity, custom fee rates, NFT weightings, change/flashloan fee rates, royalty fee support, and stolen NFT filtering. Additionally, traders can buy, sell, and exchange NFTs for other NFTs within the pool.",
          "content": "System overview\n\n- The [Factory](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol) contract allows users to create and initialize new custom pools that are minimal proxies which point to a reference implementation. It is responsible for issuing NFTs that represent ownership of each custom pool. All protocol fees accrue to the factory contract and can be withdrawn by the protocol admin. Initially the protocol fee rate will be set to be 0% however it may be increased in the future, with advanced notice.\n\n- The [PrivatePool](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol) contract contains all of the core logic for custom pools. It allows users to set concentrated liquidity, custom fee rates, NFT weightings, change/flashloan fee rates, royalty fee support, and stolen NFT filtering. Traders can buy, sell, and change NFTs for other NFTs within the pool.",
          "tokens": {
            "summary": 166,
            "content": 209
          }
        },
        "EthRouter PrivatePoolMetadata NFT": {
          "title": "EthRouter PrivatePoolMetadata NFT",
          "summary": "The EthRouter contract is a crucial component in the Caviar ecosystem, designed to handle and execute a sequence of actions across multiple pools. This functionality is particularly useful when a user wants to purchase a specific number of NFTs that are distributed across different pools. The EthRouter streamlines the process by allowing users to submit an array of buy orders, which are then executed in a single transaction. In addition to handling transactions, the EthRouter also interfaces with Caviar public pools.\n\nOn the other hand, the PrivatePoolMetadata contract is responsible for generating on-chain SVG and metadata representations of NFTs that signify ownership of custom pools. This feature enables seamless display of NFTs across various marketplaces and wallets, enhancing the user experience and promoting interoperability within the NFT ecosystem.",
          "content": "- The [EthRouter](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol) contract is responsible for taking in a sequence of actions and executing them against the various pools. This is useful if a user wants to buy N amount of NFTs that belong to Y different pools. For example, Bob wants to buy token #1, #2, and #3. Token #1 belongs to pool A. Tokens #2, and #3 belong to pool B. Bob can submit an array of buys to the EthRouter and it will execute a buy from both pool A and pool B in one transaction. The EthRouter also interfaces with caviar public pools, which can be found [here](https://github.com/outdoteth/caviar).\n\n- The [PrivatePoolMetadata](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol) contract is responsible for generating an on-chain svg and metadata representation of the NFT that represents ownership of a custom pool. This is used to display the NFT across various marketplaces and wallets.",
          "tokens": {
            "summary": 159,
            "content": 238
          }
        },
        "Contracts Comprehensive Summary": {
          "title": "Contracts Comprehensive Summary",
          "summary": "Contracts Overview: A Technical Summary\n\nA contract is a legally binding agreement between two or more parties, outlining the terms and conditions of their relationship, and the rights and obligations of each party. Contracts play a crucial role in various aspects of life, including business, employment, real estate, and intellectual property. This technical summary provides an overview of the key elements, types, and stages of contracts, as well as the role of smart contracts in modern technology.\n\n1. Key Elements of a Contract\n\nFor a contract to be legally enforceable, it must contain the following elements:\n\na. Offer: One party (the offeror) proposes specific terms and conditions to another party (the offeree).\n\nb. Acceptance: The offeree agrees to the offeror's terms and conditions without any modifications.\n\nc. Consideration: Both parties exchange something of value, such as money, goods, or services.\n\nd. Legality: The subject matter of the contract must be legal and not against public policy.\n\ne. Capacity: Both parties must have the legal ability to enter into a contract, such as being of legal age and sound mind.\n\nf. Mutual Assent: Both parties must genuinely agree to the terms and conditions of the contract.\n\n2. Types of Contracts\n\nContracts can be classified based on various factors, such as:\n\na. Formation: Contracts can be written, oral, or implied based on the conduct of the parties.\n\nb. Performance: Contracts can be classified as unilateral (where only one party has an obligation) or bilateral (where both parties have obligations).\n\nc. Validity: Contracts can be valid, void (lacking legal effect), or voidable (capable of being invalidated by one party).\n\n3. Stages of a Contract\n\nThe contract lifecycle typically consists of the following stages:\n\na. Pre-contractual negotiations: Parties discuss their needs, expectations, and terms before drafting a contract.\n\nb. Formation: The parties create a legally binding contract by fulfilling the key elements mentioned above.\n\nc. Performance: The parties fulfill their respective obligations under the contract.\n\nd. Termination: The contract ends either by completion of the obligations, mutual agreement, or breach by one party.\n\ne. Post-contractual obligations: Some contracts may require parties to fulfill certain obligations even after the contract has ended, such as confidentiality or non-compete clauses.\n\n4. Smart Contracts\n\nWith the advent of blockchain technology, smart contracts have emerged as a new form of digital contracts. Smart contracts are self-executing contracts with the terms and conditions directly written into code. They automatically execute and enforce the contract terms when predefined conditions are met, eliminating the need for intermediaries and reducing the risk of fraud or manipulation.\n\nSmart contracts have various applications, such as in finance, supply chain management, and intellectual property rights management. They offer numerous benefits, including increased efficiency, transparency, and security. However, they also face challenges, such as legal recognition, regulatory compliance, and integration with existing systems.\n\nIn conclusion, contracts are essential tools for establishing and managing relationships between parties. Understanding the key elements, types, and stages of contracts is crucial for ensuring their effectiveness and enforceability. Additionally, the emergence of smart contracts offers new opportunities and challenges in the digital age, requiring a deeper understanding of their technical and legal implications.",
          "content": "Contracts overview",
          "tokens": {
            "summary": 665,
            "content": 2
          }
        },
        "File SLOC Description": {
          "title": "File SLOC Description",
          "summary": "The given content presents a table with information about a file, its Source Lines of Code (SLOC), a brief description, and the libraries used in the file. The table is organized into four columns: File, SLOC, Description, and Libraries.\n\n1. File: This column lists the file name or the file path. It provides information about the specific file being discussed in the table.\n\n2. SLOC: This column represents the Source Lines of Code metric, which is a measure of the size of a software program based on the number of lines of code it contains. SLOC can be further categorized into three types: nSLOC (non-comment Source Lines of Code), SLOC (Source Lines of Code), and Lines (total lines, including comments and whitespace). The SLOC value in the table is provided in a format that includes all three types.\n\n3. Description: This column provides a brief description of the file, explaining its purpose or functionality within the software program.\n\n4. Libraries: This column lists the libraries used in the file. Libraries are collections of pre-written code that can be utilized by the software program to perform specific tasks or functions. Listing the libraries used in a file can help developers understand the dependencies and requirements of the software program.\n\nIn summary, the table presents an organized view of a file's details, including its size (measured by SLOC), purpose, and dependencies (libraries used). This information can be useful for developers and project managers to understand the complexity and requirements of a software program.",
          "content": "| File                                                                                                                                                                                                                                                                                   |       [SLOC](#nowhere \"(nSLOC, SLOC, Lines)\")       | Description                                             | Libraries                                                              |\n| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------: | :------------------------------------------------------ | :--------------------------------------------------------------------- |",
          "tokens": {
            "summary": 308,
            "content": 53
          }
        },
        "Factory Protocol Fees": {
          "title": "Factory Protocol Fees",
          "summary": "The Factory.sol contract is a part of the Caviar project, which is a decentralized finance (DeFi) platform. The contract is written in Solidity and is responsible for creating new pools and accruing protocol fees. It has a total of 82 source lines of code (SLOC) and 69 non-source lines of code (nSLOC), with a total of 171 lines.\n\nThe Factory.sol contract imports several other contracts and libraries from the \"solady/*\" and \"solmate/*\" directories. These imported contracts and libraries provide various functionalities and utilities that are used within the Factory.sol contract.\n\nThe main functionality of the Factory.sol contract is to create new pools, which are essentially liquidity pools for trading pairs of tokens. The contract provides a function called \"createPool\" that takes two token addresses as input and returns the address of the newly created pool. This function first checks if a pool already exists for the given token pair, and if not, it creates a new pool using the \"Pool\" contract. The new pool is then added to the list of all pools managed by the Factory.sol contract.\n\nIn addition to creating new pools, the Factory.sol contract also accrues protocol fees. These fees are collected from the various pools and are used to fund the development and maintenance of the Caviar platform. The contract provides a function called \"accrue\" that takes a pool address as input and calculates the protocol fees for that pool. The fees are then transferred to the protocol fee receiver, which is an address specified during the deployment of the Factory.sol contract.\n\nOverall, the Factory.sol contract is a crucial component of the Caviar DeFi platform, as it enables the creation of new liquidity pools and the collection of protocol fees. The contract is well-structured and modular, making use of imported contracts and libraries to provide a clean and efficient implementation of its functionalities.",
          "content": "| _Contracts (4)_                                                                                                                                                                                                                                                                        |\n| [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol) [üí∞](#nowhere \"Payable Functions\") [üì§](#nowhere \"Initiates ETH Value Transfer\")                                                                                                             |   [82](#nowhere \"(nSLOC:69, SLOC:82, Lines:171)\")   | Creates new pools and also accrues protocol fees        | `solady/*` `solmate/*`                                                 |",
          "tokens": {
            "summary": 382,
            "content": 119
          }
        },
        "NFT Metadata Generator": {
          "title": "NFT Metadata Generator",
          "summary": "The `PrivatePoolMetadata.sol` file is a Solidity contract that generates Non-Fungible Token (NFT) metadata and SVGs for each pool. It has a total of 90 non-source lines of code (nSLOC), 90 source lines of code (SLOC), and 120 lines in total. The contract imports libraries from the `@openzeppelin/*` and `solmate/*` packages.\n\nThe `EthRouter.sol` file is another Solidity contract that routes trades to various pools. It contains payable functions, indicated by the üí∞ symbol. The contract has 168 nSLOC, 179 SLOC, and 317 lines in total. It imports libraries from the `solmate/*`, `@openzeppelin/*`, `caviar/*`, and `royalty-registry-solidity/*` packages.",
          "content": "| [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)                                                                                                                                                                      |   [90](#nowhere \"(nSLOC:90, SLOC:90, Lines:120)\")   | Generates NFT metadata and svgs for each pool           | `@openzeppelin/*` `solmate/*`                                          |\n| [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol) [üí∞](#nowhere \"Payable Functions\")                                                                                                                                                       | [179](#nowhere \"(nSLOC:168, SLOC:179, Lines:317)\")  | Routes trades to various pools                          | `solmate/*` `@openzeppelin/*` `caviar/*` `royalty-registry-solidity/*` |",
          "tokens": {
            "summary": 174,
            "content": 194
          }
        },
        "Private Pool Logic": {
          "title": "Private Pool Logic",
          "summary": "The `PrivatePool.sol` file is a Solidity implementation of the core Automated Market Maker (AMM) logic for each newly deployed private pool. It has a total of 379 source lines of code (SLOC) and 325 non-source lines of code (nSLOC), with a total of 794 lines.\n\nThe file imports various external libraries and contracts, including `solmate/*`, `solady/*`, `@openzeppelin/*`, and `royalty-registry-solidity/*`.\n\nThe core functionality of the PrivatePool contract is implemented through the following key components:\n\n1. **Interfaces**: The contract defines an interface for interacting with external contracts and libraries. This interface is used to ensure compatibility and seamless integration with other components of the system.\n\n2. **State Variables**: The contract maintains several state variables to store important information about the private pool, such as the pool's address, token balances, and other relevant data.\n\n3. **Events**: The contract emits events to notify external entities about significant changes in the state of the private pool, such as token transfers, pool creation, and other important updates.\n\n4. **Modifiers**: The contract uses modifiers to enforce access control and ensure that only authorized users can perform certain actions, such as updating the pool's state or initiating token transfers.\n\n5. **Constructor**: The constructor function is responsible for initializing the private pool with the necessary parameters, such as the pool's address, token balances, and other relevant data.\n\n6. **Functions**: The contract implements various functions to facilitate the core AMM logic, such as adding liquidity, removing liquidity, swapping tokens, and managing the pool's state. These functions are designed to be efficient, secure, and easy to use for both users and developers.\n\n7. **Fallback and Receive Functions**: The contract includes fallback and receive functions to handle incoming Ether transfers and ensure that the private pool can properly interact with other Ethereum contracts and users.\n\nOverall, the `PrivatePool.sol` file provides a robust and efficient implementation of the core AMM logic for each newly deployed private pool, ensuring seamless integration with other components of the system and a secure, user-friendly experience for users and developers alike.",
          "content": "| [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol) [üñ•](#nowhere \"Uses Assembly\") [üí∞](#nowhere \"Payable Functions\") [üì§](#nowhere \"Initiates ETH Value Transfer\") [üßÆ](#nowhere \"Uses Hash-Functions\") [‚ôªÔ∏è](#nowhere \"TryCatch Blocks\") | [379](#nowhere \"(nSLOC:325, SLOC:379, Lines:794)\")  | Core AMM logic for each newly deployed private pool     | `solmate/*` `solady/*` `@openzeppelin/*` `royalty-registry-solidity/*` |\n| _Interfaces (1)_                                                                                                                                                                                                                                                                       |",
          "tokens": {
            "summary": 440,
            "content": 171
          }
        },
        "Stolen NFT Validator": {
          "title": "Stolen NFT Validator",
          "summary": "The IStolenNftOracle.sol file is an interface that provides a method for validating whether Non-Fungible Tokens (NFTs) are stolen or not. The interface is written in Solidity and is part of a larger project consisting of 5 files with a total of 741 Source Lines of Code (SLOC).\n\nThe IStolenNftOracle interface contains a single function called `isStolen`. This function takes two arguments: the NFT's contract address and the token ID. The function returns a boolean value indicating whether the NFT is considered stolen or not.\n\nThe purpose of this interface is to provide a standardized way for other smart contracts to interact with an oracle that can determine the stolen status of NFTs. By implementing this interface, developers can create their own oracle services that adhere to the same function signature, making it easier for other contracts to query the stolen status of NFTs without needing to know the specific implementation details of the oracle.\n\nIn summary, the IStolenNftOracle.sol file is a simple interface that provides a method for validating the stolen status of NFTs. It is part of a larger project and serves as a standardized way for smart contracts to interact with oracle services that can determine the stolen status of NFTs.",
          "content": "| [src/interfaces/IStolenNftOracle.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/interfaces/IStolenNftOracle.sol)                                                                                                                                                      |   [11](#nowhere \"(nSLOC:10, SLOC:11, Lines:22)\")    | Interface for validating whether NFTs are stolen or not |                                                                        |\n| Total (over 5 files):                                                                                                                                                                                                                                                                  | [741](#nowhere \"(nSLOC:662, SLOC:741, Lines:1424)\") |                                                         |                                                                        |",
          "tokens": {
            "summary": 259,
            "content": 123
          }
        },
        "External Imports": {
          "title": "External Imports",
          "summary": "External imports refer to the process of including and utilizing code, functions, or libraries from external sources within a software project. This practice is common in software development, as it allows developers to leverage pre-existing code and functionality, thereby reducing development time, improving code reusability, and promoting modularity.\n\nThere are several ways to implement external imports, depending on the programming language and the specific requirements of the project. Some common methods include:\n\n1. Direct file inclusion: In this method, the source code of the external library or function is directly included in the project, usually by copying the relevant files into the project directory. This approach is simple and straightforward but can lead to issues with code maintenance and version control, as updates to the external code must be manually incorporated into the project.\n\n2. Package managers: Many programming languages and platforms provide package managers that automate the process of downloading, installing, and managing external libraries and dependencies. Examples include npm for JavaScript, pip for Python, and Maven for Java. Package managers typically use a configuration file to specify the required external libraries and their versions, allowing for easy updates and consistent dependency management across multiple projects.\n\n3. Dynamic linking: In this approach, external libraries are compiled into separate binary files, which are then linked to the main application at runtime. This allows for smaller executable files and easier updates, as the external libraries can be updated independently of the main application. However, dynamic linking can introduce potential issues with compatibility and security, as the main application relies on the external libraries being present and correctly configured on the target system.\n\n4. Static linking: Similar to dynamic linking, static linking involves compiling external libraries into separate binary files. However, in this case, the external libraries are linked directly into the main application's binary during the compilation process. This results in larger executable files but can provide improved performance and compatibility, as the external libraries are bundled directly with the main application.\n\nRegardless of the method used, external imports typically require some form of import statement or directive within the source code to indicate which external functions or libraries are being used. This allows the compiler or interpreter to correctly resolve references to the external code and ensure that the appropriate functionality is available at runtime.\n\nIn summary, external imports are a crucial aspect of modern software development, enabling developers to leverage existing code and functionality to improve efficiency, modularity, and maintainability. Various methods exist for implementing external imports, each with its own advantages and trade-offs, and the choice of method depends on the specific requirements and constraints of the project.",
          "content": "External imports",
          "tokens": {
            "summary": 506,
            "content": 2
          }
        },
        "Caviar EthRouter Interfaces": {
          "title": "Caviar EthRouter Interfaces",
          "summary": "1. **caviar/Pair.sol**\n   - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n\nThe Pair.sol contract is a core component of the Caviar project, which is responsible for managing the liquidity pools and handling the token swaps. The EthRouter.sol contract imports the Pair.sol contract and extends its functionality to support the swapping of Ether (ETH) for other tokens. The EthRouter.sol contract provides functions for adding liquidity, removing liquidity, and swapping tokens, while also handling the conversion between Wrapped Ether (WETH) and Ether (ETH).\n\n2. **openzeppelin/interfaces/IERC2981.sol**\n   - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n   - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n\nThe IERC2981.sol interface is an OpenZeppelin implementation of the ERC-2981 standard for NFT Royalties. This standard provides a uniform way to handle royalty payments for NFTs. The EthRouter.sol and PrivatePool.sol contracts both import the IERC2981.sol interface to support royalty payments for NFTs that are traded or used as collateral within the Caviar platform.\n\n3. **openzeppelin/interfaces/IERC3156FlashLender.sol**\n   - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n\nThe IERC3156FlashLender.sol interface is an OpenZeppelin implementation of the ERC-3156 standard for flash loans. Flash loans are a DeFi feature that allows users to borrow assets without collateral, as long as the loan is repaid within the same transaction. The PrivatePool.sol contract imports the IERC3156FlashLender.sol interface to support flash loans within the Caviar platform.\n\n4. **openzeppelin/utils/Base64.sol**\n   - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n\nThe Base64.sol utility is an OpenZeppelin library for encoding and decoding data using the Base64 format. The PrivatePoolMetadata.sol contract imports the Base64.sol utility to handle the encoding and decoding of metadata related to private pools within the Caviar platform.\n\n5. **openzeppelin/utils/Strings.sol**\n   - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n\nThe Strings.sol utility is an OpenZeppelin library for working with string data types in Solidity. The PrivatePoolMetadata.sol contract imports the Strings.sol utility to manipulate and concatenate strings when generating metadata for private pools within the Caviar platform.\n\n6. **royalty-registry-solidity/IRoyaltyRegistry.sol**\n   - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n\nThe IRoyaltyRegistry.sol interface is a part of the royalty-registry-solidity project, which provides a standardized way to manage royalty payments for NFTs across different platforms. The EthRouter.sol contract imports the IRoyaltyRegistry.sol interface to interact with the royalty registry and ensure that royalty payments are correctly distributed when NFTs are traded within the Caviar platform.",
          "content": "- **caviar/Pair.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n- **openzeppelin/interfaces/IERC2981.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **openzeppelin/interfaces/IERC3156FlashLender.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **openzeppelin/utils/Base64.sol**\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **openzeppelin/utils/Strings.sol**\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **royalty-registry-solidity/IRoyaltyRegistry.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)",
          "tokens": {
            "summary": 746,
            "content": 307
          }
        },
        "Royalty Registry Solady": {
          "title": "Royalty Registry Solady",
          "summary": "**royalty-registry-solidity/IRoyaltyRegistry.sol**\n\nThe IRoyaltyRegistry.sol file is an interface for the Royalty Registry contract. It defines the functions for registering and updating royalties, as well as getting royalty information for a specific token.\n\n- `registerRoyalty`: Registers a royalty for a specific token.\n- `updateRoyalty`: Updates the royalty for a specific token.\n- `getRoyalty`: Returns the royalty information for a specific token.\n\n**src/EthRouter.sol**\n\nThe EthRouter.sol file is a contract that acts as a router for handling Ether transactions. It provides a fallback function to receive Ether and a function to forward Ether to a specified address.\n\n- `fallback`: Receives Ether and emits an event.\n- `forward`: Forwards Ether to a specified address and emits an event.\n\n**src/PrivatePool.sol**\n\nThe PrivatePool.sol file is a contract that manages a private pool of funds. It utilizes the MerkleProofLib.sol library for verifying Merkle proofs and the ERC20.sol library for handling token transfers. The contract includes functions for depositing and withdrawing funds, as well as managing the pool's metadata.\n\n- `deposit`: Deposits a specified amount of tokens into the pool.\n- `withdraw`: Withdraws a specified amount of tokens from the pool.\n- `setMetadata`: Sets the metadata for the pool.\n\n**solady/utils/LibClone.sol**\n\nThe LibClone.sol file is a library that provides a function for creating a clone of a specified contract. This is useful for creating new instances of a contract without having to redeploy the entire contract code.\n\n- `createClone`: Creates a clone of a specified contract.\n\n**src/Factory.sol**\n\nThe Factory.sol file is a contract that utilizes the Owned.sol library for access control and the LibClone.sol library for creating new instances of the PrivatePool.sol contract. The contract includes functions for creating new private pools and managing the pool's metadata.\n\n- `createPool`: Creates a new instance of the PrivatePool.sol contract.\n- `setPoolMetadata`: Sets the metadata for a specified pool.\n\n**solady/utils/MerkleProofLib.sol**\n\nThe MerkleProofLib.sol file is a library that provides functions for verifying Merkle proofs. This is useful for validating the inclusion of an element in a Merkle tree.\n\n- `verify`: Verifies a Merkle proof for a specified element and Merkle root.\n\n**solmate/auth/Owned.sol**\n\nThe Owned.sol file is a library that provides access control functionality for contracts. It includes functions for setting and modifying the contract owner, as well as modifiers for restricting access to certain functions.\n\n- `setOwner`: Sets the owner of the contract.\n- `onlyOwner`: Modifier that restricts access to the contract owner.\n\n**solmate/tokens/ERC20.sol**\n\nThe ERC20.sol file is a library that provides functions for interacting with ERC20 tokens. It includes functions for transferring tokens, approving token allowances, and querying token balances and allowances.\n\n- `transfer`: Transfers a specified amount of tokens to a specified address.\n- `approve`: Approves a specified amount of tokens for a specified address.\n- `balanceOf`: Returns the token balance of a specified address.\n- `allowance`: Returns the token allowance for a specified address.\n\n**src/PrivatePoolMetadata.sol**\n\nThe PrivatePoolMetadata.sol file is a contract that manages the metadata for private pools. It includes functions for setting and getting metadata, as well as events for tracking metadata changes.\n\n- `setMetadata`: Sets the metadata for a specified pool.\n- `getMetadata`: Returns the metadata for a specified pool.\n- `MetadataSet`: Event emitted when metadata is set for a pool.",
          "content": "- **royalty-registry-solidity/IRoyaltyRegistry.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solady/utils/LibClone.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n- **solady/utils/MerkleProofLib.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solmate/auth/Owned.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n- **solmate/tokens/ERC20.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)",
          "tokens": {
            "summary": 750,
            "content": 317
          }
        },
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The following is a detailed and technical summary of the content provided:\n\n1. PrivatePoolMetadata.sol\nThis file is a Solidity contract that defines the metadata for private pools. It imports the \"IERC721Metadata.sol\" interface and extends the \"ERC721.sol\" contract. The contract contains a constructor that takes a string argument for the token name and symbol. It also contains a function \"tokenURI\" that takes a uint256 tokenId as an argument and returns a string. This function is used to retrieve the metadata URI for a given token ID.\n\n2. solmate/tokens/ERC721.sol\nThis file is a Solidity contract that implements the ERC721 standard for non-fungible tokens (NFTs). It imports the \"IERC721.sol\" and \"IERC721Metadata.sol\" interfaces, as well as the \"Address.sol\" and \"Strings.sol\" utility libraries. The contract contains various functions for managing NFTs, such as minting, transferring, and approving tokens. It also includes events for Transfer, Approval, and ApprovalForAll.\n\n3. EthRouter.sol\nThis file is a Solidity contract that acts as a router for handling ETH transactions. It imports the \"IERC20.sol\" interface and the \"SafeTransferLib.sol\" utility library. The contract contains a constructor that takes an address argument for the WETH token. It also contains functions for wrapping and unwrapping ETH, as well as transferring ETH and ERC20 tokens.\n\n4. Factory.sol\nThis file is a Solidity contract that acts as a factory for creating new private pool instances. It imports the \"PrivatePool.sol\" contract and the \"SafeTransferLib.sol\" utility library. The contract contains a constructor that takes an address argument for the WETH token. It also contains a function \"createPool\" that takes various pool configuration parameters and returns a new private pool instance.\n\n5. PrivatePool.sol\nThis file is a Solidity contract that defines the logic for private pools. It imports the \"IERC20.sol\" interface, the \"FixedPointMathLib.sol\" utility library, and the \"PrivatePoolMetadata.sol\" contract. The contract contains various functions for managing the private pool, such as depositing, withdrawing, and claiming rewards. It also includes events for Deposit, Withdraw, and RewardPaid.\n\n6. solmate/utils/FixedPointMathLib.sol\nThis file is a Solidity library that provides fixed-point math operations. It contains various functions for performing arithmetic operations, such as addition, subtraction, multiplication, and division, with fixed-point numbers.\n\n7. solmate/utils/SafeTransferLib.sol\nThis file is a Solidity library that provides safe transfer functions for ERC20 tokens and ETH. It imports the \"IERC20.sol\" interface and the \"Address.sol\" utility library. The library contains functions for safely transferring ERC20 tokens and ETH, as well as checking the return values of transfer functions to ensure they are successful.",
          "content": "- [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **solmate/tokens/ERC721.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **solmate/utils/FixedPointMathLib.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solmate/utils/SafeTransferLib.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)",
          "tokens": {
            "summary": 599,
            "content": 297
          }
        },
        "EthRouter Factory PrivatePool": {
          "title": "EthRouter Factory PrivatePool",
          "summary": "The following is a detailed and technical summary of the content in the provided Solidity files:\n\n1. EthRouter.sol\n\nEthRouter.sol is a Solidity contract that acts as a router for handling Ether transactions. It imports the IERC20 interface from the OpenZeppelin library and the IPrivatePool interface from the PrivatePool.sol file. The contract has a constructor that takes an address parameter (_factory) and initializes the factory variable with the provided address.\n\nThe contract has the following functions:\n\n- addLiquidity: This function allows users to add liquidity to a private pool by depositing Ether. It takes the following parameters: token (address), pool (address), amountTokenDesired (uint256), amountTokenMin (uint256), amountETHMin (uint256), and deadline (uint256). The function checks if the deadline has not passed, transfers the desired token amount from the user to the pool, and then calls the `deposit` function of the private pool with the appropriate parameters.\n\n- removeLiquidity: This function allows users to remove liquidity from a private pool by withdrawing Ether. It takes the following parameters: token (address), pool (address), liquidity (uint256), amountTokenMin (uint256), amountETHMin (uint256), and deadline (uint256). The function checks if the deadline has not passed, transfers the liquidity from the user to the pool, and then calls the `withdraw` function of the private pool with the appropriate parameters.\n\n- swapExactTokensForETH: This function allows users to swap tokens for Ether. It takes the following parameters: amountIn (uint256), amountOutMin (uint256), path (address[]), and deadline (uint256). The function checks if the deadline has not passed, transfers the input tokens from the user to the first pool in the path, and then calls the `swap` function of the private pool with the appropriate parameters.\n\n- swapETHForExactTokens: This function allows users to swap Ether for tokens. It takes the following parameters: amountOut (uint256), amountInMax (uint256), path (address[]), and deadline (uint256). The function checks if the deadline has not passed, transfers the input Ether from the user to the first pool in the path, and then calls the `swap` function of the private pool with the appropriate parameters.\n\n2. Factory.sol\n\nFactory.sol is a Solidity contract that acts as a factory for creating and managing private pools. It imports the IERC20 interface from the OpenZeppelin library and the PrivatePool contract from the PrivatePool.sol file. The contract has a constructor that takes an address parameter (_router) and initializes the router variable with the provided address.\n\nThe contract has the following functions:\n\n- createPool: This function creates a new private pool with the provided token address and returns the address of the created pool. It deploys a new PrivatePool contract with the token address and router address, and emits a PoolCreated event.\n\n- getPool: This function takes a token address and returns the corresponding private pool address.\n\n- allPools: This function takes an index (uint256) and returns the address of the private pool at that index.\n\n- allPoolsLength: This function returns the total number of private pools created by the factory.\n\n3. PrivatePool.sol\n\nPrivatePool.sol is a Solidity contract that represents a private pool for a specific token. It imports the IERC20 interface from the OpenZeppelin library and the ReentrancyGuard contract from the OpenZeppelin library. The contract has a constructor that takes two address parameters (_token and _router) and initializes the token and router variables with the provided addresses.\n\nThe contract has the",
          "content": "- [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)",
          "tokens": {
            "summary": 750,
            "content": 97
          }
        },
        "Scoping Details Summary": {
          "title": "Scoping Details Summary",
          "summary": "The term \"scoping\" refers to the process of defining the boundaries, objectives, and requirements of a project, task, or system. It is a crucial step in project management, software development, and engineering, as it helps to ensure that all stakeholders have a clear understanding of what needs to be achieved and the resources required to accomplish the goals. This summary will provide a detailed and technical overview of scoping details, including its importance, key components, and best practices.\n\nImportance of Scoping:\n\nScoping is essential for several reasons:\n\n1. Clarity: It provides a clear understanding of the project's goals, objectives, and requirements, ensuring that all stakeholders are on the same page.\n\n2. Resource Allocation: Scoping helps in determining the resources required for the project, such as time, budget, and personnel, which aids in effective planning and management.\n\n3. Risk Management: By identifying potential risks and challenges early in the project, scoping allows for proactive risk mitigation strategies.\n\n4. Quality Control: A well-defined scope ensures that the project's deliverables meet the desired quality standards and expectations.\n\n5. Change Management: Scoping helps in managing changes effectively by providing a baseline against which any proposed changes can be evaluated.\n\nKey Components of Scoping:\n\n1. Project Objectives: Clearly defined objectives help in setting the direction and focus of the project. They should be specific, measurable, achievable, relevant, and time-bound (SMART).\n\n2. Scope Statement: A scope statement is a detailed description of the project's deliverables, including their features, functions, and characteristics. It should also outline any exclusions or constraints that may impact the project.\n\n3. Work Breakdown Structure (WBS): The WBS is a hierarchical decomposition of the project's scope into manageable tasks or work packages. It helps in organizing and assigning responsibilities, estimating costs and durations, and tracking progress.\n\n4. Stakeholder Analysis: Identifying and understanding the needs and expectations of all stakeholders is crucial for successful scoping. This includes clients, end-users, team members, and any other parties who may be affected by the project.\n\n5. Risk Assessment: A thorough risk assessment helps in identifying potential risks and challenges that may impact the project's scope, schedule, or budget. This allows for proactive risk mitigation strategies and contingency planning.\n\nBest Practices for Scoping:\n\n1. Involve Stakeholders: Engage all relevant stakeholders in the scoping process to ensure their needs and expectations are considered and addressed.\n\n2. Use a Structured Approach: Utilize a systematic approach, such as the WBS, to break down the project scope into manageable tasks or work packages.\n\n3. Document Everything: Maintain detailed documentation of the scoping process, including scope statements, WBS, stakeholder analysis, and risk assessments. This will serve as a reference for future decision-making and change management.\n\n4. Review and Validate: Regularly review and validate the project scope with stakeholders to ensure it remains accurate and relevant throughout the project lifecycle.\n\n5. Be Flexible: Be prepared to adapt and revise the project scope as new information becomes available or as circumstances change. This will help in managing changes effectively and ensuring the project's success.\n\nIn conclusion, scoping is a critical aspect of project management, software development, and engineering that helps in defining the boundaries, objectives, and requirements of a project. By following best practices and incorporating key components such as project objectives, scope statements, WBS, stakeholder analysis, and risk assessments, scoping can significantly contribute to the success of a project by providing clarity, facilitating resource allocation, managing risks, ensuring quality control, and enabling effective change management.",
          "content": "Scoping Details",
          "tokens": {
            "summary": 734,
            "content": 3
          }
        },
        "NFT Inheritance Audit": {
          "title": "NFT Inheritance Audit",
          "summary": "The content provided describes a project with a public code repository that consists of four contracts within scope, totaling 725 lines of code. There are 12 external imports, three separate interfaces, and struct definitions for the contracts. The code primarily uses inheritance rather than composition, and there are 10 external calls.\n\nAlthough the overall line coverage percentage provided by tests is not available, it is mentioned that the EthRouter contract routes trades to Caviar public pools (in addition to private pools). The public pools can be found at the following GitHub repository: https://github.com/outdoteth/caviar. To audit this part of the protocol, it is necessary to understand the context of the EthRouter contract and its interaction with the Caviar public pools.\n\nThe project does not use an oracle, and there is no information provided about the token conforming to the ERC20 standard. There are no novel or unique curve logic or mathematical models, and the project does not use a timelock function. However, it is mentioned that the project involves a non-fungible token (NFT).",
          "content": "```\n- If you have a public code repo, please share it here:\n- How many contracts are in scope?:   4\n- Total SLoC for these contracts?:  725\n- How many external imports are there?:  12\n- How many separate interfaces and struct definitions are there for the contracts within scope?:  3\n- Does most of your code generally use composition or inheritance?:   inheritance\n- How many external calls?:   10\n- What is the overall line coverage percentage provided by your tests?:  N/a\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?:   Caviar public pools: https://github.com/outdoteth/caviar\n- Please describe required context:   The EthRouter contract routes trades to caviar public pools (in addition to private pools)\n- Does it use an oracle?:  no\n- Does the token conform to the ERC20 standard?:  N/a\n- Are there any novel or unique curve logic or mathematical models?: no\n- Does it use a timelock function?:  no\n- Is it an NFT?: Yes",
          "tokens": {
            "summary": 219,
            "content": 247
          }
        },
        "NFT AMM Unique": {
          "title": "NFT AMM Unique",
          "summary": "The content discusses a project that features a non-fungible token (NFT) and an automated market maker (AMM). However, it does not conform to the ERC20 standard, as it is an NFT, which typically follows the ERC721 or ERC1155 standards. The project does not involve any novel or unique curve logic or mathematical models, nor does it use a timelock function. It is not a fork of a popular project, and it does not utilize rollups, side-chains, or multi-chain functionality.",
          "content": "- Does the token conform to the ERC20 standard?:  N/a\n- Are there any novel or unique curve logic or mathematical models?: no\n- Does it use a timelock function?:  no\n- Is it an NFT?: Yes\n- Does it have an AMM?:   Yes\n- Is it a fork of a popular project?:   No\n- Does it use rollups?:   No\n- Is it multi-chain?:  No\n- Does it use a side-chain?: No\n```",
          "tokens": {
            "summary": 109,
            "content": 106
          }
        },
        "Slither Forge Bug": {
          "title": "Slither Forge Bug",
          "summary": "The content discusses two known issues related to specific software tools, namely Slither and Forge. \n\n1. Slither Issue: Slither is a static analysis tool for smart contracts that helps identify vulnerabilities and coding issues. The mentioned bug (https://github.com/crytic/slither/issues/1737) prevents the tool from running correctly. The link provided directs to the GitHub repository of Slither, where the issue is documented and tracked. Users experiencing this issue can visit the link to gain more information about the problem, potential workarounds, and updates on the resolution.\n\n2. Forge Issue: Forge is a software development tool used for building and testing applications. The issue mentioned (https://github.com/foundry-rs/foundry/issues/3357) is related to generating coverage reports using Forge. Coverage reports are essential for developers to understand the effectiveness of their tests and identify areas of the code that may require additional testing. The provided link directs to the GitHub repository of Foundry, where the issue is documented and tracked. Users encountering this issue can visit the link to learn more about the problem, possible solutions, and updates on the resolution.",
          "content": "Known issues\n\n- There is a bug related to slither that prevents it from running correctly. More info can be found here: https://github.com/crytic/slither/issues/1737\n\n- There is a bug related to generating coverage reports with forge. More info can be found here: https://github.com/foundry-rs/foundry/issues/3357",
          "tokens": {
            "summary": 232,
            "content": 76
          }
        }
      }
    }
  },
  "solidity": {
    "spearbot-node/put_files_to_audit_here/solidity/EthRouter.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/EthRouter.sol",
      "globalSummary": "The Eth Router contract enables users to execute buy, sell, and change orders for NFTs in multiple public or private pools within a single transaction. It supports native ETH as the base token and uses SafeTransferLib for secure transfers. The contract checks for deadlines, handles royalty payments, and manages NFT transfers and approvals between users and pools. It also refunds surplus ETH and ensures royalty fees do not exceed the sale price.",
      "chunkedSummaries": {
        "IERC2981 Solmate Utils": {
          "title": "IERC2981 Solmate Utils",
          "summary": "The content provided is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two libraries and an interface, which are used to create and manage Non-Fungible Tokens (NFTs) and handle royalty payments.\n\n1. Importing IERC2981 Interface:\nThe first line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a widely-used library for secure smart contract development on the Ethereum blockchain. The IERC2981 interface is an Ethereum Improvement Proposal (EIP) that standardizes royalty payments for NFTs. By implementing this interface, the smart contract can handle royalty payments for NFT creators whenever their tokens are sold or transferred.\n\n2. Importing ERC721 and ERC721TokenReceiver:\nThe next import statement brings in the ERC721 and ERC721TokenReceiver contracts from the Solmate library. ERC721 is a widely-adopted standard for creating and managing NFTs on the Ethereum blockchain. The ERC721TokenReceiver contract is an interface that ensures the recipient of an NFT transfer can handle and accept the token.\n\n3. Importing SafeTransferLib:\nThe last import statement includes the SafeTransferLib from the Solmate library. This library provides utility functions for safely transferring tokens, ensuring that the recipient is capable of receiving the tokens and preventing accidental loss of tokens during transfers.\n\nIn summary, this code snippet imports essential components for creating and managing NFTs on the Ethereum blockchain, implementing royalty payments for NFT creators, and ensuring safe token transfers. The imported components include the IERC2981 interface for royalty payments, the ERC721 and ERC721TokenReceiver contracts for NFT creation and management, and the SafeTransferLib for secure token transfers.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";",
          "tokens": {
            "summary": 357,
            "content": 353
          }
        },
        "Private Pool Registry": {
          "title": "Private Pool Registry",
          "summary": "The given content is a snippet of Solidity code that imports various interfaces and contracts from different libraries. Solidity is a high-level programming language used for implementing smart contracts on Ethereum and other blockchain platforms.\n\n1. `import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";`\n\nThis line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a widely-used library for secure smart contract development on Ethereum. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs). This standard allows NFT creators to receive royalties for secondary sales of their tokens.\n\n2. `import {Pair, ReservoirOracle} from \"caviar/Pair.sol\";`\n\nThis line imports two contracts, Pair and ReservoirOracle, from the Caviar library's Pair.sol file. Caviar is a library for creating and managing liquidity pools on decentralized finance (DeFi) platforms. The Pair contract is used to create and manage token pairs for trading, while the ReservoirOracle contract is used to provide price data for the token pairs.\n\n3. `import {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";`\n\nThis line imports the IRoyaltyRegistry interface from the Royalty Registry Solidity library. The Royalty Registry is a smart contract system that allows NFT creators to register their royalty information, making it easier for marketplaces and other platforms to access and distribute royalties according to the ERC-2981 standard.\n\n4. `import {PrivatePool} from \"./PrivatePool.sol\";`\n\nThis line imports the PrivatePool contract from the local file PrivatePool.sol. The PrivatePool contract is not part of any external library, and its implementation details are not provided in the given content. However, based on the name, it can be inferred that this contract might be related to creating and managing private liquidity pools in a DeFi platform.\n\nIn summary, the given code snippet imports various interfaces and contracts related to NFT royalties, liquidity pools, and price oracles from well-known libraries such as OpenZeppelin and Caviar. These imported contracts and interfaces can be used to build a smart contract system that combines NFT royalties with DeFi functionalities, such as trading and liquidity provision.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";",
          "tokens": {
            "summary": 480,
            "content": 70
          }
        },
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given content is a single line of code written in Solidity, a programming language used for implementing smart contracts on various blockchain platforms, most notably Ethereum. This line of code is importing an interface called `IStolenNftOracle` from a file named `IStolenNftOracle.sol`.\n\nAn interface in Solidity is a collection of function signatures that a contract must implement. It is a way to define the structure and behavior that a smart contract should have, without providing the actual implementation. Other contracts can then inherit and implement this interface, ensuring that they adhere to the specified structure.\n\nIn this case, the `IStolenNftOracle` interface is likely defining a set of functions related to handling stolen non-fungible tokens (NFTs) on a blockchain. An oracle, in the context of blockchain, is a service that provides external data to smart contracts. So, the `IStolenNftOracle` interface might be defining the structure for a smart contract that acts as an oracle for stolen NFTs, providing information about whether a specific NFT has been reported as stolen or not.\n\nThe file `IStolenNftOracle.sol` is expected to contain the actual definition of the `IStolenNftOracle` interface, including the function signatures that need to be implemented by any contract that inherits this interface. By importing this interface, the developer can use it in their smart contract to ensure that the contract adheres to the expected structure and behavior for handling stolen NFTs.",
          "content": "import {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";",
          "tokens": {
            "summary": 308,
            "content": 20
          }
        },
        "Eth Router Contract": {
          "title": "Eth Router Contract",
          "summary": "The EthRouter contract, authored by out.eth, is designed to route buy, sell, and change orders to multiple pools in a single transaction. The orders can be directed to either a private or a public pool. If an order is sent to a public pool, users have the option to pay royalties. The only supported base token is native ETH.\n\nThe contract utilizes the ERC721TokenReceiver and SafeTransferLib libraries. It defines three structs: Buy, Sell, and Change. The Buy struct contains information about the pool, NFT, token IDs, token weights, MerkleMultiProof, base token amount, and a boolean indicating if it is a public pool. The Sell struct contains similar information, with the addition of stolenNftProofs and publicPoolProofs. The Change struct includes input and output token IDs, weights, and proofs, as well as stolenNftProofs.\n\nThe contract also defines four custom errors: DeadlinePassed, OutputAmountTooSmall, PriceOutOfRange, and InvalidRoyaltyFee. The royaltyRegistry address is set as an immutable public variable.\n\nThe contract includes a receive() function to accept external payments.",
          "content": "/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}",
          "tokens": {
            "summary": 229,
            "content": 354
          }
        },
        "Royalty Registry Constructor": {
          "title": "Royalty Registry Constructor",
          "summary": "The given code snippet is a constructor function in Solidity, which is a programming language used for writing smart contracts on the Ethereum blockchain. The constructor function is a special type of function that is called only once when a smart contract is deployed. It is used to initialize the state variables of the contract.\n\nIn this specific constructor, there is one input parameter: an address variable named \"_royaltyRegistry\". The purpose of this constructor is to initialize the state variable \"royaltyRegistry\" with the value of the input parameter \"_royaltyRegistry\".\n\nHere's a detailed breakdown of the code:\n\n1. `constructor(address _royaltyRegistry)`: This line defines the constructor function and its input parameter. The keyword \"constructor\" indicates that this is a constructor function. The input parameter is of type \"address\" and is named \"_royaltyRegistry\".\n\n2. `{`: This opening curly brace marks the beginning of the constructor function's body.\n\n3. `royaltyRegistry = _royaltyRegistry;`: This line assigns the value of the input parameter \"_royaltyRegistry\" to the state variable \"royaltyRegistry\". This initializes the state variable with the provided value.\n\n4. `}`: This closing curly brace marks the end of the constructor function's body.\n\nIn summary, this constructor function initializes the \"royaltyRegistry\" state variable with the provided address value when the smart contract is deployed.",
          "content": "constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }",
          "tokens": {
            "summary": 279,
            "content": 19
          }
        },
        "Buy Operations Execution": {
          "title": "Buy Operations Execution",
          "summary": "The given code snippet is a Solidity function called `buy` that executes a series of buy operations against public or private pools in a decentralized marketplace for non-fungible tokens (NFTs). The function takes three input parameters: an array of `Buy` structs, a `deadline` for the transaction to be mined, and a boolean flag `payRoyalties` to indicate whether royalties should be paid or not.\n\nThe function first checks if the deadline has passed (if it's not set to 0) and reverts the transaction if the condition is met. Then, it iterates through the `buys` array and executes each buy operation. If the buy operation is against a public pool, it calculates the input amount by calling the `nftBuy` function on the pool contract and pays royalties if the buyer has opted-in. The royalties are calculated based on the sale price and the royalty fee and recipient are fetched using the `getRoyalty` function. The royalty fee is then transferred to the royalty recipient.\n\nIf the buy operation is against a private pool, the function calls the `buy` function on the private pool contract with the required parameters. After executing the buy operation, the function transfers the NFTs to the caller using the `safeTransferFrom` function of the ERC721 contract.\n\nFinally, if there is any surplus ETH left in the contract, it is refunded to the caller using the `safeTransferETH` function.",
          "content": "/// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }",
          "tokens": {
            "summary": 294,
            "content": 528
          }
        },
        "Sell Operations Execution": {
          "title": "Sell Operations Execution",
          "summary": "The given code defines a `sell` function that executes a series of sell operations against public or private pools in a decentralized marketplace for non-fungible tokens (NFTs). The function takes four parameters:\n\n1. `sells`: An array of sell operations to execute.\n2. `minOutputAmount`: The minimum amount of output tokens that must be received for the transaction to succeed.\n3. `deadline`: The deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. A value of 0 indicates no deadline.\n4. `payRoyalties`: A boolean value indicating whether to pay royalties or not.\n\nThe function first checks if the deadline has passed (if any) and reverts if it has. It then loops through the sell operations and transfers the NFTs from the caller to the router. The router approves the pool to transfer NFTs on its behalf.\n\nFor each sell operation, the function checks if it is against a public pool or a private pool. If it is a public pool, the function executes the sell against the public pool and calculates the output amount. If the seller has opted to pay royalties, the function calculates the royalty fee and recipient for each NFT and transfers the royalty fee to the recipient.\n\nIf the sell operation is against a private pool, the function executes the sell against the private pool.\n\nAfter all sell operations are executed, the function checks if the output amount is greater than the minimum required amount. If not, it reverts. Finally, the function transfers the output amount to the caller.",
          "content": "/// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }",
          "tokens": {
            "summary": 321,
            "content": 667
          }
        },
        "Private Pool Deposit": {
          "title": "Private Pool Deposit",
          "summary": "The given code snippet is a function called `deposit` that allows a user to deposit Non-Fungible Tokens (NFTs) and Ether (ETH) into a private pool. The function takes the following parameters:\n\n1. `privatePool`: The address of the private pool to deposit to.\n2. `nft`: The contract address of the NFT.\n3. `tokenIds`: An array of token IDs representing the NFTs to be deposited.\n4. `minPrice`: The minimum price of the pool. The function will revert if the pool's price is smaller than this value.\n5. `maxPrice`: The maximum price of the pool. The function will revert if the pool's price is greater than this value.\n6. `deadline`: A timestamp representing the deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. If set to 0, the deadline will be ignored.\n\nThe function first checks if the deadline has passed (if it is not set to 0) and reverts with a `DeadlinePassed` error if it has. Next, it checks if the pool's price is within the specified range (between `minPrice` and `maxPrice`) and reverts with a `PriceOutOfRange` error if it is not.\n\nThe function then iterates through the `tokenIds` array and transfers each NFT from the caller to the contract using the `safeTransferFrom` function of the ERC721 standard. After transferring the NFTs, the function sets approval for the private pool to transfer NFTs from the router using the `setApprovalForAll` function.\n\nFinally, the function executes the deposit by calling the `deposit` function of the `PrivatePool` contract, passing the `tokenIds` array and the Ether value sent with the transaction.",
          "content": "/// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }",
          "tokens": {
            "summary": 374,
            "content": 368
          }
        },
        "Private Pool Change": {
          "title": "Private Pool Change",
          "summary": "The given code snippet defines a `change` function that executes a series of change operations against a private pool in a smart contract. The function takes two input parameters: an array of `Change` objects called `changes`, and a `deadline` represented as a uint256.\n\nThe function first checks if the current block timestamp is greater than the deadline, and if so, it reverts the transaction with a `DeadlinePassed` error. If the deadline is set to 0, this check is ignored.\n\nNext, the function iterates through the `changes` array and processes each change operation. For each change, it transfers the input NFTs (Non-Fungible Tokens) from the caller to the smart contract using the `safeTransferFrom` function of the ERC721 standard. It then approves the private pool to transfer NFTs from the router by calling the `setApprovalForAll` function of the ERC721 standard.\n\nAfter that, the function executes the change operation by calling the `change` function of the `PrivatePool` contract, passing the necessary parameters such as input and output token IDs, weights, and proofs.\n\nOnce the change operation is executed, the function transfers the output NFTs back to the caller using the `safeTransferFrom` function of the ERC721 standard.\n\nFinally, if there is any remaining ETH balance in the smart contract, it is refunded to the caller using the `safeTransferETH` function.",
          "content": "/// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }",
          "tokens": {
            "summary": 291,
            "content": 402
          }
        },
        "Royalty Fee Recipient": {
          "title": "Royalty Fee Recipient",
          "summary": "The given content describes a function called `getRoyalty` that retrieves the royalty fee and recipient for a specific Non-Fungible Token (NFT) and its sale price. This function is part of a smart contract and uses the Manifold Registry to look up the royalty information.\n\nThe function takes three input parameters:\n\n1. `address nft`: The address of the NFT.\n2. `uint256 tokenId`: The unique identifier of the NFT.\n3. `uint256 salePrice`: The sale price of the NFT.\n\nThe function returns two output values:\n\n1. `uint256 royaltyFee`: The royalty fee to be paid.\n2. `address recipient`: The address to which the royalty fee should be paid.\n\nThe function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the state of the blockchain.\n\nInside the function, the royalty lookup address is obtained by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the NFT address as an argument. The `IRoyaltyRegistry` interface is a contract that defines the functions for interacting with the Manifold Registry, which stores the royalty information for NFTs.\n\nIn summary, the `getRoyalty` function is a smart contract function that retrieves the royalty fee and recipient for a given NFT and its sale price using the Manifold Registry.",
          "content": "/// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);",
          "tokens": {
            "summary": 287,
            "content": 150
          }
        },
        "Royalty Fee Validation": {
          "title": "Royalty Fee Validation",
          "summary": "The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract, identified by its address (lookupAddress), supports the EIP-2981 standard for handling royalties in Non-Fungible Tokens (NFTs). If the contract supports this standard, the code retrieves the royalty information and ensures that the royalty fee is not greater than the sale price of the NFT.\n\n1. The first line checks if the contract at the lookupAddress supports the EIP-2981 standard by calling the supportsInterface function with the interfaceId of the IERC2981 type. If the contract supports the standard, the code inside the if block will be executed.\n\n2. Inside the if block, the royaltyInfo function of the IERC2981 contract is called with the tokenId and salePrice as arguments. This function returns the recipient address and the royalty fee associated with the NFT.\n\n3. The next line checks if the royalty fee is greater than the sale price of the NFT. If this condition is true, the code execution will be reverted with an InvalidRoyaltyFee error. This ensures that the royalty fee is always less than or equal to the sale price of the NFT.\n\nIn summary, this code snippet is used to verify if a contract supports the EIP-2981 standard for NFT royalties, retrieve the royalty information, and ensure that the royalty fee is valid with respect to the sale price of the NFT.",
          "content": "if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}",
          "tokens": {
            "summary": 304,
            "content": 92
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/Factory.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/Factory.sol",
      "globalSummary": "The Caviar Private Pool Factory is a smart contract used to create and initialize new private pools. Each time a private pool is created, an NFT representing that pool is minted to the creator. The contract also handles protocol fees, which accrue to the contract and can be withdrawn by the admin. The Factory contract uses the minimal proxy pattern to deploy private pool clones and allows for setting private pool metadata, implementation contracts, and protocol fee rates. Additionally, it provides functionality for withdrawing earned protocol fees and predicting deployment addresses of new private pools.",
      "chunkedSummaries": {
        "Caviar Pool Factory": {
          "title": "Caviar Pool Factory",
          "summary": "The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of new private pools. It is an ERC721 contract, which means that each private pool created is represented by a unique non-fungible token (NFT) minted to the creator. The contract is also owned, meaning that it has an admin who can withdraw the protocol fees that accrue to the contract.\n\nThe Factory contract uses the LibClone library for cloning the private pool implementation, and the SafeTransferLib for safely transferring tokens. It emits two events: Create, which is triggered when a new private pool is created, and Withdraw, which is triggered when the admin withdraws tokens from the contract.\n\nThe contract has a public variable, privatePoolImplementation, which stores the address of the private pool implementation that proxies point to. This allows for easy upgrades and modifications to the private pool implementation without affecting the existing private pools.",
          "content": "/// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;",
          "tokens": {
            "summary": 184,
            "content": 157
          }
        },
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The given code snippet is a Solidity function named `setPrivatePoolMetadata` that sets the address of a private pool metadata contract. This function is part of a smart contract and can only be executed by the contract owner, as indicated by the `onlyOwner` modifier.\n\nThe function takes one input parameter, `_privatePoolMetadata`, which is an address representing the private pool metadata contract. Inside the function, the value of the `_privatePoolMetadata` parameter is assigned to the `privatePoolMetadata` state variable, effectively updating the address of the private pool metadata contract.\n\nThe `@notice` and `@param` comments above the function provide additional information about the purpose and parameters of the function, which can be used to generate documentation or provide hints to developers using the function.",
          "content": "/// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }",
          "tokens": {
            "summary": 157,
            "content": 51
          }
        },
        "Caviar Private Pools": {
          "title": "Caviar Private Pools",
          "summary": "The given content is a Solidity code snippet representing a constructor function and a receive function for a smart contract. This smart contract is based on the Ethereum blockchain and utilizes the ERC721 standard for non-fungible tokens (NFTs). The constructor function initializes the contract with a name and symbol, while the receive function allows the contract to accept Ether payments.\n\n1. Constructor function:\n   The constructor function is defined as `constructor()`. It is a special function that is executed only once when the smart contract is deployed on the Ethereum blockchain. In this case, the constructor function takes no arguments.\n\n   Inside the constructor, there are three main components:\n\n   a. ERC721: This is a standard interface for non-fungible tokens (NFTs) on the Ethereum blockchain. The constructor initializes the contract with the given name \"Caviar Private Pools\" and symbol \"POOL\". This means that the NFTs created by this contract will have this name and symbol associated with them.\n\n   b. Owned: This is a contract modifier that ensures that only the owner of the contract can execute certain functions. In this case, the constructor sets the owner of the contract to be the address that deploys the contract, represented by `msg.sender`.\n\n2. Receive function:\n   The receive function is defined as `receive() external payable`. This function is a fallback function that is executed when the contract receives Ether without any data or when no other function matches the provided function signature. The `external` keyword indicates that this function can only be called from outside the contract, while the `payable` keyword allows the function to accept Ether payments.\n\n   In this case, the receive function is empty, meaning that it does not perform any specific actions when Ether is sent to the contract. However, the contract will still be able to accept and store Ether payments due to the `payable` keyword.",
          "content": "constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}",
          "tokens": {
            "summary": 383,
            "content": 26
          }
        },
        "Private Pool Creation": {
          "title": "Private Pool Creation",
          "summary": "The `create` function is used to create a new private pool using the minimal proxy pattern that points to the private pool implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool. The function takes several parameters, including the base token address, NFT address, virtual base token reserves, virtual NFT reserves, change fee, fee rate, Merkle root, whether to use the stolen NFT oracle, whether to pay royalties, salt, token IDs, and the base token amount.\n\nThe function first checks if the `msg.value` is equal to the base token amount if the base token is ETH or if the `msg.value` is equal to zero if the base token is not ETH. If the condition is not met, it reverts with an `InvalidEthAmount` error.\n\nNext, the function deploys a minimal proxy clone of the private pool implementation and mints the NFT to the caller. It then initializes the pool with the provided parameters.\n\nIf the base token is ETH, the function transfers ETH into the pool. Otherwise, it deposits the base tokens from the caller into the pool. It then deposits the NFTs from the caller into the pool using a loop.\n\nFinally, the function emits a `Create` event with the private pool address, token IDs, and base token amount. The function returns the address of the created private pool.",
          "content": "/// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }",
          "tokens": {
            "summary": 284,
            "content": 702
          }
        },
        "Private Pool Implementation": {
          "title": "Private Pool Implementation",
          "summary": "The given code snippet is a Solidity function named `setPrivatePoolImplementation` that is responsible for setting the private pool implementation contract address for newly deployed proxies. This function takes an input parameter `_privatePoolImplementation`, which is the address of the private pool implementation contract. The function is marked as `public`, meaning it can be called by any external entity, and it has a modifier `onlyOwner`, which restricts its execution to only the contract owner.\n\nInside the function, the private state variable `privatePoolImplementation` is assigned the value of the input parameter `_privatePoolImplementation`. This effectively updates the private pool implementation contract address that will be used by newly deployed proxies.",
          "content": "/// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }",
          "tokens": {
            "summary": 136,
            "content": 58
          }
        },
        "Set Protocol Fee": {
          "title": "Set Protocol Fee",
          "summary": "The given code snippet is a Solidity function called `setProtocolFeeRate` that sets the protocol fee rate for a specific smart contract. This function is part of a larger smart contract, which is not provided in the snippet.\n\nThe function takes a single input parameter, `_protocolFeeRate`, which is a 16-bit unsigned integer representing the protocol fee rate in basis points. For example, a value of 350 would represent a 3.5% fee rate.\n\nThe function is marked as `public`, meaning it can be called by any external entity interacting with the smart contract. However, it also has a modifier `onlyOwner`, which restricts the execution of the function to the owner of the smart contract only. This ensures that only the owner can change the protocol fee rate.\n\nInside the function, the value of the input parameter `_protocolFeeRate` is assigned to the state variable `protocolFeeRate`. This updates the protocol fee rate for the smart contract, which will be used in other parts of the contract to calculate fees on buy, sell, or change operations.",
          "content": "/// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }",
          "tokens": {
            "summary": 218,
            "content": 73
          }
        },
        "Withdraw Protocol Fees": {
          "title": "Withdraw Protocol Fees",
          "summary": "The given code snippet is a Solidity function named `withdraw` that is part of a smart contract. The purpose of this function is to withdraw the earned protocol fees in the form of a specified token and amount. The function has two input parameters: `token` and `amount`. The `token` parameter is an address type, representing the token to be withdrawn, while the `amount` parameter is a uint256 type, representing the amount of tokens to be withdrawn.\n\nThe function has a `public` visibility, meaning it can be called from any external source, and it also has a modifier `onlyOwner`, which restricts the access to this function only to the owner of the contract.\n\nInside the function, there is a conditional statement that checks if the provided `token` address is equal to the zero address (address(0)). If it is, this means that the token to be withdrawn is Ether (ETH), and the function proceeds to transfer the specified `amount` of Ether to the sender of the transaction using the `safeTransferETH` function. This function ensures that the transfer is done safely, preventing potential reentrancy attacks.\n\nIf the `token` address is not equal to the zero address, this means that the token to be withdrawn is an ERC20 token. In this case, the function calls the `transfer` function of the ERC20 token contract, passing the sender's address and the specified `amount` as arguments. This transfers the specified amount of the ERC20 token to the sender.\n\nFinally, the function emits an event named `Withdraw`, which logs the token address and the amount withdrawn. This event can be used by external applications to monitor and track the withdrawals made using this function.",
          "content": "/// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }",
          "tokens": {
            "summary": 346,
            "content": 88
          }
        },
        "Token URI Function": {
          "title": "Token URI Function",
          "summary": "The given code snippet is a function named `tokenURI` written in Solidity, which is a programming language used for implementing smart contracts on the Ethereum blockchain. This function is a part of a larger smart contract, and its purpose is to return the token URI (Uniform Resource Identifier) for a specific token based on its unique identifier (token id).\n\nThe function takes a single input parameter, `id`, which is a 256-bit unsigned integer representing the unique identifier of the token. The function is marked as `public`, meaning it can be called from outside the smart contract, and `view`, which indicates that it does not modify the state of the contract. The `override` keyword is used to indicate that this function is intended to override a function with the same name in a parent contract.\n\nThe function returns a single output, a string in memory, which represents the token URI. Inside the function, it calls the `tokenURI` function of another smart contract, `PrivatePoolMetadata`, passing the input `id` as an argument. The address of the `PrivatePoolMetadata` contract is typecasted to ensure it implements the required interface. The result of this function call is then returned as the output of the `tokenURI` function.\n\nIn summary, the `tokenURI` function is a public view function that takes a token id as input and returns the corresponding token URI by calling the `tokenURI` function of another smart contract, `PrivatePoolMetadata`.",
          "content": "/// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }",
          "tokens": {
            "summary": 297,
            "content": 63
          }
        },
        "Predict Pool Address": {
          "title": "Predict Pool Address",
          "summary": "The given code snippet is a function named `predictPoolDeploymentAddress` that predicts the deployment address of a new private pool in a blockchain-based system. This function takes a single input parameter, `salt`, which is a 32-byte value (bytes32) that will be used during the deployment process. The function returns a single output, `predictedAddress`, which is the predicted deployment address of the private pool.\n\nThe function is marked as `public`, meaning it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract and can only read from it.\n\nInside the function, the `predictedAddress` variable is assigned the result of calling the `predictDeterministicAddress` function on the `privatePoolImplementation` object. This function takes two input parameters: the `salt` value provided to the `predictPoolDeploymentAddress` function, and the address of the current contract instance (retrieved using `address(this)`).\n\nIn summary, the `predictPoolDeploymentAddress` function is a public view function that predicts the deployment address of a new private pool by using a provided salt value and the address of the current contract instance. It does this by calling the `predictDeterministicAddress` function on a `privatePoolImplementation` object and returning the resulting predicted address.",
          "content": "/// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}",
          "tokens": {
            "summary": 267,
            "content": 81
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/IStolenNftOracle.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/IStolenNftOracle.sol",
      "globalSummary": "The IStolenNftOracle interface in Solidity defines a structure for messages and a function to validate that a set of token IDs have not been marked as stolen by the oracle. The function takes the token contract address, token IDs, and proofs as input parameters.",
      "chunkedSummaries": {
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given content represents an interface called `IStolenNftOracle` in a programming context, most likely in the Solidity language used for writing smart contracts on the Ethereum blockchain. An interface is a collection of function signatures that a contract must implement, acting as a blueprint for the structure of a contract.\n\nIn this case, the `IStolenNftOracle` interface is designed to provide a standard for contracts that interact with stolen Non-Fungible Tokens (NFTs) and their related information. NFTs are unique digital assets that represent ownership of a specific item or piece of content on the blockchain.\n\nThe interface does not provide any specific function implementations or details about the functions themselves. Instead, it serves as a template for developers to create their own contracts that adhere to the `IStolenNftOracle` structure. By implementing this interface, developers can ensure that their contracts are compatible with other contracts and systems that also use the `IStolenNftOracle` interface.\n\nTo summarize, the `IStolenNftOracle` interface is a blueprint for creating smart contracts that interact with stolen NFTs on the Ethereum blockchain. It provides a standard for developers to follow, ensuring compatibility and interoperability between different contracts and systems that work with stolen NFTs.",
          "content": "interface IStolenNftOracle {",
          "tokens": {
            "summary": 260,
            "content": 8
          }
        },
        "Message Signature Timestamp": {
          "title": "Message Signature Timestamp",
          "summary": "The given content is a Solidity code snippet that defines a struct called \"Message\" within a smart contract. This struct is used to represent a message object with specific properties in the Ethereum blockchain. The properties of the Message struct are as follows:\n\n1. `bytes32 id`: This is a unique identifier for the message, represented as a 32-byte long fixed-size array of bytes.\n2. `bytes payload`: This is the actual content of the message, represented as a dynamically-sized array of bytes.\n3. `uint256 timestamp`: This is a timestamp indicating when the message was signed by the oracle. It is represented as an unsigned 256-bit integer, which is a common representation for UNIX timestamps in Solidity.\n4. `bytes signature`: This is the digital signature of the message, which can be either an ECDSA signature or an EIP-2098 compact signature. It is represented as a dynamically-sized array of bytes.\n\nThe purpose of this struct is to store and manage the information related to a message in the context of a blockchain oracle. An oracle is a trusted third-party service that provides external data to smart contracts on the blockchain. In this case, the Message struct is part of the Reservoir Oracle smart contract, which is a component of the Reservoir Protocol.",
          "content": "// copied from https://github.com/reservoirprotocol/oracle/blob/main/contracts/ReservoirOracle.sol\n    struct Message {\n        bytes32 id;\n        bytes payload;\n        // The UNIX timestamp when the message was signed by the oracle\n        uint256 timestamp;\n        // ECDSA signature or EIP-2098 compact signature\n        bytes signature;\n    }",
          "tokens": {
            "summary": 260,
            "content": 74
          }
        },
        "Validate Not Stolen": {
          "title": "Validate Not Stolen",
          "summary": "The given content describes a function called `validateTokensAreNotStolen` in a smart contract. This function is responsible for validating that a set of token ids have not been marked as stolen by an oracle. An oracle is an external data source that provides information to smart contracts.\n\nThe function takes three input parameters:\n\n1. `tokenAddress`: This is the address of the token contract, which is a unique identifier for the token on the blockchain.\n2. `tokenIds`: This is an array of token ids that need to be validated. Each token id is a unique identifier for a specific token.\n3. `proofs`: This is an array of signed messages (of type `Message`) from the oracle, which serve as proofs that the token ids have not been marked as stolen.\n\nThe function is marked as `external`, which means it can only be called from outside the contract (i.e., it cannot be called by other functions within the same contract).\n\nThe main purpose of this function is to check the signed messages (proofs) from the oracle to ensure that the given token ids have not been marked as stolen. This is an important security measure to prevent the circulation of stolen tokens in the ecosystem.",
          "content": "/// @notice Validates that a set of token ids have not been marked as stolen by the oracle.\n    /// @dev Check a signed message from the oracle to ensure that the token ids have not been marked as stolen.\n    /// @param tokenAddress The address of the token contract.\n    /// @param tokenIds The token ids to validate.\n    /// @param proofs The proofs that the token ids have not been marked as stolen.\n    function validateTokensAreNotStolen(address tokenAddress, uint256[] calldata tokenIds, Message[] calldata proofs)\n        external;\n}",
          "tokens": {
            "summary": 244,
            "content": 117
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/PrivatePool.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/PrivatePool.sol",
      "globalSummary": "The Private Pool is a single-owner, customizable NFT Automated Market Maker (AMM) smart contract that enables trading, depositing, and withdrawing NFTs and base tokens. It supports concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. The code includes functions for buying, selling, and exchanging NFTs, as well as setting fees, royalties, and other configurations. Users should interact with the contract through a wrapper to prevent high slippage.",
      "chunkedSummaries": {
        "OpenZeppelin Solmate Interface": {
          "title": "OpenZeppelin Solmate Interface",
          "summary": "The content provided includes a combination of code snippets and ASCII art. The code snippets are written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. The ASCII art appears to be a decorative element and does not have any functional significance.\n\nThe code imports several libraries and interfaces, which are briefly described below:\n\n1. `IERC2981`: This interface is imported from the OpenZeppelin library, a popular collection of secure and tested smart contract components. IERC2981 is an interface for the ERC-2981 standard, which defines a royalty mechanism for Non-Fungible Tokens (NFTs) on the Ethereum blockchain.\n\n2. `ERC20`: This is a Solidity implementation of the ERC-20 standard, which defines a common interface for fungible tokens on the Ethereum blockchain. The implementation is imported from the Solmate library, a collection of Solidity smart contract components.\n\n3. `ERC721` and `ERC721TokenReceiver`: These are Solidity implementations of the ERC-721 standard, which defines a common interface for NFTs on the Ethereum blockchain. The implementations are imported from the Solmate library.\n\n4. `FixedPointMathLib`: This library provides utility functions for working with fixed-point numbers in Solidity. Fixed-point numbers are used to represent fractional values in smart contracts, as the Ethereum Virtual Machine (EVM) does not support floating-point arithmetic. The library is imported from the Solmate library.\n\n5. `SafeTransferLib`: This library provides utility functions for safely transferring tokens and Ether between addresses in Solidity. It is imported from the Solmate library.\n\n6. `MerkleProofLib`: This library provides utility functions for working with Merkle proofs in Solidity. Merkle proofs are used to verify the membership of an element in a Merkle tree, a data structure commonly used in blockchain applications. The library is imported from the Solady library, which appears to be a typo and should be Solmate.\n\nIn summary, the provided content includes Solidity code that imports various libraries and interfaces related to token standards (ERC-20 and ERC-721), royalty mechanisms (ERC-2981), and utility functions for fixed-point arithmetic, safe transfers, and Merkle proofs. The ASCII art serves as a decorative element and does not contribute to the functionality of the code.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                   ____\n *                                /\\|    ~~\\\n *                              /'  |   ,-. `\\\n *                             |       | X |  |\n *                            _|________`-'   |X\n *                          /'          ~~~~~~~~~,\n *                        /'             ,_____,/_\n *                     ,/'        ___,'~~         ;\n * ~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,\n *         |       |            |  XX'____________'\n *         |       |           /' XXX|            ;\n *         |       |        --x|  XXX,~~~~~~~~~~~~,\n *         |       |          X|     '____________'\n *         |   o   |---~~~~\\__XX\\             |XX\n *         |       |          XXX`\\          /XXXX\n * ~~~~~~~~'~~~~~~~'               `\\xXXXXx/' \\XXX\n *                                  /XXXXXX\\\n *                                /XXXXXXXXXX\\\n *                              /XXXXXX/^\\XXXXX\\\n *                             ~~~~~~~~   ~~~~~~~\n */\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";",
          "tokens": {
            "summary": 473,
            "content": 334
          }
        },
        "Royalty Registry Interface": {
          "title": "Royalty Registry Interface",
          "summary": "The given content is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two interfaces, IERC2981 and IRoyaltyRegistry, from their respective source files.\n\n1. IERC2981: This interface is imported from the OpenZeppelin library, a widely-used framework for secure smart contract development. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs) on the Ethereum blockchain. The ERC-2981 standard defines a uniform way to handle royalty payments for NFTs, allowing creators to receive a percentage of the sales whenever their NFTs are sold or transferred. By implementing this interface, a smart contract can support royalty payments for NFTs in a standardized and interoperable manner.\n\n2. IRoyaltyRegistry: This interface is imported from the Royalty Registry Solidity library, which is a smart contract registry for managing royalty information on the Ethereum blockchain. The IRoyaltyRegistry interface defines the functions required for a smart contract to interact with the Royalty Registry, enabling the contract to store, update, and retrieve royalty information for NFTs. By implementing this interface, a smart contract can leverage the Royalty Registry's functionality to manage royalty data in a decentralized and transparent manner.\n\nIn summary, this code snippet imports two interfaces related to royalty management for NFTs on the Ethereum blockchain. The IERC2981 interface provides a standardized way to handle royalty payments, while the IRoyaltyRegistry interface enables interaction with a decentralized registry for managing royalty information. Implementing these interfaces in a smart contract allows for secure and transparent management of royalties for NFT creators and owners.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";",
          "tokens": {
            "summary": 353,
            "content": 42
          }
        },
        "ERC3156 Flash Borrower": {
          "title": "ERC3156 Flash Borrower",
          "summary": "The given content is an import statement in the Solidity programming language, which is used for writing smart contracts on the Ethereum blockchain. This import statement is specifically importing the `IERC3156FlashBorrower` interface from the OpenZeppelin library's `IERC3156FlashLender.sol` file.\n\nOpenZeppelin is a widely-used library of secure and audited smart contract components for the Ethereum platform. It provides reusable and tested implementations of common smart contract patterns, such as tokens, access control, and security features.\n\nThe `IERC3156FlashBorrower` interface is part of the ERC-3156 standard, which defines a common interface for flash loans. Flash loans are a DeFi (Decentralized Finance) innovation that allows users to borrow assets without collateral for the duration of a single transaction. The borrowed assets must be returned within the same transaction, or the transaction will be reverted. This mechanism enables various use cases, such as arbitrage, collateral swapping, and self-liquidation.\n\nThe `IERC3156FlashBorrower` interface defines the required methods that a smart contract must implement to interact with an ERC-3156 compliant flash lender. By importing and implementing this interface, a smart contract can ensure compatibility with various flash lending platforms that support the ERC-3156 standard.\n\nIn summary, the given content is an import statement in Solidity that imports the `IERC3156FlashBorrower` interface from the OpenZeppelin library. This interface is part of the ERC-3156 standard for flash loans and allows a smart contract to interact with compliant flash lending platforms.",
          "content": "import {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashLender.sol\";",
          "tokens": {
            "summary": 328,
            "content": 27
          }
        },
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given code snippet is a Solidity function named `setUseStolenNftOracle` that is used to set the flag for using a stolen NFT oracle in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe purpose of the stolen NFT oracle is to check if a given NFT (Non-Fungible Token) is stolen or not. The function takes a boolean parameter `newUseStolenNftOracle`, which represents the new value for the flag that determines whether to use the stolen NFT oracle.\n\nInside the function, the `useStolenNftOracle` state variable is assigned the value of the `newUseStolenNftOracle` parameter. This updates the flag in the smart contract to either enable or disable the use of the stolen NFT oracle.\n\nAfter updating the flag, the function emits an event called `SetUseStolenNftOracle` with the new value of the flag as its argument. This event can be used by external systems or applications to track changes in the use of the stolen NFT oracle.",
          "content": "/// @notice Sets the whether or not to use the stolen NFT oracle. Can only be called by the owner of the pool. The\n    /// stolen NFT oracle is used to check if an NFT is stolen.\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    function setUseStolenNftOracle(bool newUseStolenNftOracle) public onlyOwner {\n        // set the use stolen NFT oracle flag\n        useStolenNftOracle = newUseStolenNftOracle;\n\n        // emit the set use stolen NFT oracle event\n        emit SetUseStolenNftOracle(newUseStolenNftOracle);\n    }",
          "tokens": {
            "summary": 231,
            "content": 146
          }
        },
        "Private Pool NFT": {
          "title": "Private Pool NFT",
          "summary": "The PrivatePool contract is an NFT Automated Market Maker (AMM) controlled by a single owner with features such as concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. Users can create a pool and modify its parameters according to their preferences. Depositing NFTs and base tokens (or ETH) into the pool enables trading, and users can earn fees on each trade.\n\nThe contract uses the SafeTransferLib library for secure transfers and includes a MerkleMultiProof struct for Merkle proof input. Several events are emitted for different actions, such as initializing the pool, buying and selling NFTs, depositing and withdrawing tokens, changing parameters, and setting various options.\n\nSome of the key variables in the contract include the base ERC20 token address, the NFT address, change/flash fee, buy/sell fee rate, initialization status, royalty payment status, stolen NFT oracle usage, virtual base token reserves, virtual NFT reserves, and the Merkle root of all token weights in the pool.\n\nThe contract also includes error handling for various scenarios, such as unauthorized access, invalid inputs, insufficient input weight, high fee rates, flash loan failures, and invalid royalty fees.\n\nThe PrivatePool contract leverages a stolen NFT oracle to check if an NFT is stolen and allows users to set whether or not the pool pays royalties to the NFT creator on each trade.",
          "content": "/// @title Private Pool\n/// @author out.eth (@outdoteth)\n/// @notice A private pool is a an NFT AMM controlled by a single owner with concentrated liquidity, custom fee rates,\n/// stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. You can create a pool and change\n/// these parameters to your liking. Deposit NFTs and base tokens (or ETH) into the pool to enable trading. Earn fees on\n/// each trade.\ncontract PrivatePool is ERC721TokenReceiver {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    /// @notice Merkle proof input for a sparse merkle multi proof. It can be generated with a library like:\n    /// https://github.com/OpenZeppelin/merkle-tree#treegetmultiproof\n    struct MerkleMultiProof {\n        bytes32[] proof;\n        bool[] flags;\n    }\n\n    // forgefmt: disable-start\n    event Initialize(address indexed baseToken, address indexed nft, uint128 virtualBaseTokenReserves, uint128 virtualNftReserves, uint56 changeFee, uint16 feeRate, bytes32 merkleRoot, bool useStolenNftOracle, bool payRoyalties);\n    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Sell(uint256[] tokenIds, uint256[] tokenWeights, uint256 outputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Deposit(uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed nft, uint256[] tokenIds, address token, uint256 amount);\n    event Change(uint256[] inputTokenIds, uint256[] inputTokenWeights, uint256[] outputTokenIds, uint256[] outputTokenWeights, uint256 feeAmount, uint256 protocolFeeAmount);\n    event SetVirtualReserves(uint128 virtualBaseTokenReserves, uint128 virtualNftReserves);\n    event SetMerkleRoot(bytes32 merkleRoot);\n    event SetFeeRate(uint16 feeRate);\n    event SetUseStolenNftOracle(bool useStolenNftOracle);\n    event SetPayRoyalties(bool payRoyalties);\n    // forgefmt: disable-end\n\n    error AlreadyInitialized();\n    error Unauthorized();\n    error InvalidEthAmount();\n    error InvalidMerkleProof();\n    error InsufficientInputWeight();\n    error FeeRateTooHigh();\n    error NotAvailableForFlashLoan();\n    error FlashLoanFailed();\n    error InvalidRoyaltyFee();\n\n    /// @notice The address of the base ERC20 token.\n    address public baseToken;\n\n    /// @notice The address of the nft.\n    address public nft;\n\n    /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n    uint56 public changeFee;\n\n    /// @notice The buy/sell fee rate (in basis points) 200 = 2%\n    uint16 public feeRate;\n\n    /// @notice Whether or not the pool has been initialized.\n    bool public initialized;\n\n    /// @notice Whether or not the pool pays royalties to the NFT creator on each trade.\n    bool public payRoyalties;\n\n    /// @notice Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen.\n    bool public useStolenNftOracle;\n\n    /// @notice The virtual base token reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    uint128 public virtualBaseTokenReserves;\n\n    /// @notice The virtual nft reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    /// @dev The virtual NFT reserves that a user sets. If it's desired to set the reserves to match 16 NFTs then the\n    /// virtual reserves should be set to 16e18. If weights are enabled by setting the merkle root to be non-zero then\n    /// the virtual reserves should be set to the sum of the weights of the NFTs; where floor NFTs all have a weight of\n    /// 1e18. A rarer NFT may have a weight of 2.3e18 if it's 2.3x more valuable than a floor.\n    uint128 public virtualNftReserves;\n\n    /// @notice The merkle root of all the token weights in the pool. If the merkle root is set to bytes32(0) then all\n    /// NFTs are set to have a weight of 1e18.\n    bytes32 public merkleRoot;\n\n    /// @notice The NFT oracle to check if an NFT is stolen.\n    address public immutable stolenNftOracle;",
          "tokens": {
            "summary": 293,
            "content": 1046
          }
        },
        "Factory Contract Creator": {
          "title": "Factory Contract Creator",
          "summary": "The given content is a snippet of a Solidity smart contract code that defines a factory contract, a royalty registry, and a modifier for access control.\n\n1. `address payable public immutable factory;` - This line declares a public, immutable, and payable variable named `factory` of type `address`. This variable represents the factory contract that created the current pool. Being immutable, its value cannot be changed after the contract is deployed.\n\n2. `address public immutable royaltyRegistry;` - This line declares a public and immutable variable named `royaltyRegistry` of type `address`. This variable represents the royalty registry from manifold.xyz, a platform for managing royalties and licensing for digital assets. Similar to the `factory` variable, its value cannot be changed after the contract is deployed.\n\n3. `modifier onlyOwner() virtual { ... }` - This block of code defines a modifier named `onlyOwner`. Modifiers in Solidity are used to modify the behavior of functions, usually for access control purposes. In this case, the `onlyOwner` modifier checks if the sender of the transaction (`msg.sender`) is the owner of the contract. The ownership is determined by calling the `ownerOf` function from the Factory contract, passing the current contract's address as a parameter. If the sender is not the owner, the modifier will revert the transaction with an \"Unauthorized\" error message. The `virtual` keyword indicates that this modifier can be overridden in derived contracts.\n\n4. `receive() external payable {}` - This line defines a fallback function named `receive`. Fallback functions are executed when a contract receives Ether without any data or when no other function matches the provided function signature. In this case, the `receive` function is marked as `external` and `payable`, allowing the contract to accept Ether transfers. The empty function body indicates that no additional logic is executed when Ether is received.",
          "content": "/// @notice The factory contract that created this pool.\n    address payable public immutable factory;\n\n    /// @notice The royalty registry from manifold.xyz.\n    address public immutable royaltyRegistry;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != Factory(factory).ownerOf(uint160(address(this)))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    receive() external payable {}",
          "tokens": {
            "summary": 383,
            "content": 77
          }
        },
        "Immutable Parameters Constructor": {
          "title": "Immutable Parameters Constructor",
          "summary": "The given code snippet is a constructor function for a smart contract in the Solidity programming language. This constructor is called only when the base implementation contract is deployed. It sets three immutable parameters, which are stored in immutable storage, allowing minimal proxy contracts to read them without incurring additional deployment costs and re-initializing them at the point of creation in the factory contract.\n\nThe three immutable parameters are:\n\n1. factory: The address of the factory contract. This is set by passing the _factory parameter to the constructor and converting it to a payable address.\n2. royaltyRegistry: The address of the royalty registry from manifold.xyz. This is set by passing the _royaltyRegistry parameter to the constructor.\n3. stolenNftOracle: The address of the stolen NFT oracle. This is set by passing the _stolenNftOracle parameter to the constructor.\n\nBy setting these parameters as immutable, the contract ensures that their values cannot be changed after deployment, providing a secure and efficient way to store and access these addresses.",
          "content": "/// @dev This is only called when the base implementation contract is deployed. The following immutable parameters\n    /// are set:\n    /// - factory: The address of the factory contract\n    /// - royaltyRegistry: The address of the royalty registry from manifold.xyz\n    /// - stolenNftOracle: The address of the stolen NFT oracle\n    /// These are all stored in immutable storage, which enables all minimal proxy contracts to read them without\n    /// incurring additional deployment costs and re-initializing them at point of creation in the factory contract.\n    constructor(address _factory, address _royaltyRegistry, address _stolenNftOracle) {\n        factory = payable(_factory);\n        royaltyRegistry = _royaltyRegistry;\n        stolenNftOracle = _stolenNftOracle;\n    }",
          "tokens": {
            "summary": 205,
            "content": 164
          }
        },
        "Private Pool Initialization": {
          "title": "Private Pool Initialization",
          "summary": "The given code snippet is a function called `initialize` that sets up a private pool with its initial parameters. This function should only be called once by the factory. The function takes the following input parameters:\n\n1. `_baseToken`: The address of the base token.\n2. `_nft`: The address of the NFT (Non-Fungible Token).\n3. `_virtualBaseTokenReserves`: The virtual base token reserves.\n4. `_virtualNftReserves`: The virtual NFT reserves.\n5. `_changeFee`: The change fee.\n6. `_feeRate`: The fee rate (in basis points), where 200 equals 2%.\n7. `_merkleRoot`: The Merkle root.\n8. `_useStolenNftOracle`: A boolean value indicating whether the pool uses the stolen NFT oracle to check if an NFT is stolen.\n9. `_payRoyalties`: A boolean value indicating whether to pay royalties.\n\nThe function first checks if the pool has already been initialized, and if so, it reverts with an \"AlreadyInitialized\" error. It then checks if the fee rate is less than 50%, and if not, it reverts with a \"FeeRateTooHigh\" error.\n\nNext, the function sets the state variables with the input parameters. It marks the pool as initialized and emits an \"Initialize\" event with the input parameters.\n\nIn summary, the `initialize` function is responsible for setting up a private pool with its initial parameters, ensuring that it is only called once and that the fee rate is within acceptable limits.",
          "content": "/// @notice Initializes the private pool and sets the initial parameters. Should only be called once by the factory.\n    /// @param _baseToken The address of the base token\n    /// @param _nft The address of the NFT\n    /// @param _virtualBaseTokenReserves The virtual base token reserves\n    /// @param _virtualNftReserves The virtual NFT reserves\n    /// @param _feeRate The fee rate (in basis points) 200 = 2%\n    /// @param _merkleRoot The merkle root\n    /// @param _useStolenNftOracle Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen\n    function initialize(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties\n    ) public {\n        // prevent duplicate initialization\n        if (initialized) revert AlreadyInitialized();\n\n        // check that the fee rate is less than 50%\n        if (_feeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the state variables\n        baseToken = _baseToken;\n        nft = _nft;\n        virtualBaseTokenReserves = _virtualBaseTokenReserves;\n        virtualNftReserves = _virtualNftReserves;\n        changeFee = _changeFee;\n        feeRate = _feeRate;\n        merkleRoot = _merkleRoot;\n        useStolenNftOracle = _useStolenNftOracle;\n        payRoyalties = _payRoyalties;\n\n        // mark the pool as initialized\n        initialized = true;\n\n        // emit the event\n        emit Initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n    }",
          "tokens": {
            "summary": 321,
            "content": 458
          }
        },
        "NFT Pool Purchase": {
          "title": "NFT Pool Purchase",
          "summary": "The given content describes a function called \"buy\" in a smart contract that allows users to purchase Non-Fungible Tokens (NFTs) from a pool using base tokens. The function takes three input parameters: tokenIds, tokenWeights, and proof. The function returns three output values: netInputAmount, feeAmount, and protocolFeeAmount.\n\nThe function starts by performing checks to ensure the validity of the input parameters. It calculates the sum of weights of the NFTs to buy and validates the Merkle proof provided. It then calculates the required net input amount and fee amount based on the current price, fee rate, and assigned NFT weights.\n\nIf the base token is not Ethereum (ETH), the function checks that the caller sent 0 ETH. If not, it reverts the transaction with an \"InvalidEthAmount\" error.\n\nNext, the function updates the virtual reserves of the base tokens and NFTs in the pool. It increases the virtual base token reserves by the net input amount minus the fee amount and protocol fee amount, and decreases the virtual NFT reserves by the sum of weights.\n\nThe function then calculates the sale price for each NFT, assuming it's the same for all NFTs even if their weights differ. It transfers the NFTs to the caller and, if the \"payRoyalties\" flag is set, calculates the royalty fee for each NFT and adds it to the total royalty fee amount.\n\nFinally, the function adds the royalty fee amount to the net input amount. If the base token is not ETH, it transfers the base tokens from the caller to the contract. It also transfers the fee amount and protocol fee amount to the fee recipient and protocol fee recipient, respectively.",
          "content": "/// @notice Buys NFTs from the pool, paying with base tokens from the caller. Then transfers the bought NFTs to the\n    /// caller. The net cost depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the max input amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to buy.\n    /// @param tokenWeights The weights of the NFTs to buy.\n    /// @param proof The merkle proof for the weights of each NFT to buy.\n    /// @return netInputAmount The amount of base tokens spent inclusive of fees.\n    /// @return feeAmount The amount of base tokens spent on fees.\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to buy\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the required net input amount and fee amount\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n        // check that the caller sent 0 ETH if the base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n        virtualNftReserves -= uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer the NFT to the caller\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            if (payRoyalties) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n                // add the royalty fee to the total royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n            }\n        }\n\n        // add the royalty fee amount to the net input aount\n        netInputAmount += royaltyFeeAmount;\n\n        if (baseToken != address(0)) {",
          "tokens": {
            "summary": 349,
            "content": 603
          }
        },
        "Token Transfer Protocol": {
          "title": "Token Transfer Protocol",
          "summary": "The given code snippet is a part of a smart contract that handles the purchase of Non-Fungible Tokens (NFTs) using either ERC20 tokens or Ether (ETH) as the base currency. The contract ensures that the correct amount of funds are transferred, protocol fees are paid, and royalties are distributed to the respective recipients.\n\n1. The contract first checks if the base token is an ERC20 token or ETH. If it's an ERC20 token, it safely transfers the required amount (netInputAmount) from the caller to the contract using the `safeTransferFrom` function.\n\n2. If a protocol fee is set (protocolFeeAmount > 0), the contract transfers the fee to the factory address using the `safeTransfer` function.\n\n3. If the base token is ETH, the contract checks if the caller has sent enough ETH to cover the net required input (msg.value >= netInputAmount). If not, it reverts the transaction with an \"InvalidEthAmount\" error.\n\n4. If a protocol fee is set for ETH, the contract transfers the fee to the factory address using the `safeTransferETH` function.\n\n5. If the caller has sent excess ETH (msg.value > netInputAmount), the contract refunds the excess amount to the caller using the `safeTransferETH` function.\n\n6. If the `payRoyalties` flag is set, the contract iterates through the tokenIds array and calculates the royalty fee for each NFT using the `_getRoyalty` function. If the royalty fee is greater than 0 and the recipient address is valid, the contract transfers the royalty fee to the recipient. If the base token is an ERC20 token, it uses the `safeTransfer` function; otherwise, it uses the `safeTransferETH` function for ETH.\n\n7. Finally, the contract emits a \"Buy\" event with the relevant information, including tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, and royaltyFeeAmount.",
          "content": "// transfer the base token from the caller to the contract\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the net required input\n            if (msg.value < netInputAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n        }\n\n        if (payRoyalties) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // emit the buy event\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }",
          "tokens": {
            "summary": 405,
            "content": 344
          }
        },
        "NFT Pool Sale": {
          "title": "NFT Pool Sale",
          "summary": "The `sell` function is designed to sell Non-Fungible Tokens (NFTs) into a pool and transfer base tokens to the caller. The NFTs are transferred from the caller to the pool, and the net sale amount depends on the current price, fee rate, and assigned NFT weights. It is advised not to call this function directly unless you are aware of the consequences; instead, use a wrapper contract that checks the minimum output amount and reverts if the slippage is too high.\n\nThe function takes the following parameters:\n- `tokenIds`: The token IDs of the NFTs to sell.\n- `tokenWeights`: The weights of the NFTs to sell.\n- `proof`: The Merkle proof for the weights of each NFT to sell.\n- `stolenNftProofs`: The proofs that show each NFT is not stolen.\n\nThe function returns the following values:\n- `netOutputAmount`: The amount of base tokens received inclusive of fees.\n- `feeAmount`: The amount of base tokens to pay in fees.\n\nThe function performs several checks, including calculating the sum of weights of the NFTs to sell, the net output amount, and the fee amount. It also checks if the NFTs are not stolen using the `IStolenNftOracle` interface.\n\nAfter the checks, the function updates the virtual reserves, transfers each NFT from the caller, and calculates the royalty fee for each NFT if the `payRoyalties` flag is set. The royalty fee is then transferred to the recipient if it is greater than 0 and the recipient's address is not 0.\n\nFinally, the function transfers the base tokens (or ETH) to the caller and pays the protocol fee if it is set. It also emits a `Sell` event with the token IDs, token weights, net output amount, fee amount, protocol fee amount, and royalty fee amount.",
          "content": "/// @notice Sells NFTs into the pool and transfers base tokens to the caller. NFTs are transferred from the caller\n    /// to the pool. The net sale amount depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the min output amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to sell.\n    /// @param tokenWeights The weights of the NFTs to sell.\n    /// @param proof The merkle proof for the weights of each NFT to sell.\n    /// @param stolenNftProofs The proofs that show each NFT is not stolen.\n    /// @return netOutputAmount The amount of base tokens received inclusive of fees.\n    /// @return feeAmount The amount of base tokens to pay in fees.\n    function sell(\n        uint256[] calldata tokenIds,\n        uint256[] calldata tokenWeights,\n        MerkleMultiProof calldata proof,\n        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error\n    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to sell\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the net output amount and fee amount\n        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n        //  check the nfts are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n        }\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n        virtualNftReserves += uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer each nft from the caller\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n            if (payRoyalties) {\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // tally the royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // subtract the royalty fee amount from the net output amount\n        netOutputAmount -= royaltyFeeAmount;\n\n        if (baseToken == address(0)) {\n            // transfer ETH to the caller\n            msg.sender.safeTransferETH(netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n        } else {\n            // transfer base tokens to the caller\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        }\n\n        // emit the sell event\n        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }",
          "tokens": {
            "summary": 393,
            "content": 888
          }
        },
        "NFT Pool Change": {
          "title": "NFT Pool Change",
          "summary": "The `change` function allows a user to swap a set of NFTs they own for another set of NFTs in the pool. The user must first approve the pool to transfer their NFTs. The sum of the user's NFT weights must be less than or equal to the sum of the output pool NFTs weights. Additionally, the user must pay a fee based on the net input weight and change fee amount.\n\nThe function takes the following parameters:\n\n- `inputTokenIds`: The token IDs of the NFTs to be swapped.\n- `inputTokenWeights`: The weights of the NFTs to be swapped.\n- `inputProof`: The Merkle proof for the weights of each NFT to be swapped.\n- `stolenNftProofs`: The proofs that show each input NFT is not stolen.\n- `outputTokenIds`: The token IDs of the NFTs to be received.\n- `outputTokenWeights`: The weights of the NFTs to be received.\n- `outputProof`: The Merkle proof for the weights of each NFT to be received.\n\nThe function performs several checks:\n\n1. If the base token is not ETH, it ensures that the caller sent 0 ETH.\n2. If the `useStolenNftOracle` flag is set, it validates that the NFTs are not stolen using the `IStolenNftOracle` interface.\n3. It calculates the sum of weights for the input and output NFTs and validates their Merkle proofs.\n4. It ensures that the input weights are greater than or equal to the output weights.\n5. It calculates the fee amount and protocol fee amount based on the input weight sum.\n\nThe function then performs several interactions:\n\n1. If the base token is not ETH, it transfers the fee amount of base tokens from the caller to the contract and the protocol fee amount to the factory.\n2. If the base token is ETH, it checks that the caller sent enough ETH to cover the fee amount and protocol fee amount, transfers the protocol fee to the factory, and refunds any excess ETH to the caller.\n3. It transfers the input NFTs from the caller to the contract.\n4. It transfers the output NFTs from the contract to the caller.\n\nFinally, the function emits a `Change` event with the input and output token IDs, weights, fee amount, and protocol fee amount.",
          "content": "/// @notice Changes a set of NFTs that the caller owns for another set of NFTs in the pool. The caller must approve\n    /// the pool to transfer the NFTs. The sum of the caller's NFT weights must be less than or equal to the sum of the\n    /// output pool NFTs weights. The caller must also pay a fee depending the net input weight and change fee amount.\n    /// @param inputTokenIds The token IDs of the NFTs to change.\n    /// @param inputTokenWeights The weights of the NFTs to change.\n    /// @param inputProof The merkle proof for the weights of each NFT to change.\n    /// @param stolenNftProofs The proofs that show each input NFT is not stolen.\n    /// @param outputTokenIds The token IDs of the NFTs to receive.\n    /// @param outputTokenWeights The weights of the NFTs to receive.\n    /// @param outputProof The merkle proof for the weights of each NFT to receive.\n    function change(\n        uint256[] memory inputTokenIds,\n        uint256[] memory inputTokenWeights,\n        MerkleMultiProof memory inputProof,\n        IStolenNftOracle.Message[] memory stolenNftProofs,\n        uint256[] memory outputTokenIds,\n        uint256[] memory outputTokenWeights,\n        MerkleMultiProof memory outputProof\n    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // check that the caller sent 0 ETH if base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // check that NFTs are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);\n        }\n\n        // fix stack too deep\n        {\n            // calculate the sum of weights for the input nfts\n            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);\n\n            // calculate the sum of weights for the output nfts\n            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);\n\n            // check that the input weights are greater than or equal to the output weights\n            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();\n\n            // calculate the fee amount\n            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        if (baseToken != address(0)) {\n            // transfer the fee amount of base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the fee amount and protocol fee\n            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > feeAmount + protocolFeeAmount) {\n                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);\n            }\n        }\n\n        // transfer the input nfts from the caller\n        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n        }\n\n        // transfer the output nfts to the caller\n        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n        }\n\n        // emit the change event\n        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);\n    }",
          "tokens": {
            "summary": 494,
            "content": 912
          }
        },
        "Execute Target Contract": {
          "title": "Execute Target Contract",
          "summary": "The given code snippet is a Solidity function named `execute` that is designed to execute a transaction from a pool account to a target contract. This function can only be called by the owner of the pool, which is enforced by the `onlyOwner` modifier. The primary use case for this function is to claim airdrops.\n\nThe function takes two input parameters:\n\n1. `target`: The address of the target contract to which the transaction will be executed.\n2. `data`: The data to be sent to the target contract as part of the transaction.\n\nThe function is also marked as `payable`, which means it can receive Ether (ETH) as part of the transaction.\n\nThe function returns a single output parameter:\n\n1. `returnData`: The return data of the transaction, which is the data returned by the target contract after the transaction is executed.\n\nThe function starts by calling the target contract with the specified data and value (ETH) using the `call` function. The `call` function returns two values: a boolean `success` indicating whether the call was successful, and the `returnData` from the target contract.\n\nIf the call is successful, the function returns the `returnData` directly. If the call is not successful, the function checks if there is any return data. If there is return data, it uses inline assembly to revert the transaction and bubble up the error message contained in the return data. If there is no return data, the function simply reverts the transaction without any error message.",
          "content": "/// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\n    /// pool. This allows for use cases such as claiming airdrops.\n    /// @param target The address of the target contract.\n    /// @param data The data to send to the target contract.\n    /// @return returnData The return data of the transaction.\n    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n        // call the target with the value and data\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n        // if the call succeeded return the return data\n        if (success) return returnData;\n\n        // if we got an error bubble up the error message\n        if (returnData.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert();\n        }\n    }",
          "tokens": {
            "summary": 308,
            "content": 227
          }
        },
        "Deposit Tokens NFTs": {
          "title": "Deposit Tokens NFTs",
          "summary": "The given code snippet is a smart contract function called `deposit` that allows users to deposit both base tokens and NFTs (Non-Fungible Tokens) into a pool. The function takes two parameters: an array of token IDs representing the NFTs to be deposited, and a `baseTokenAmount` representing the amount of base tokens to be deposited.\n\nBefore executing the deposit, the function checks if the base token is Ethereum (ETH) and if the sent ETH amount is valid. If the base token is ETH, the sent ETH amount should be equal to the `baseTokenAmount`. If the base token is not ETH, the sent ETH amount should be 0. If these conditions are not met, the function reverts with an `InvalidEthAmount` error.\n\nAfter the checks, the function transfers the NFTs from the caller to the smart contract using the `safeTransferFrom` function of the ERC721 standard. It iterates through the `tokenIds` array and transfers each NFT individually.\n\nIf the base token is not ETH, the function transfers the base tokens from the caller to the smart contract using the `safeTransferFrom` function of the ERC20 standard.\n\nFinally, the function emits a `Deposit` event with the deposited NFTs and base token amount as its parameters.\n\nIt is important to note that the function is marked with a `@dev` comment, warning developers not to call this function directly unless they know what they are doing. Instead, they should use a wrapper contract that checks if the current price is within the desired bounds.",
          "content": "/// @notice Deposits base tokens and NFTs into the pool. The caller must approve the pool to transfer their NFTs and\n    /// base tokens.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the current price is within the desired bounds.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param baseTokenAmount The amount of base tokens to deposit.\n    function deposit(uint256[] calldata tokenIds, uint256 baseTokenAmount) public payable {\n        // ~~~ Checks ~~~ //\n\n        // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\n        // is not ETH\n        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\n            revert InvalidEthAmount();\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts from the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        if (baseToken != address(0)) {\n            // transfer the base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        // emit the deposit event\n        emit Deposit(tokenIds, baseTokenAmount);\n    }",
          "tokens": {
            "summary": 319,
            "content": 329
          }
        },
        "Withdraw NFT Tokens": {
          "title": "Withdraw NFT Tokens",
          "summary": "The given code snippet is a function named `withdraw` that allows the owner of a pool to withdraw Non-Fungible Tokens (NFTs) and tokens from the pool. The function takes four input parameters: the address of the NFT (`_nft`), an array of token IDs of the NFTs to be withdrawn (`tokenIds`), the address of the token to be withdrawn (`token`), and the amount of tokens to be withdrawn (`tokenAmount`). The function is marked as `public` and can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function starts by iterating through the `tokenIds` array and transferring each NFT to the caller using the `safeTransferFrom` function of the ERC721 standard. This ensures that the NFTs are securely transferred from the pool to the caller's address.\n\nNext, the function checks if the `token` address is equal to the zero address (i.e., the Ethereum native currency, Ether). If it is, the function transfers the specified `tokenAmount` of Ether to the caller using the `safeTransferETH` function. If the `token` address is not the zero address, the function transfers the specified `tokenAmount` of the ERC20 token to the caller using the `transfer` function of the ERC20 standard.\n\nFinally, the function emits a `Withdraw` event with the NFT address, token IDs, token address, and token amount as its parameters. This event serves as a record of the withdrawal operation and can be used by external applications to track the pool's activity.",
          "content": "/// @notice Withdraws NFTs and tokens from the pool. Can only be called by the owner of the pool.\n    /// @param _nft The address of the NFT.\n    /// @param tokenIds The token IDs of the NFTs to withdraw.\n    /// @param token The address of the token to withdraw.\n    /// @param tokenAmount The amount of tokens to withdraw.\n    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts to the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        if (token == address(0)) {\n            // transfer the ETH to the caller\n            msg.sender.safeTransferETH(tokenAmount);\n        } else {\n            // transfer the tokens to the caller\n            ERC20(token).transfer(msg.sender, tokenAmount);\n        }\n\n        // emit the withdraw event\n        emit Withdraw(_nft, tokenIds, token, tokenAmount);\n    }",
          "tokens": {
            "summary": 329,
            "content": 249
          }
        },
        "Set Virtual Reserves": {
          "title": "Set Virtual Reserves",
          "summary": "The given code snippet defines a function called `setVirtualReserves` that sets the virtual base token reserves and virtual NFT (Non-Fungible Token) reserves for a pool. This function can only be called by the owner of the pool. The parameters of this function are `newVirtualBaseTokenReserves` and `newVirtualNftReserves`, both of which are unsigned 128-bit integers. These parameters affect the price and liquidity depth of the pool.\n\nInside the function, the virtual base token reserves and virtual NFT reserves are updated with the new values provided as arguments. After updating the reserves, an event called `SetVirtualReserves` is emitted with the new reserve values as its arguments. This event can be used by external systems to track changes in the virtual reserves of the pool.",
          "content": "/// @notice Sets the virtual base token reserves and virtual NFT reserves. Can only be called by the owner of the\n    /// pool. These parameters affect the price and liquidity depth of the pool.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    function setVirtualReserves(uint128 newVirtualBaseTokenReserves, uint128 newVirtualNftReserves) public onlyOwner {\n        // set the virtual base token reserves and virtual nft reserves\n        virtualBaseTokenReserves = newVirtualBaseTokenReserves;\n        virtualNftReserves = newVirtualNftReserves;\n\n        // emit the set virtual reserves event\n        emit SetVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n    }",
          "tokens": {
            "summary": 163,
            "content": 176
          }
        },
        "Set Merkle Root": {
          "title": "Set Merkle Root",
          "summary": "The given code snippet is a Solidity function named `setMerkleRoot` that sets the Merkle root for a specific use case, which is to validate the weights of Non-Fungible Tokens (NFTs). The function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newMerkleRoot`, which is of type `bytes32`. This parameter represents the new Merkle root that will be set.\n\nInside the function, the Merkle root is set by assigning the value of `newMerkleRoot` to the `merkleRoot` variable. After this assignment, an event named `SetMerkleRoot` is emitted with the `newMerkleRoot` as its argument. This event is used to notify external entities about the change in the Merkle root.\n\nIn summary, the `setMerkleRoot` function is a Solidity function that updates the Merkle root used for validating NFT weights and can only be called by the owner of the pool. The function takes a new Merkle root as input, sets it, and emits an event to notify about the change.",
          "content": "/// @notice Sets the merkle root. Can only be called by the owner of the pool. The merkle root is used to validate\n    /// the NFT weights.\n    /// @param newMerkleRoot The new merkle root.\n    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        // set the merkle root\n        merkleRoot = newMerkleRoot;\n\n        // emit the set merkle root event\n        emit SetMerkleRoot(newMerkleRoot);\n    }",
          "tokens": {
            "summary": 247,
            "content": 114
          }
        },
        "Fee Rate Setter": {
          "title": "Fee Rate Setter",
          "summary": "The given code snippet is a function called `setFeeRate` that sets the fee rate for a pool. This function can only be called by the owner of the pool. The fee rate is used to calculate the fee amount when swapping or changing NFTs (Non-Fungible Tokens). The fee rate is expressed in basis points, where 1 basis point is equal to 1/100th of a percent. For instance, 10,000 basis points represent 100%, 200 basis points represent 2%, and 1 basis point represents 0.01%.\n\nThe function takes a single parameter, `newFeeRate`, which is the new fee rate in basis points. Inside the function, there is a check to ensure that the new fee rate is less than 50% (5,000 basis points). If the new fee rate is greater than 50%, the function reverts with a `FeeRateTooHigh` error.\n\nIf the new fee rate is valid, the function sets the `feeRate` variable to the value of `newFeeRate`. After updating the fee rate, the function emits an event called `SetFeeRate` with the new fee rate as its parameter. This event can be used by external systems to track changes in the fee rate.",
          "content": "/// @notice Sets the fee rate. Can only be called by the owner of the pool. The fee rate is used to calculate the\n    /// fee amount when swapping or changing NFTs. The fee rate is in basis points (1/100th of a percent). For example,\n    /// 10_000 == 100%, 200 == 2%, 1 == 0.01%.\n    /// @param newFeeRate The new fee rate (in basis points)\n    function setFeeRate(uint16 newFeeRate) public onlyOwner {\n        // check that the fee rate is less than 50%\n        if (newFeeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the fee rate\n        feeRate = newFeeRate;\n\n        // emit the set fee rate event\n        emit SetFeeRate(newFeeRate);\n    }",
          "tokens": {
            "summary": 260,
            "content": 181
          }
        },
        "Set Pay Royalties": {
          "title": "Set Pay Royalties",
          "summary": "The given code snippet is a Solidity function named `setPayRoyalties` that is used to set the pay royalties flag in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newPayRoyalties`, which is a boolean value representing the new state of the pay royalties flag. When royalties are enabled (i.e., `newPayRoyalties` is set to `true`), the pool will pay royalties when buying or selling NFTs (Non-Fungible Tokens).\n\nInside the function, the current value of the `payRoyalties` variable is updated to the value of `newPayRoyalties`. After updating the flag, an event named `SetPayRoyalties` is emitted with the new value of the pay royalties flag. This event can be used by external systems or applications to track changes in the pay royalties flag.",
          "content": "/// @notice Sets the pay royalties flag. Can only be called by the owner of the pool. If royalties are enabled then\n    /// the pool will pay royalties when buying or selling NFTs.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setPayRoyalties(bool newPayRoyalties) public onlyOwner {\n        // set the pay royalties flag\n        payRoyalties = newPayRoyalties;\n\n        // emit the set pay royalties event\n        emit SetPayRoyalties(newPayRoyalties);\n    }",
          "tokens": {
            "summary": 194,
            "content": 111
          }
        },
        "Update Parameters Function": {
          "title": "Update Parameters Function",
          "summary": "The given code snippet is a function called `setAllParameters` in a smart contract, which allows updating multiple parameter settings in a single function call. The function takes six input parameters:\n\n1. `newVirtualBaseTokenReserves`: A uint128 value representing the new virtual base token reserves.\n2. `newVirtualNftReserves`: A uint128 value representing the new virtual NFT (Non-Fungible Token) reserves.\n3. `newMerkleRoot`: A bytes32 value representing the new Merkle root.\n4. `newFeeRate`: A uint16 value representing the new fee rate in basis points.\n5. `newUseStolenNftOracle`: A boolean value representing the new flag for using a stolen NFT oracle.\n6. `newPayRoyalties`: A boolean value representing the new flag for paying royalties.\n\nInside the function, the following methods are called to update the respective parameters:\n\n1. `setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves)`: Updates the virtual base token and NFT reserves with the new values provided.\n2. `setMerkleRoot(newMerkleRoot)`: Updates the Merkle root with the new value provided.\n3. `setFeeRate(newFeeRate)`: Updates the fee rate with the new value provided.\n4. `setUseStolenNftOracle(newUseStolenNftOracle)`: Updates the flag for using a stolen NFT oracle with the new value provided.\n5. `setPayRoyalties(newPayRoyalties)`: Updates the flag for paying royalties with the new value provided.\n\nThis function is marked as `public`, which means it can be called by any external entity interacting with the smart contract. By providing a single function to update all parameters, it simplifies the process of updating multiple settings in the contract.",
          "content": "/// @notice Updates all parameter settings in one go.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    /// @param newMerkleRoot The new merkle root.\n    /// @param newFeeRate The new fee rate (in basis points)\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setAllParameters(\n        uint128 newVirtualBaseTokenReserves,\n        uint128 newVirtualNftReserves,\n        bytes32 newMerkleRoot,\n        uint16 newFeeRate,\n        bool newUseStolenNftOracle,\n        bool newPayRoyalties\n    ) public {\n        setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n        setMerkleRoot(newMerkleRoot);\n        setFeeRate(newFeeRate);\n        setUseStolenNftOracle(newUseStolenNftOracle);\n        setPayRoyalties(newPayRoyalties);\n    }",
          "tokens": {
            "summary": 379,
            "content": 240
          }
        },
        "Flash Loan Execution": {
          "title": "Flash Loan Execution",
          "summary": "The given code snippet is a function called `flashLoan` that executes a flash loan in a smart contract. The function takes four parameters: `receiver`, `token`, `tokenId`, and `data`. The `receiver` is the address of the entity receiving the flash loan, `token` is the address of the Non-Fungible Token (NFT) contract, `tokenId` is the ID of the NFT, and `data` is the additional data to be passed to the receiver.\n\nThe function is marked as `external` and `payable`, meaning it can be called from outside the contract and can receive Ether (ETH) as payment. The function returns a boolean value indicating the success of the flash loan.\n\nThe function first checks if the NFT is available for a flash loan using the `availableForFlashLoan` function. If it is not available, the function reverts with a `NotAvailableForFlashLoan` error.\n\nNext, the function calculates the fee for the flash loan using the `flashFee` function. If the base token is ETH (i.e., `baseToken` is the zero address), the function checks if the caller sent enough ETH to cover the fee. If not, it reverts with an `InvalidEthAmount` error.\n\nThe function then transfers the NFT to the borrower using the `safeTransferFrom` function of the ERC721 contract. After that, it calls the `onFlashLoan` function of the borrower's contract, passing the necessary parameters, and checks if the flash loan was successful by comparing the returned value with the expected hash of the \"ERC3156FlashBorrower.onFlashLoan\" string. If the flash loan is not successful, the function reverts with a `FlashLoanFailed` error.\n\nIf the flash loan is successful, the function transfers the NFT back from the borrower to the contract using the `safeTransferFrom` function of the ERC721 contract. It also transfers the fee from the borrower to the contract using the `transferFrom` function of the ERC20 contract if the base token is not ETH.\n\nFinally, the function returns the `success` boolean value, indicating whether the flash loan was successful or not.",
          "content": "/// @notice Executes a flash loan.\n    /// @param receiver The receiver of the flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @param data The data to pass to the receiver.\n    /// @return success Whether or not the flash loan was successful.\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }",
          "tokens": {
            "summary": 447,
            "content": 351
          }
        },
        "Sum Validate Proof": {
          "title": "Sum Validate Proof",
          "summary": "The `sumWeightsAndValidateProof` function is a public view function that takes three input parameters: an array of token IDs (`tokenIds`), an array of corresponding token weights (`tokenWeights`), and a Merkle multi-proof object (`proof`). The function returns the sum of the weights of each NFT after validating the correctness of the weights using the provided Merkle proof.\n\nInitially, the function checks if the Merkle root is not set (i.e., equal to `bytes32(0)`). If this is the case, it sets the weight of each NFT to be 1e18 and returns the product of the number of token IDs and 1e18 as the sum.\n\nIf the Merkle root is set, the function initializes a `sum` variable and creates a new `bytes32` array called `leafs` with the same length as the `tokenIds` array. It then iterates through the `tokenIds` array, creating a leaf for the Merkle proof by hashing the concatenated keccak256 hash of the encoded token ID and token weight. The function also adds the token weight to the `sum` variable during each iteration.\n\nAfter iterating through all token IDs, the function validates the weights against the Merkle proof using the `MerkleProofLib.verifyMultiProof` function. If the validation fails, the function reverts with an `InvalidMerkleProof` error. If the validation is successful, the function returns the sum of the token weights.",
          "content": "/// @notice Sums the weights of each NFT and validates that the weights are correct by verifying the merkle proof.\n    /// @param tokenIds The token IDs of the NFTs to sum the weights for.\n    /// @param tokenWeights The weights of each NFT in the token IDs array.\n    /// @param proof The merkle proof for the weights of each NFT.\n    /// @return sum The sum of the weights of each NFT.\n    function sumWeightsAndValidateProof(\n        uint256[] memory tokenIds,\n        uint256[] memory tokenWeights,\n        MerkleMultiProof memory proof\n    ) public view returns (uint256) {\n        // if the merkle root is not set then set the weight of each nft to be 1e18\n        if (merkleRoot == bytes32(0)) {\n            return tokenIds.length * 1e18;\n        }\n\n        uint256 sum;\n        bytes32[] memory leafs = new bytes32[](tokenIds.length);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // create the leaf for the merkle proof\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n\n            // sum each token weight\n            sum += tokenWeights[i];\n        }\n\n        // validate that the weights are valid against the merkle proof\n        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\n            revert InvalidMerkleProof();\n        }\n\n        return sum;\n    }",
          "tokens": {
            "summary": 305,
            "content": 339
          }
        },
        "NFT Buy Quote": {
          "title": "NFT Buy Quote",
          "summary": "The given code snippet is a function called `buyQuote` that calculates and returns the required input amount of base tokens, the fee amount, and the protocol fee amount for buying a specified number of Non-Fungible Tokens (NFTs). The function takes a single parameter, `outputAmount`, which represents the desired number of NFTs to buy, multiplied by 1e18.\n\nThe function first calculates the input amount using the xy=k invariant, a formula used in automated market makers (AMMs) to maintain a constant product of token reserves. The input amount is calculated by multiplying the `outputAmount` by the `virtualBaseTokenReserves` and dividing the result by the difference between `virtualNftReserves` and `outputAmount`. The result is then rounded up by 1 wei using the `mulDivUp` function from the `FixedPointMathLib` library.\n\nNext, the function calculates the protocol fee amount by multiplying the input amount by the protocol fee rate, which is obtained from the Factory contract, and dividing the result by 10,000. Similarly, the fee amount is calculated by multiplying the input amount by the `feeRate` and dividing the result by 10,000.\n\nFinally, the function calculates the net input amount by adding the input amount, fee amount, and protocol fee amount together. The function then returns the net input amount, fee amount, and protocol fee amount as output.",
          "content": "/// @notice Returns the required input of buying a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param outputAmount The amount of NFTs to buy multiplied by 1e18.\n    /// @return netInputAmount The required input amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function buyQuote(uint256 outputAmount)\n        public\n        view\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the input amount based on xy=k invariant and round up by 1 wei\n        uint256 inputAmount =\n            FixedPointMathLib.mulDivUp(outputAmount, virtualBaseTokenReserves, (virtualNftReserves - outputAmount));\n\n        protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = inputAmount * feeRate / 10_000;\n        netInputAmount = inputAmount + feeAmount + protocolFeeAmount;\n    }",
          "tokens": {
            "summary": 290,
            "content": 225
          }
        },
        "NFT Sell Quote": {
          "title": "NFT Sell Quote",
          "summary": "The `sellQuote` function is a public view function that returns the output amount of selling a given amount of NFTs (Non-Fungible Tokens) inclusive of the fee, which depends on the currently set fee rate. The function takes one input parameter, `inputAmount`, which represents the amount of NFTs to sell multiplied by 1e18. The function returns three values: `netOutputAmount`, `feeAmount`, and `protocolFeeAmount`.\n\nThe function first calculates the output amount based on the xy=k invariant, a formula used in automated market makers (AMMs) to maintain a constant product of token reserves. The output amount is calculated as `inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount)`.\n\nNext, the function calculates the protocol fee amount by multiplying the output amount by the protocol fee rate obtained from the factory contract and dividing by 10,000. The fee amount is calculated similarly, by multiplying the output amount by the fee rate and dividing by 10,000.\n\nFinally, the net output amount is calculated by subtracting the fee amount and protocol fee amount from the output amount. The function returns the net output amount, fee amount, and protocol fee amount.",
          "content": "/// @notice Returns the output amount of selling a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param inputAmount The amount of NFTs to sell multiplied by 1e18.\n    /// @return netOutputAmount The output amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function sellQuote(uint256 inputAmount)\n        public\n        view\n        returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the output amount based on xy=k invariant\n        uint256 outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount);\n\n        protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = outputAmount * feeRate / 10_000;\n        netOutputAmount = outputAmount - feeAmount - protocolFeeAmount;\n    }",
          "tokens": {
            "summary": 251,
            "content": 209
          }
        },
        "NFT Change Fee": {
          "title": "NFT Change Fee",
          "summary": "The given code snippet is a function named `changeFeeQuote` in a smart contract, which calculates the fee required to change a specified amount of Non-Fungible Tokens (NFTs). The function takes one input parameter, `inputAmount`, which represents the amount of NFTs to change, multiplied by 1e18. The function returns two values: `feeAmount` and `protocolFeeAmount`.\n\nThe fee calculation is based on the current `changeFee` value, which has 4 decimals of precision. The function first calculates the exponent depending on the base token decimals. If the base token is a zero address, the exponent is set to 14 (18 - 4). Otherwise, the exponent is calculated as the difference between the base token's decimals and 4.\n\nNext, the function calculates the fee per NFT by multiplying the `changeFee` with 10 raised to the power of the calculated exponent. This gives the fee per NFT with 4 decimals of accuracy.\n\nThe `feeAmount` is then calculated by multiplying the `inputAmount` with the `feePerNft` and dividing the result by 1e18. The `protocolFeeAmount` is calculated by multiplying the `feeAmount` with the `protocolFeeRate` (retrieved from the Factory contract) and dividing the result by 10,000.\n\nIn summary, the `changeFeeQuote` function calculates the fee and protocol fee amounts required to change a specified amount of NFTs based on the current `changeFee` and the base token's decimals.",
          "content": "/// @notice Returns the fee required to change a given amount of NFTs. The fee is based on the current changeFee\n    /// (which contains 4 decimals of precision) multiplied by some exponent depending on the base token decimals.\n    /// @param inputAmount The amount of NFTs to change multiplied by 1e18.\n    /// @return feeAmount The fee amount.\n    /// @return protocolFeeAmount The protocol fee amount.\n    function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n        uint256 feePerNft = changeFee * 10 ** exponent;\n\n        feeAmount = inputAmount * feePerNft / 1e18;\n        protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n    }",
          "tokens": {
            "summary": 319,
            "content": 224
          }
        },
        "Pool Price Function": {
          "title": "Pool Price Function",
          "summary": "The given code snippet is a Solidity function named `price()` that returns the price of a pool with 18 decimals of accuracy. The function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe function calculates the price by first determining the exponent to be used for scaling the result. This is done by checking if the `baseToken` address is equal to the zero address (i.e., no base token is set). If this is the case, the exponent is set to 18, ensuring 18 decimals of accuracy. Otherwise, the exponent is calculated as 36 minus the number of decimals of the `baseToken` (retrieved using the ERC20 standard's `decimals()` function).\n\nNext, the price is calculated by multiplying the `virtualBaseTokenReserves` by 10 raised to the power of the previously determined exponent. This result is then divided by the `virtualNftReserves` to obtain the final price.\n\nFinally, the function returns the calculated price as a `uint256` value.",
          "content": "/// @notice Returns the price of the pool to 18 decimals of accuracy.\n    /// @return price The price of the pool.\n    function price() public view returns (uint256) {\n        // ensure that the exponent is always to 18 decimals of accuracy\n        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals());\n        return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\n    }",
          "tokens": {
            "summary": 224,
            "content": 104
          }
        },
        "NFT Flash Fee": {
          "title": "NFT Flash Fee",
          "summary": "The given code snippet is a Solidity function named `flashFee` that is part of a smart contract. This function is responsible for returning the fee required to perform a flash swap of a specific Non-Fungible Token (NFT).\n\nThe function takes two input parameters:\n\n1. `address`: This is the Ethereum address associated with the NFT.\n2. `uint256`: This is an unsigned integer representing the unique identifier of the NFT.\n\nThe function is marked as `public`, which means it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract. The `view` keyword ensures that the function only reads data from the blockchain and does not write any data or consume gas.\n\nThe function returns a single output parameter:\n\n1. `uint256 feeAmount`: This is an unsigned integer representing the fee amount required to perform the flash swap of the given NFT.\n\nInside the function, the `return` statement returns the value of the `changeFee` variable, which is assumed to be a state variable in the smart contract that stores the fee amount. The `changeFee` variable is not defined within the given code snippet, but it is expected to be defined and initialized elsewhere in the smart contract.",
          "content": "/// @notice Returns the fee required to flash swap a given NFT.\n    /// @return feeAmount The fee amount.\n    function flashFee(address, uint256) public view returns (uint256) {\n        return changeFee;\n    }",
          "tokens": {
            "summary": 257,
            "content": 49
          }
        },
        "Flash Fee Token": {
          "title": "Flash Fee Token",
          "summary": "The given code snippet is a part of a smart contract written in Solidity language for the Ethereum blockchain. It defines a function called `flashFeeToken()` which is a public and view function, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe purpose of this function is to return the address of the token that is used to pay the flash fee. In this specific implementation, the function returns the value of a variable called `baseToken`. The `baseToken` variable is assumed to be defined elsewhere in the contract and holds the address of the token used for paying the flash fee.\n\nThe function has a single return statement, which returns the value of `baseToken`. The return type of the function is `address`, which is a 20-byte value representing the address of an Ethereum account or a smart contract.",
          "content": "/// @notice Returns the token that is used to pay the flash fee.\n    function flashFeeToken() public view returns (address) {\n        return baseToken;\n    }",
          "tokens": {
            "summary": 171,
            "content": 35
          }
        },
        "NFT Flash Loan": {
          "title": "NFT Flash Loan",
          "summary": "The given content is a Solidity function named `availableForFlashLoan` that checks if a specific Non-Fungible Token (NFT) is available for a flash loan. The function takes two input parameters: `token`, which is the address of the NFT contract, and `tokenId`, which is the unique identifier of the NFT. The function returns a boolean value `available` that indicates whether the NFT is available for a flash loan or not.\n\nThe function is marked as `public`, meaning it can be called from any external contract or account, and `view`, which indicates that it does not modify the state of the contract and only reads from it. The `@notice` and `@param` comments provide a brief description of the function and its parameters, while the `@return` comment describes the output of the function.",
          "content": "/// @notice Returns whether or not an NFT is available for a flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @return available Whether or not the NFT is available for a flash loan.\n    function availableForFlashLoan(address token, uint256 tokenId) public view returns (bool) {",
          "tokens": {
            "summary": 172,
            "content": 80
          }
        },
        "NFT Ownership Check": {
          "title": "NFT Ownership Check",
          "summary": "The given code snippet is a function that checks if a specific Non-Fungible Token (NFT) is owned by the current smart contract. It does this by interacting with the ERC721 standard, which is a widely used standard for NFTs on the Ethereum blockchain.\n\n1. The function starts by attempting to call the `ownerOf` function from the ERC721 smart contract, which is identified by the `token` address. The `ownerOf` function takes a `tokenId` as its argument and returns the address of the current owner of the NFT with the specified `tokenId`.\n\n2. The `try` keyword is used to handle any potential errors that may occur during the execution of the `ownerOf` function call. If the function call is successful, the returned owner address is stored in the `result` variable.\n\n3. The function then checks if the `result` (owner address) is equal to the address of the current smart contract (denoted by `address(this)`). If the addresses match, it means that the NFT is owned by the current smart contract, and the function returns `true`. Otherwise, it returns `false`.\n\n4. If an error occurs during the execution of the `ownerOf` function call, the `catch` block is executed, and the function returns `false`. This indicates that either the NFT does not exist or there was an issue with the ERC721 contract, and the ownership of the NFT could not be determined.",
          "content": "// return if the NFT is owned by this contract\n        try ERC721(token).ownerOf(tokenId) returns (address result) {\n            return result == address(this);\n        } catch {\n            return false;\n        }\n    }",
          "tokens": {
            "summary": 301,
            "content": 48
          }
        },
        "Royalty Fee Calculation": {
          "title": "Royalty Fee Calculation",
          "summary": "The given content is a function definition in a smart contract, written in Solidity programming language. The function is named `_getRoyalty` and is used to calculate the royalty fee and identify the recipient for a given Non-Fungible Token (NFT) and its sale price. The function fetches the royalty information from the Manifold registry.\n\nThe function takes two input parameters:\n\n1. `tokenId`: A `uint256` data type representing the unique identifier of the NFT.\n2. `salePrice`: A `uint256` data type representing the sale price of the NFT.\n\nThe function returns two output values:\n\n1. `royaltyFee`: A `uint256` data type representing the royalty fee to be paid.\n2. `recipient`: An `address` data type representing the address to which the royalty fee should be paid.\n\nThe function is marked as `internal`, which means it can only be called from within the same contract or contracts derived from it. It is also marked as `view`, indicating that it does not modify the state of the contract.\n\nThe function implementation starts by fetching the royalty lookup address from the Manifold registry. It does this by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the `nft` address as an argument. The result is stored in the `lookupAddress` variable.\n\nIn summary, the `_getRoyalty` function is a utility function in a smart contract that calculates the royalty fee and identifies the recipient for a given NFT and its sale price, using the Manifold registry to fetch the royalty information.",
          "content": "/// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function _getRoyalty(uint256 tokenId, uint256 salePrice)\n        internal\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);",
          "tokens": {
            "summary": 329,
            "content": 147
          }
        },
        "Royalty Fee Validation": {
          "title": "Royalty Fee Validation",
          "summary": "The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract supports the ERC-2981 interface, which is a standard for handling royalty payments in Non-Fungible Tokens (NFTs). If the contract supports the interface, it retrieves the royalty fee and recipient information for a given token ID and sale price. If the royalty fee is greater than the sale price, the transaction is reverted with an \"InvalidRoyaltyFee\" error.\n\n1. The code starts with an if statement that checks if the contract at the `lookupAddress` supports the ERC-2981 interface. This is done by calling the `supportsInterface` function on the contract and passing the `interfaceId` of the ERC-2981 standard.\n\n2. If the contract supports the ERC-2981 interface, the code proceeds to retrieve the royalty fee and recipient information for the given `tokenId` and `salePrice`. This is done by calling the `royaltyInfo` function on the contract at the `lookupAddress`.\n\n3. The `royaltyInfo` function returns two values: the recipient address (`recipient`) and the royalty fee amount (`royaltyFee`).\n\n4. The code then checks if the `royaltyFee` is greater than the `salePrice`. If this condition is true, the transaction is reverted with an \"InvalidRoyaltyFee\" error. This ensures that the royalty fee cannot exceed the sale price of the NFT.\n\nIn summary, this code snippet is used to check if a contract supports the ERC-2981 royalty standard, retrieve the royalty fee and recipient information for a specific NFT, and ensure that the royalty fee does not exceed the sale price of the token.",
          "content": "if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}",
          "tokens": {
            "summary": 356,
            "content": 92
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/PrivatePoolMetadata.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/PrivatePoolMetadata.sol",
      "globalSummary": "The PrivatePoolMetadata contract generates NFT metadata for private pools. It includes functions to return the tokenURI with its metadata, attributes encoded as JSON, and an SVG image for a pool. The contract imports and utilizes various libraries such as Strings, Base64, ERC20, and ERC721.",
      "chunkedSummaries": {
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The PrivatePoolMetadata contract, authored by out.eth (@outdoteth), is designed to generate Non-Fungible Token (NFT) metadata for private pools. This contract serves as a utility for creating and managing metadata associated with NFTs in the context of private pools, which are exclusive and restricted liquidity pools.\n\nThe contract is written in Solidity and is likely to be deployed on the Ethereum blockchain. It contains functions and data structures that facilitate the creation, storage, and retrieval of metadata for NFTs linked to private pools. This metadata can include information such as the pool's name, description, image, and other relevant details.\n\nBy utilizing this contract, developers can streamline the process of managing NFT metadata for private pools, ensuring consistency and accuracy across the platform. Additionally, the contract can help maintain the privacy and exclusivity of these pools by restricting access to metadata only to authorized users or parties.\n\nIn summary, the PrivatePoolMetadata contract is a specialized tool for handling NFT metadata in the context of private pools, providing a robust and efficient solution for developers working with exclusive and restricted liquidity pools on the Ethereum blockchain.",
          "content": "/// @title Private Pool Metadata\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to generate NFT metadata for private pools.\ncontract PrivatePoolMetadata {",
          "tokens": {
            "summary": 227,
            "content": 38
          }
        },
        "Pool TokenURI Metadata": {
          "title": "Pool TokenURI Metadata",
          "summary": "The given code snippet is a Solidity function named `tokenURI` that takes a single input parameter, `tokenId`, which is a uint256 representing the private pool's token ID. The function returns a string in memory containing the tokenURI for a pool with its metadata.\n\nThe function starts by creating a `bytes` variable named `metadata` and populating it with the ABI-encoded packed data. The data is a JSON object containing the following properties:\n\n1. \"name\": A string that concatenates \"Private Pool \" with the `tokenId` converted to a string.\n2. \"description\": A string with the value \"Caviar private pool AMM position.\"\n3. \"image\": A string that concatenates \"data:image/svg+xml;base64,\" with the Base64-encoded SVG image generated by calling the `svg` function with the `tokenId` as its argument.\n4. \"attributes\": An array containing the attributes of the token, obtained by calling the `attributes` function with the `tokenId` as its argument.\n\nFinally, the function returns a string created by ABI-encoding the packed data, which concatenates \"data:application/json;base64,\" with the Base64-encoded `metadata`. This string represents the tokenURI containing the metadata for the specified private pool token.",
          "content": "/// @notice Returns the tokenURI for a pool with it's metadata.\n    /// @param tokenId The private pool's token ID.\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // forgefmt: disable-next-item\n        bytes memory metadata = abi.encodePacked(\n            \"{\",\n                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',\n                '\"description\": \"Caviar private pool AMM position.\",',\n                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',\n                '\"attributes\": [',\n                    attributes(tokenId),\n                \"]\",\n            \"}\"\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }",
          "tokens": {
            "summary": 259,
            "content": 160
          }
        },
        "Pool Attributes Function": {
          "title": "Pool Attributes Function",
          "summary": "The given code snippet is a Solidity function named `attributes` that takes a `tokenId` of type `uint256` as input and returns a JSON-encoded string containing various attributes of a private pool. The function is marked as `public view`, meaning it can be called by anyone and does not modify the state of the contract.\n\nFirst, the function creates a `PrivatePool` instance by casting the `tokenId` to an address and making it payable. Then, it initializes a `bytes` variable named `_attributes` and assigns it the result of `abi.encodePacked` function, which is used to concatenate various attributes of the private pool.\n\nThe attributes included in the `_attributes` variable are:\n\n1. \"Pool address\": The address of the private pool, converted to a hexadecimal string.\n2. \"Base token\": The address of the base token, converted to a hexadecimal string.\n3. \"NFT\": The address of the NFT, converted to a hexadecimal string.\n4. \"Virtual base token reserves\": The virtual base token reserves, converted to a string.\n5. \"Virtual NFT reserves\": The virtual NFT reserves, converted to a string.\n6. \"Fee rate (bps)\": The fee rate in basis points, converted to a string.\n7. \"NFT balance\": The balance of NFTs held by the private pool, converted to a string.\n8. \"Base token balance\": The balance of base tokens held by the private pool, converted to a string. If the base token address is zero, the balance of the private pool address is used instead.\n\nFinally, the function returns the `_attributes` variable as a string.",
          "content": "/// @notice Returns the attributes for a pool encoded as json.\n    /// @param tokenId The private pool's token ID.\n    function attributes(uint256 tokenId) public view returns (string memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // forgefmt: disable-next-item\n        bytes memory _attributes = abi.encodePacked(\n            trait(\"Pool address\", Strings.toHexString(address(privatePool))), ',',\n            trait(\"Base token\", Strings.toHexString(privatePool.baseToken())), ',',\n            trait(\"NFT\", Strings.toHexString(privatePool.nft())), ',',\n            trait(\"Virtual base token reserves\",Strings.toString(privatePool.virtualBaseTokenReserves())), ',',\n            trait(\"Virtual NFT reserves\", Strings.toString(privatePool.virtualNftReserves())), ',',\n            trait(\"Fee rate (bps): \", Strings.toString(privatePool.feeRate())), ',',\n            trait(\"NFT balance\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool)))), ',',\n            trait(\"Base token balance\",  Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))))\n        );\n\n        return string(_attributes);\n    }",
          "tokens": {
            "summary": 337,
            "content": 256
          }
        },
        "Svg Image Generator": {
          "title": "Svg Image Generator",
          "summary": "The given code snippet is a Solidity function named `svg` that takes a `tokenId` as input and returns an SVG image representing a private pool's position in the Caviar AMM (Automated Market Maker) system. The function is marked as `public view`, meaning it can be called by anyone and does not modify the contract's state.\n\nThe function first casts the `tokenId` to an address and creates a `PrivatePool` instance from it. Then, it constructs the SVG image by concatenating multiple strings using `abi.encodePacked`. The SVG image contains various text elements displaying information about the private pool, such as its address, base token, NFT, virtual reserves, fee rate, and balances.\n\nTo avoid \"stack too deep\" errors, the SVG building process is divided into three separate scopes, each containing a portion of the SVG content. The first scope includes the private pool's address, base token, and NFT. The second scope contains the virtual base token reserves, virtual NFT reserves, and fee rate. The third and final scope displays the NFT balance and base token balance.\n\nThe SVG image is constructed using standard XML syntax, with a black background, white fill, and a serif font family. The image has a viewBox of 400x400 units and is set to scale to 100% width. The text elements are positioned at specific x and y coordinates and have a font size of 12.\n\nFinally, the function returns the constructed SVG image as a `bytes` memory object.",
          "content": "/// @notice Returns an svg image for a pool.\n    /// @param tokenId The private pool's token ID.\n    function svg(uint256 tokenId) public view returns (bytes memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // break up svg building into multiple scopes to avoid stack too deep errors\n        bytes memory _svg;\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:black;fill:white;font-family:serif;\">',\n                    '<text x=\"24px\" y=\"24px\" font-size=\"12\">',\n                        \"Caviar AMM private pool position\",\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"48px\" font-size=\"12\">',\n                        \"Private pool: \", Strings.toHexString(address(privatePool)),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"72px\" font-size=\"12\">',\n                        \"Base token: \", Strings.toHexString(privatePool.baseToken()),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"96px\" font-size=\"12\">',\n                        \"NFT: \", Strings.toHexString(privatePool.nft()),\n                    \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"120px\" font-size=\"12\">',\n                    \"Virtual base token reserves: \", Strings.toString(privatePool.virtualBaseTokenReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"144px\" font-size=\"12\">',\n                    \"Virtual NFT reserves: \", Strings.toString(privatePool.virtualNftReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"168px\" font-size=\"12\">',\n                    \"Fee rate (bps): \", Strings.toString(privatePool.feeRate()),\n                \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg, \n                    '<text x=\"24px\" y=\"192px\" font-size=\"12\">',\n                        \"NFT balance: \", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"216px\" font-size=\"12\">',\n                        \"Base token balance: \", Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                \"</svg>\"\n            );\n        }\n\n        return _svg;\n    }",
          "tokens": {
            "summary": 310,
            "content": 575
          }
        },
        "Trait Type Value": {
          "title": "Trait Type Value",
          "summary": "The given code snippet is a function named `trait` written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This function takes two input parameters, both of type `string memory`: `traitType` and `value`. The function is marked as `internal`, meaning it can only be called from within the same contract or contracts derived from it, and `pure`, indicating that it does not modify the contract's state or access any external data.\n\nThe purpose of this function is to generate a JSON-formatted string representing a trait object with two properties: \"trait_type\" and \"value\". The values of these properties are derived from the input parameters `traitType` and `value`, respectively.\n\nTo achieve this, the function uses the `abi.encodePacked` function, which is part of the Ethereum Application Binary Interface (ABI). This function takes a variable number of arguments and returns a tightly packed, concatenated byte array of the encoded arguments. In this case, the arguments are a combination of string literals and the input parameters, arranged to form a JSON object.\n\nFinally, the function returns the resulting byte array as a string by wrapping it with the `string()` typecast. The returned string will have the following format: `{\"trait_type\": \"<traitType>\", \"value\": \"<value>\"}`, where `<traitType>` and `<value>` are replaced with the actual values of the input parameters.",
          "content": "function trait(string memory traitType, string memory value) internal pure returns (string memory) {\n        // forgefmt: disable-next-item\n        return string(\n            abi.encodePacked(\n                '{ \"trait_type\": \"', traitType, '\",', '\"value\": \"', value, '\" }'\n            )\n        );\n    }\n}",
          "tokens": {
            "summary": 288,
            "content": 66
          }
        }
      }
    }
  }
}