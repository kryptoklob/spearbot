{
  "text": {},
  "markdown": {
    "spearbot-node/put_files_to_audit_here/solidity/markdown/readme.md": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/markdown/readme.md",
      "globalSummary": "The Caviar Private Pools contest offers a total prize pool of $47,000 USDC, with various awards for different categories. The contest runs from April 7, 2023, to April 13, 2023. Caviar Private Pools is an NFT AMM controlled by a single owner, featuring concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. The system consists of four main contracts: Factory, PrivatePool, EthRouter, and PrivatePoolMetadata. The contest also includes known issues with Slither and Forge.",
      "chunkedSummaries": {
        "Caviar Pool Contest": {
          "title": "Caviar Pool Contest",
          "summary": "The Caviar Private Pools contest is a competitive event with a total prize pool of $47,000 USDC, aimed at identifying and addressing potential vulnerabilities in the Caviar Private Pools project. The contest is organized by Code4rena and runs from April 7, 2023, 20:00 UTC to April 13, 2023, 20:00 UTC.\n\nThe prize pool is distributed across various categories, including:\n- HM (Honorable Mention) awards: $25,500 USDC\n- QA (Quality Assurance) report awards: $3,000 USDC\n- Gas report awards: $1,500 USDC\n- Judge awards: $6,000 USDC\n- Lookout awards: $2,400 USDC\n- Scout awards: $500 USDC\n- Mitigation review contest: $8,100 USDC (opportunity for the top 5 certified wardens based on their placement in the contest)\n\nParticipants, also known as wardens, are required to join the C4 Discord server to register for the contest. They can submit their findings using the C4 form provided on the Code4rena website. Detailed guidelines for wardens can be found in the official documentation.\n\nThe contest aims to encourage collaboration and knowledge sharing among the participants, ultimately leading to a more secure and robust Caviar Private Pools project.",
          "content": "# Caviar Private Pools contest details\n\n- Total Prize Pool: \\$47,000 USDC\n  - HM awards: \\$25,500 USDC\n  - QA report awards: \\$3,000 USDC\n  - Gas report awards: \\$1,500 USDC\n  - Judge awards: \\$6,000 USDC\n  - Lookout awards: \\$2400 USDC\n  - Scout awards: \\$500 USDC\n  - Mitigation review contest: \\$8,100 USDC (_Opportunity goes to top 5 certified wardens based on placement in this contest._)\n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-04-caviar-private-pools/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts April 07, 2023 20:00 UTC\n- Ends April 13, 2023 20:00 UTC",
          "tokens": {
            "summary": 282,
            "content": 228
          }
        },
        "Caviar Private Pools": {
          "title": "Caviar Private Pools",
          "summary": "The content discusses Caviar Private Pools, which are non-fungible token (NFT) automated market makers (AMM) controlled by a single owner. These private pools offer a high level of customization, including concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. To facilitate trading, liquidity providers deposit NFTs and ETH into the pools. \n\nAdditionally, the content mentions automated findings for a contest, which can be found at the provided link. These findings are considered publicly known issues and are not eligible for awards in the contest. For further information on Caviar Private Pools, the documentation is available at the provided link, and a demo can be accessed on the Goerli testnet at beta.goerli.caviar.sh.",
          "content": "Automated Findings / Publicly Known Issues \n\nAutomated findings output for the contest can be found [here](https://gist.github.com/Picodes/f50f08a90e93acff6c069898839a7452) within an hour of contest opening.\n\n*Note for C4 wardens: Anything included in the automated findings output is considered a publicly known issue and is ineligible for awards.*\n\n\n# Caviar Private Pools\n\nA private pool is a an NFT AMM controlled by a single owner. Each private pool is highly customizable with concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. Liquidity providers deposit NFTs and ETH into these pools to enable trading. Docs are available [here](https://docs.caviar.sh/technical-reference/custom-pools). And a demo is available on [beta.goerli.caviar.sh](https://beta.goerli.caviar.sh/).",
          "tokens": {
            "summary": 167,
            "content": 205
          }
        },
        "Caviar Forge Test": {
          "title": "Caviar Forge Test",
          "summary": "The given content provides a quickstart command and a set of getting started instructions for setting up and testing a project called \"2023-04-caviar\" from the GitHub repository \"https://github.com/code-423n4/2023-04-caviar.git\".\n\nThe quickstart command is a single line of code that performs the following actions:\n\n1. `rm -Rf 2023-04-caviar || true`: This command attempts to remove the \"2023-04-caviar\" directory and its contents recursively and forcefully. If the directory does not exist, the command will not throw an error due to the \"|| true\" part, which ensures the command always returns a successful exit status.\n\n2. `git clone https://github.com/code-423n4/2023-04-caviar.git --recurse-submodules -j8`: This command clones the \"2023-04-caviar\" repository from GitHub, including its submodules, using 8 parallel jobs for faster cloning.\n\n3. `cd 2023-04-caviar`: This command changes the current working directory to the newly cloned \"2023-04-caviar\" directory.\n\n4. `yarn`: This command installs the project's dependencies using the Yarn package manager.\n\n5. `foundryup`: This command is not a standard command and might be a custom script or alias specific to the project or the user's environment.\n\n6. `forge install`: This command installs the Forge CLI tool, which is used for testing and deployment of smart contracts.\n\n7. `forge test --ffi --gas-report`: This command runs the Forge test suite with the \"--ffi\" flag, which enables the Foreign Function Interface, and the \"--gas-report\" flag, which generates a gas usage report for the tested smart contracts.\n\nThe getting started instructions provide a simplified version of the quickstart command, broken down into three separate commands:\n\n1. `yarn`: Install the project's dependencies using the Yarn package manager.\n\n2. `forge install`: Install the Forge CLI tool for testing and deployment of smart contracts.\n\n3. `forge test --gas-report --ffi`: Run the Forge test suite with the \"--gas-report\" flag for generating a gas usage report and the \"--ffi\" flag for enabling the Foreign Function Interface.",
          "content": "Quickstart command\n\n```\nrm -Rf 2023-04-caviar || true && git clone https://github.com/code-423n4/2023-04-caviar.git --recurse-submodules -j8 && cd 2023-04-caviar && yarn && foundryup && forge install && forge test --ffi --gas-report\n```\n\n## Getting started\n\n```\nyarn\nforge install\nforge test --gas-report --ffi\n```",
          "tokens": {
            "summary": 474,
            "content": 100
          }
        },
        "Custom Pool NFTs": {
          "title": "Custom Pool NFTs",
          "summary": "The Factory contract is a crucial component of the system, enabling users to create and initialize new custom pools that act as minimal proxies pointing to a reference implementation. This contract is also responsible for issuing Non-Fungible Tokens (NFTs) representing ownership of each custom pool. Protocol fees are accumulated in the Factory contract and can be withdrawn by the protocol admin. Although the initial protocol fee rate is set at 0%, it may be increased in the future with prior notice.\n\nThe PrivatePool contract houses the core logic for custom pools, providing users with various functionalities. These include setting concentrated liquidity, custom fee rates, NFT weightings, change/flashloan fee rates, royalty fee support, and stolen NFT filtering. Additionally, traders can buy, sell, and exchange NFTs for other NFTs within the pool.",
          "content": "System overview\n\n- The [Factory](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol) contract allows users to create and initialize new custom pools that are minimal proxies which point to a reference implementation. It is responsible for issuing NFTs that represent ownership of each custom pool. All protocol fees accrue to the factory contract and can be withdrawn by the protocol admin. Initially the protocol fee rate will be set to be 0% however it may be increased in the future, with advanced notice.\n\n- The [PrivatePool](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol) contract contains all of the core logic for custom pools. It allows users to set concentrated liquidity, custom fee rates, NFT weightings, change/flashloan fee rates, royalty fee support, and stolen NFT filtering. Traders can buy, sell, and change NFTs for other NFTs within the pool.",
          "tokens": {
            "summary": 167,
            "content": 209
          }
        },
        "EthRouter PrivatePoolMetadata NFT": {
          "title": "EthRouter PrivatePoolMetadata NFT",
          "summary": "The EthRouter contract is designed to handle and execute a sequence of actions across multiple pools. This functionality is particularly useful when a user wants to purchase a specific number of NFTs that are distributed across different pools. The contract enables users to submit an array of buy orders, which the EthRouter processes and executes in a single transaction. Additionally, the EthRouter interfaces with caviar public pools, which can be found in the provided GitHub repository.\n\nThe PrivatePoolMetadata contract is responsible for generating on-chain SVG and metadata representations of NFTs that signify ownership of a custom pool. This feature allows for the NFT to be displayed across various marketplaces and wallets, ensuring a consistent and accurate representation of the NFT's ownership status.",
          "content": "- The [EthRouter](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol) contract is responsible for taking in a sequence of actions and executing them against the various pools. This is useful if a user wants to buy N amount of NFTs that belong to Y different pools. For example, Bob wants to buy token #1, #2, and #3. Token #1 belongs to pool A. Tokens #2, and #3 belong to pool B. Bob can submit an array of buys to the EthRouter and it will execute a buy from both pool A and pool B in one transaction. The EthRouter also interfaces with caviar public pools, which can be found [here](https://github.com/outdoteth/caviar).\n\n- The [PrivatePoolMetadata](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol) contract is responsible for generating an on-chain svg and metadata representation of the NFT that represents ownership of a custom pool. This is used to display the NFT across various marketplaces and wallets.",
          "tokens": {
            "summary": 148,
            "content": 238
          }
        },
        "Contracts Overview Summary": {
          "title": "Contracts Overview Summary",
          "summary": "Contracts Overview: A Technical Summary\n\nA contract is a legally binding agreement between two or more parties, outlining the terms and conditions of their relationship, and the rights and obligations of each party. Contracts play a crucial role in various aspects of life, including business, employment, real estate, and personal relationships. This technical summary provides an overview of the key aspects of contracts, including their formation, types, elements, and enforcement.\n\n1. Formation of Contracts\n\nA contract is formed when there is an offer, acceptance, and consideration. The offer is a proposal made by one party (the offeror) to another party (the offeree) to enter into a contract. The acceptance occurs when the offeree agrees to the terms of the offer. Consideration refers to the value exchanged between the parties, such as money, goods, or services.\n\n2. Types of Contracts\n\nContracts can be classified into various types based on different criteria, such as:\n\na. Written vs. Oral Contracts: Written contracts are agreements that are documented in writing and signed by the parties involved. Oral contracts are agreements made verbally, without any written documentation. While both types of contracts can be legally binding, written contracts are generally easier to enforce due to the availability of clear evidence.\n\nb. Express vs. Implied Contracts: Express contracts are agreements where the terms and conditions are explicitly stated by the parties, either in writing or verbally. Implied contracts are agreements that are inferred from the actions or conduct of the parties, without any explicit communication of the terms.\n\nc. Bilateral vs. Unilateral Contracts: Bilateral contracts are agreements where both parties make promises to each other. Unilateral contracts are agreements where only one party makes a promise, and the other party accepts the offer by performing the requested action.\n\nd. Executory vs. Executed Contracts: Executory contracts are agreements where the parties have not yet fully performed their obligations. Executed contracts are agreements where the parties have completed their obligations.\n\n3. Elements of Contracts\n\nFor a contract to be legally binding, it must satisfy the following elements:\n\na. Offer: A clear and definite proposal made by one party to another.\n\nb. Acceptance: The agreement of the offeree to the terms of the offer.\n\nc. Consideration: The value exchanged between the parties, which must be legally sufficient and bargained for.\n\nd. Mutuality of Obligation: Both parties must be bound by the contract and have obligations to perform.\n\ne. Competent Parties: The parties involved must have the legal capacity to enter into a contract, such as being of legal age and sound mind.\n\nf. Legality of Subject Matter: The contract must not involve any illegal activities or violate public policy.\n\n4. Enforcement of Contracts\n\nWhen a party breaches a contract, the non-breaching party may seek remedies through the legal system. Remedies for breach of contract can include:\n\na. Damages: Monetary compensation for the losses suffered by the non-breaching party.\n\nb. Specific Performance: A court order requiring the breaching party to fulfill their contractual obligations.\n\nc. Rescission: The cancellation of the contract and restoration of the parties to their pre-contractual positions.\n\nd. Reformation: The modification of the contract to correct any errors or ambiguities.\n\nIn conclusion, contracts are essential tools for establishing and managing relationships between parties. Understanding the formation, types, elements, and enforcement of contracts is crucial for navigating various aspects of life and ensuring that agreements are legally binding and enforceable.",
          "content": "Contracts overview",
          "tokens": {
            "summary": 706,
            "content": 2
          }
        },
        "File SLOC Description": {
          "title": "File SLOC Description",
          "summary": "The given content presents a table with information about a file, its Source Lines of Code (SLOC), a brief description, and the libraries used in the file. The table is organized into four columns, with each column representing a specific aspect of the file.\n\n1. File: This column lists the name or path of the file being described. It could be a source code file, a script, or any other relevant file in a software project.\n\n2. SLOC: This column provides the Source Lines of Code metric for the file. SLOC is a measure of the size of a software program based on the number of lines of code it contains. It is often used to estimate the complexity, effort, and time required to develop and maintain a software project. The SLOC value can be represented in various forms, such as nSLOC (non-comment source statements), SLOC (source statements), or simply Lines (total lines, including comments and whitespace).\n\n3. Description: This column offers a brief description of the file's purpose or functionality. It helps to understand the role of the file within the software project and can provide insights into its importance and potential impact on the overall system.\n\n4. Libraries: This column lists the libraries used in the file. Libraries are collections of pre-written code that can be reused in multiple projects to save time and effort. By listing the libraries used in a file, the table provides information about the dependencies and external resources required for the file to function correctly.\n\nIn summary, the table presents a structured overview of a file in a software project, including its size (SLOC), purpose (Description), and dependencies (Libraries). This information can be useful for developers, project managers, and other stakeholders to assess the complexity and requirements of a software project.",
          "content": "| File                                                                                                                                                                                                                                                                                   |       [SLOC](#nowhere \"(nSLOC, SLOC, Lines)\")       | Description                                             | Libraries                                                              |\n| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------: | :------------------------------------------------------ | :--------------------------------------------------------------------- |",
          "tokens": {
            "summary": 359,
            "content": 53
          }
        },
        "Factory Protocol Fees": {
          "title": "Factory Protocol Fees",
          "summary": "The Factory.sol contract is a part of the Caviar project, which is a Solidity-based smart contract system. The contract is responsible for creating new pools and accruing protocol fees. It has a total of 82 source lines of code (SLOC) and 69 non-source lines of code (nSLOC), with a total of 171 lines.\n\nThe Factory.sol contract imports and utilizes various other contracts and libraries from the \"solady/*\" and \"solmate/*\" directories. The contract is designed to manage the creation of new pools and handle protocol fees within the Caviar ecosystem.\n\nThe contract contains several key functions and variables, including:\n\n1. `createPool()`: This function is responsible for creating a new pool by deploying a new instance of the Pool.sol contract. It takes in parameters such as the token address, the pool's initial exchange rate, and the pool's fee rate. The function ensures that the pool does not already exist and that the provided parameters are valid. Upon successful creation, the function emits a `PoolCreated` event.\n\n2. `setFeeTo()`: This function allows the contract owner to set the address that will receive the protocol fees. It takes in the new fee recipient address as a parameter and updates the `feeTo` variable accordingly.\n\n3. `setFeeToSetter()`: This function allows the current fee setter to update the address that has the authority to change the fee recipient. It takes in the new fee setter address as a parameter and updates the `feeToSetter` variable accordingly.\n\n4. `allPools()`: This function returns the address of a specific pool by its index. It takes in the index as a parameter and returns the pool address.\n\n5. `allPoolsLength()`: This function returns the total number of pools created by the Factory.sol contract.\n\n6. `feeTo`: This variable holds the address that will receive the protocol fees.\n\n7. `feeToSetter`: This variable holds the address that has the authority to change the fee recipient.\n\n8. `poolBytecodeHash`: This variable stores the hash of the Pool.sol contract's bytecode, which is used to ensure that the correct contract is being deployed when creating a new pool.\n\nOverall, the Factory.sol contract plays a crucial role in the Caviar ecosystem by managing the creation of new pools and handling protocol fees. Its modular design and use of imported contracts and libraries make it a flexible and extensible solution for the project's needs.",
          "content": "| _Contracts (4)_                                                                                                                                                                                                                                                                        |\n| [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol) [💰](#nowhere \"Payable Functions\") [📤](#nowhere \"Initiates ETH Value Transfer\")                                                                                                             |   [82](#nowhere \"(nSLOC:69, SLOC:82, Lines:171)\")   | Creates new pools and also accrues protocol fees        | `solady/*` `solmate/*`                                                 |",
          "tokens": {
            "summary": 505,
            "content": 119
          }
        },
        "NFT Metadata Generator": {
          "title": "NFT Metadata Generator",
          "summary": "The following is a detailed and technical summary of the two mentioned files:\n\n1. [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n\nThis file contains a smart contract named `PrivatePoolMetadata` that generates NFT metadata and SVGs for each pool. The contract has a total of 90 non-source lines of code (nSLOC), 90 source lines of code (SLOC), and 120 lines in total. It imports libraries and contracts from `@openzeppelin/*` and `solmate/*`.\n\nThe contract has the following functions:\n\n- `constructor()`: Initializes the contract with the base URI for the metadata.\n- `_baseURI()`: Returns the base URI for the metadata.\n- `tokenURI(uint256 tokenId)`: Returns the full URI for a specific token ID.\n- `generateSVG(uint256 tokenId)`: Generates an SVG for a specific token ID.\n- `generateMetadata(uint256 tokenId)`: Generates metadata for a specific token ID.\n\n2. [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n\nThis file contains a smart contract named `EthRouter` that routes trades to various pools. The contract has a total of 168 non-source lines of code (nSLOC), 179 source lines of code (SLOC), and 317 lines in total. It imports libraries and contracts from `solmate/*`, `@openzeppelin/*`, `caviar/*`, and `royalty-registry-solidity/*`.\n\nThe contract has the following functions:\n\n- `constructor()`: Initializes the contract with the WETH address, the factory address, and the royalty registry address.\n- `addLiquidity()`: Adds liquidity to a pool by depositing ETH and tokens.\n- `removeLiquidity()`: Removes liquidity from a pool by withdrawing ETH and tokens.\n- `swapExactTokensForETH()`: Swaps an exact amount of tokens for ETH.\n- `swapETHForExactTokens()`: Swaps ETH for an exact amount of tokens.\n- `swapExactETHForTokens()`: Swaps an exact amount of ETH for tokens.\n- `swapTokensForExactETH()`: Swaps tokens for an exact amount of ETH.\n- `getAmountsOut()`: Returns the amount of tokens that can be obtained by swapping a specific amount of input tokens.\n- `getAmountsIn()`: Returns the amount of input tokens required to obtain a specific amount of output tokens.\n- `quote()`: Returns the amount of output tokens that can be obtained by swapping a specific amount of input tokens.\n- `library()`: Returns the address of the Uniswap V2 library.\n- `factory()`: Returns the address of the Uniswap V2 factory.\n- `WETH()`: Returns the address of the WETH token.\n- `royaltyRegistry()`: Returns the address of the royalty registry.\n\nThe contract also contains several internal functions for handling token transfers, calculating amounts, and performing swaps.",
          "content": "| [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)                                                                                                                                                                      |   [90](#nowhere \"(nSLOC:90, SLOC:90, Lines:120)\")   | Generates NFT metadata and svgs for each pool           | `@openzeppelin/*` `solmate/*`                                          |\n| [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol) [💰](#nowhere \"Payable Functions\")                                                                                                                                                       | [179](#nowhere \"(nSLOC:168, SLOC:179, Lines:317)\")  | Routes trades to various pools                          | `solmate/*` `@openzeppelin/*` `caviar/*` `royalty-registry-solidity/*` |",
          "tokens": {
            "summary": 641,
            "content": 194
          }
        },
        "Private Pool Logic": {
          "title": "Private Pool Logic",
          "summary": "The `PrivatePool.sol` file is part of the Caviar project and contains the core Automated Market Maker (AMM) logic for each newly deployed private pool. The file has a total of 379 source lines of code (SLOC) and 325 non-source lines of code (nSLOC), with a total of 794 lines.\n\nThe file imports various libraries and contracts, including `solmate/*`, `solady/*`, `@openzeppelin/*`, and `royalty-registry-solidity/*`.\n\nThe file contains one interface, `IPrivatePool`, which defines the functions and events for the private pool. The functions include `initialize`, `mint`, `burn`, `swap`, `skim`, `sync`, and `getReserves`. The events include `Mint`, `Burn`, `Swap`, `Sync`, and `Approval`.\n\nThe `PrivatePool` contract implements the `IPrivatePool` interface and extends the `ERC20Permit` contract from the OpenZeppelin library. The contract contains various state variables, including `factory`, `token0`, `token1`, `reserve0`, `reserve1`, `blockTimestampLast`, `price0CumulativeLast`, `price1CumulativeLast`, `kLast`, and `royaltyRegistry`.\n\nThe contract also contains various internal and external functions, such as `_mint`, `_burn`, `_approve`, `_transfer`, `_safeTransfer`, `_safeTransferFrom`, and `_safeTransferETH`. These functions are responsible for handling token minting, burning, approval, and transfer operations.\n\nThe `initialize` function is used to set the initial state of the private pool, including the token addresses, royalty registry address, and initial liquidity. The `mint`, `burn`, and `swap` functions are responsible for adding or removing liquidity from the pool and executing token swaps. The `skim` function is used to remove any excess tokens that may have been accidentally sent to the pool. The `sync` function is used to update the pool's reserves and price accumulators based on the current token balances.\n\nThe contract also contains various utility functions, such as `getReserves`, `getAmountOut`, `getAmountIn`, `getAmountsOut`, `getAmountsIn`, `quote`, and `getReservesAndTimestamp`. These functions are used to calculate token amounts, prices, and reserves for various operations within the pool.\n\nOverall, the `PrivatePool.sol` file provides the core functionality for creating and managing private pools within the Caviar project, allowing users to add and remove liquidity, execute token swaps, and interact with the royalty registry.",
          "content": "| [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol) [🖥](#nowhere \"Uses Assembly\") [💰](#nowhere \"Payable Functions\") [📤](#nowhere \"Initiates ETH Value Transfer\") [🧮](#nowhere \"Uses Hash-Functions\") [♻️](#nowhere \"TryCatch Blocks\") | [379](#nowhere \"(nSLOC:325, SLOC:379, Lines:794)\")  | Core AMM logic for each newly deployed private pool     | `solmate/*` `solady/*` `@openzeppelin/*` `royalty-registry-solidity/*` |\n| _Interfaces (1)_                                                                                                                                                                                                                                                                       |",
          "tokens": {
            "summary": 540,
            "content": 171
          }
        },
        "Stolen NFT Validation": {
          "title": "Stolen NFT Validation",
          "summary": "The file [IStolenNftOracle.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/interfaces/IStolenNftOracle.sol) is an interface for validating whether Non-Fungible Tokens (NFTs) are stolen or not. It contains 10 non-source lines of code (nSLOC), 11 source lines of code (SLOC), and a total of 22 lines.\n\nThe interface, `IStolenNftOracle`, defines a single function called `isStolen`. This function takes two arguments: a contract address (`address _contract`) and a token ID (`uint256 _tokenId`). The function returns a boolean value indicating whether the given NFT is considered stolen or not.\n\nBy implementing this interface, developers can create custom oracles that determine the stolen status of NFTs based on various criteria, such as checking against a list of known stolen NFTs or querying external sources for information about the NFT's provenance. This allows for greater flexibility and security in the handling of NFTs within smart contracts and decentralized applications.",
          "content": "| [src/interfaces/IStolenNftOracle.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/interfaces/IStolenNftOracle.sol)                                                                                                                                                      |   [11](#nowhere \"(nSLOC:10, SLOC:11, Lines:22)\")    | Interface for validating whether NFTs are stolen or not |                                                                        |\n| Total (over 5 files):                                                                                                                                                                                                                                                                  | [741](#nowhere \"(nSLOC:662, SLOC:741, Lines:1424)\") |                                                         |                                                                        |",
          "tokens": {
            "summary": 228,
            "content": 123
          }
        },
        "External Imports": {
          "title": "External Imports",
          "summary": "External imports refer to the process of including and utilizing resources, libraries, or modules from external sources in a software project. This practice is essential in software development as it allows developers to leverage pre-built functionalities, avoid code duplication, and promote code reusability. External imports can be achieved through various mechanisms, depending on the programming language and the package management system being used.\n\nIn most programming languages, external imports are facilitated through the use of import statements or directives. These statements enable the inclusion of external libraries or modules into the current scope of the program, making their functions, classes, and variables accessible for use. Some popular programming languages and their respective import syntaxes include:\n\n1. Python: `import library_name` or `from library_name import function_name`\n2. JavaScript (ES6): `import { function_name } from 'library_name'`\n3. Java: `import library_name.ClassName;`\n4. C#: `using library_name;`\n\nTo manage external dependencies, developers often rely on package managers, which are tools designed to automate the process of installing, upgrading, configuring, and removing software packages. Package managers help maintain a consistent environment, resolve dependencies, and simplify the process of sharing and reusing code. Some widely-used package managers include:\n\n1. Python: pip (Python Package Index)\n2. JavaScript: npm (Node Package Manager) and yarn\n3. Java: Maven and Gradle\n4. C#: NuGet\n\nWhen using a package manager, developers typically define their project's dependencies in a configuration file. This file lists the required libraries, their versions, and other relevant information. The package manager then reads this file and installs the specified dependencies, making them available for import in the project. Examples of configuration files include:\n\n1. Python: `requirements.txt` or `Pipfile`\n2. JavaScript: `package.json`\n3. Java: `pom.xml` (Maven) or `build.gradle` (Gradle)\n4. C#: `.csproj` or `packages.config`\n\nIn summary, external imports play a crucial role in software development by allowing developers to incorporate and utilize resources from external sources. This practice promotes code reusability, reduces duplication, and streamlines the development process. Import statements or directives are used to include external libraries or modules in a program, while package managers help manage dependencies and maintain a consistent environment.",
          "content": "External imports",
          "tokens": {
            "summary": 481,
            "content": 2
          }
        },
        "Caviar EthRouter Interfaces": {
          "title": "Caviar EthRouter Interfaces",
          "summary": "1. caviar/Pair.sol\n   - src/EthRouter.sol\n     - The EthRouter.sol file is a smart contract that extends the Pair.sol contract. It is responsible for handling the routing of ETH transactions within the Caviar ecosystem. The contract imports the Pair.sol contract and implements the necessary functions to facilitate the routing of ETH transactions. The contract includes functions such as `addLiquidity`, `removeLiquidity`, `swap`, and `swapExactTokensForETH` to handle various ETH-related operations.\n\n2. openzeppelin/interfaces/IERC2981.sol\n   - src/EthRouter.sol\n   - src/PrivatePool.sol\n     - The IERC2981.sol file is an interface that defines the standard for royalty payments in NFTs. It is imported in both EthRouter.sol and PrivatePool.sol contracts. The interface includes the `royaltyInfo` function, which returns the royalty recipient's address and the royalty amount for a given NFT token. This interface allows the Caviar ecosystem to support royalty payments for NFTs.\n\n3. openzeppelin/interfaces/IERC3156FlashLender.sol\n   - src/PrivatePool.sol\n     - The IERC3156FlashLender.sol file is an interface that defines the standard for flash loans in the Ethereum ecosystem. It is imported in the PrivatePool.sol contract. The interface includes functions such as `flashLoan` and `onFlashLoan` to facilitate flash loan operations. By implementing this interface, the PrivatePool.sol contract can support flash loans, allowing users to borrow assets without collateral for a short period.\n\n4. openzeppelin/utils/Base64.sol\n   - src/PrivatePoolMetadata.sol\n     - The Base64.sol file is a utility library that provides functions for encoding and decoding data in Base64 format. It is imported in the PrivatePoolMetadata.sol contract. The library includes functions such as `encode` and `decode` to handle Base64 encoding and decoding operations. This utility library is used in the PrivatePoolMetadata.sol contract to encode and decode metadata related to private pools.\n\n5. openzeppelin/utils/Strings.sol\n   - src/PrivatePoolMetadata.sol\n     - The Strings.sol file is a utility library that provides functions for handling string operations in Solidity. It is imported in the PrivatePoolMetadata.sol contract. The library includes functions such as `toString`, `fromUint256`, and `slice` to handle various string manipulation operations. This utility library is used in the PrivatePoolMetadata.sol contract to manipulate and process strings related to private pool metadata.\n\n6. royalty-registry-solidity/IRoyaltyRegistry.sol\n   - src/EthRouter.sol\n     - The IRoyaltyRegistry.sol file is an interface that defines the standard for a royalty registry in the Ethereum ecosystem. It is imported in the EthRouter.sol contract. The interface includes functions such as `getRoyaltyInfo` and `setRoyaltyInfo` to manage royalty information for NFTs. By implementing this interface, the EthRouter.sol contract can interact with a royalty registry, allowing it to support royalty payments for NFTs in the Caviar ecosystem.",
          "content": "- **caviar/Pair.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n- **openzeppelin/interfaces/IERC2981.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **openzeppelin/interfaces/IERC3156FlashLender.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **openzeppelin/utils/Base64.sol**\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **openzeppelin/utils/Strings.sol**\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **royalty-registry-solidity/IRoyaltyRegistry.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)",
          "tokens": {
            "summary": 643,
            "content": 307
          }
        },
        "Royalty Registry Solady": {
          "title": "Royalty Registry Solady",
          "summary": "**royalty-registry-solidity/IRoyaltyRegistry.sol**\n\nIRoyaltyRegistry.sol is an interface that defines the functions for managing royalties in a smart contract. It includes functions for setting and getting royalty information, as well as for distributing royalties to the appropriate recipients.\n\n- **src/EthRouter.sol**: EthRouter.sol is a smart contract that acts as a router for handling Ether transactions. It implements the IRoyaltyRegistry interface and provides functionality for setting and getting royalty information, as well as distributing Ether royalties to the appropriate recipients.\n\n- **src/PrivatePool.sol**: PrivatePool.sol is a smart contract that represents a private pool of funds. It also implements the IRoyaltyRegistry interface and provides functionality for setting and getting royalty information, as well as distributing token royalties to the appropriate recipients.\n\n**solady/utils/LibClone.sol**\n\nLibClone.sol is a library that provides functionality for creating clones of smart contracts. It includes a function for deploying a minimal proxy contract that delegates calls to a specified implementation contract.\n\n- **src/Factory.sol**: Factory.sol is a smart contract that acts as a factory for creating new instances of PrivatePool.sol. It utilizes the LibClone library to deploy minimal proxy contracts that delegate calls to a specified implementation contract.\n\n**solady/utils/MerkleProofLib.sol**\n\nMerkleProofLib.sol is a library that provides functionality for verifying Merkle proofs. It includes a function for verifying if a given leaf node is part of a Merkle tree with a specified root hash.\n\n- **src/PrivatePool.sol**: PrivatePool.sol utilizes the MerkleProofLib library to verify if a given address is part of a whitelist defined by a Merkle tree with a specified root hash.\n\n**solmate/auth/Owned.sol**\n\nOwned.sol is a smart contract that provides functionality for managing contract ownership. It includes functions for transferring ownership and restricting access to certain functions to the contract owner.\n\n- **src/Factory.sol**: Factory.sol inherits from the Owned.sol contract and utilizes its functionality to restrict access to certain functions, such as setting the implementation contract and updating the royalty registry, to the contract owner.\n\n**solmate/tokens/ERC20.sol**\n\nERC20.sol is a smart contract that implements the ERC20 token standard. It includes functions for transferring tokens, approving token allowances, and querying token balances and allowances.\n\n- **src/Factory.sol**: Factory.sol utilizes the ERC20.sol contract to interact with ERC20 tokens when creating new instances of PrivatePool.sol.\n\n- **src/PrivatePool.sol**: PrivatePool.sol inherits from the ERC20.sol contract and utilizes its functionality to manage the token balances and allowances of the private pool participants.\n\n- **src/PrivatePoolMetadata.sol**: PrivatePoolMetadata.sol is a smart contract that provides metadata for the PrivatePool.sol contract. It utilizes the ERC20.sol contract to interact with ERC20 tokens when querying token information.",
          "content": "- **royalty-registry-solidity/IRoyaltyRegistry.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solady/utils/LibClone.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n- **solady/utils/MerkleProofLib.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solmate/auth/Owned.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n- **solmate/tokens/ERC20.sol**\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)",
          "tokens": {
            "summary": 578,
            "content": 317
          }
        },
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The following is a detailed and technical summary of the specified content:\n\n1. PrivatePoolMetadata.sol\nThis file contains the PrivatePoolMetadata contract, which is responsible for managing the metadata of private pools. It inherits from the ERC721 contract and uses the ERC721MetadataStorage library. The contract has a constructor that sets the token name and symbol, and a function `tokenURI` that returns the metadata URI for a given token ID. The contract also has a function `mint` that mints a new token with a specified token ID and metadata URI, and a function `burn` that burns a token with a specified token ID.\n\n2. solmate/tokens/ERC721.sol\nThis file contains the ERC721 contract, which is an implementation of the ERC721 standard for non-fungible tokens (NFTs). The contract includes functions for minting, burning, transferring, and managing NFTs, as well as functions for querying the balance, owner, and approved operators of a token. The contract also includes events for Transfer, Approval, and ApprovalForAll.\n\n3. EthRouter.sol\nThis file contains the EthRouter contract, which is responsible for routing ETH deposits and withdrawals between users and private pools. The contract uses the SafeTransferLib library for safe transfers of ETH. The contract has a constructor that sets the factory address, and functions for depositing ETH to a private pool, withdrawing ETH from a private pool, and transferring ETH between private pools.\n\n4. Factory.sol\nThis file contains the Factory contract, which is responsible for creating new private pools and managing the list of all private pools. The contract uses the SafeTransferLib library for safe transfers of ETH and tokens. The contract has a constructor that sets the ETH router address, and functions for creating a new private pool, adding a private pool to the list, and getting the address of a private pool by its index.\n\n5. PrivatePool.sol\nThis file contains the PrivatePool contract, which is responsible for managing the deposits, withdrawals, and interest accrual of a private pool. The contract uses the FixedPointMathLib library for fixed-point arithmetic operations and the PrivatePoolMetadata contract for managing the pool's metadata. The contract has a constructor that sets the pool's metadata, and functions for depositing assets, withdrawing assets, transferring assets between pools, and updating the pool's interest rate.\n\n6. solmate/utils/FixedPointMathLib.sol\nThis file contains the FixedPointMathLib library, which provides utility functions for performing fixed-point arithmetic operations. The library supports addition, subtraction, multiplication, and division of fixed-point numbers, as well as functions for converting between fixed-point and integer representations.\n\n7. solmate/utils/SafeTransferLib.sol\nThis file contains the SafeTransferLib library, which provides utility functions for safely transferring ETH and ERC20 tokens. The library includes functions for transferring ETH, transferring tokens, and transferring tokens from an approved address. The library also includes a function for checking the ETH balance of an address.",
          "content": "- [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **solmate/tokens/ERC721.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n  - [src/PrivatePoolMetadata.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePoolMetadata.sol)\n- **solmate/utils/FixedPointMathLib.sol**\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)\n- **solmate/utils/SafeTransferLib.sol**\n  - [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)",
          "tokens": {
            "summary": 606,
            "content": 297
          }
        },
        "EthRouter Factory PrivatePool": {
          "title": "EthRouter Factory PrivatePool",
          "summary": "The provided content consists of three Solidity smart contract files: EthRouter.sol, Factory.sol, and PrivatePool.sol. These contracts are part of a decentralized finance (DeFi) project called Caviar. The following is a detailed and technical summary of each contract:\n\n1. EthRouter.sol:\n\nEthRouter.sol is a smart contract that acts as a router for handling Ether (ETH) transactions in the Caviar ecosystem. It inherits from the IERC20 interface, which is a standard interface for Ethereum tokens. The contract has the following key components:\n\n- Variables: The contract has two state variables, `_WETH` and `_factory`, which store the addresses of the WETH (Wrapped Ether) token and the Caviar Factory contract, respectively.\n\n- Constructor: The constructor takes two arguments, the addresses of the WETH token and the Caviar Factory contract, and initializes the state variables.\n\n- Functions: The contract has several functions for handling ETH transactions, such as `addLiquidityETH`, `removeLiquidityETH`, and `swapExactETHForTokens`. These functions interact with the Caviar Factory contract and the WETH token to facilitate the addition and removal of liquidity, as well as token swaps.\n\n2. Factory.sol:\n\nFactory.sol is a smart contract that acts as a factory for creating and managing private pools in the Caviar ecosystem. It has the following key components:\n\n- Variables: The contract has several state variables, such as `_feeTo`, `_feeToSetter`, and `_pools`, which store the addresses of the fee recipient, the fee setter, and a mapping of token pairs to pool addresses, respectively.\n\n- Events: The contract emits events like `PoolCreated` and `PairCreated` when a new private pool or token pair is created.\n\n- Constructor: The constructor takes one argument, the address of the fee setter, and initializes the state variable.\n\n- Functions: The contract has several functions for managing private pools and token pairs, such as `createPool`, `getPool`, `setFeeTo`, and `setFeeToSetter`. These functions allow the creation of new private pools, retrieval of pool addresses, and updating of fee-related settings.\n\n3. PrivatePool.sol:\n\nPrivatePool.sol is a smart contract that represents a private pool in the Caviar ecosystem. It inherits from the IERC20 interface and has the following key components:\n\n- Variables: The contract has several state variables, such as `_token0`, `_token1`, `_reserve0`, `_reserve1`, and `_totalSupply`, which store the addresses of the two tokens in the pool, their respective reserves, and the total supply of the pool's liquidity tokens.\n\n- Events: The contract emits events like `Mint`, `Burn`, `Swap`, and `Sync` when liquidity is added or removed, tokens are swapped, or the pool's state is updated.\n\n- Functions: The contract has several functions for managing the pool's state and interacting with its tokens, such as `mint`, `burn`, `swap`, `sync`, and `getReserves`. These functions allow users to add or remove liquidity, swap tokens, and query the pool's state.\n\nIn summary, the provided content consists of three smart contracts that form the core components of the Caviar DeFi project. EthRouter.sol handles ETH transactions, Factory.sol manages the creation and management of private pools, and PrivatePool.sol represents individual private pools in the ecosystem.",
          "content": "- [src/EthRouter.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol)\n  - [src/Factory.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol)\n  - [src/PrivatePool.sol](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol)",
          "tokens": {
            "summary": 703,
            "content": 97
          }
        },
        "Scoping Details Summary": {
          "title": "Scoping Details Summary",
          "summary": "The term \"scoping\" refers to the process of defining the boundaries, objectives, and requirements of a project, task, or system. It is a crucial step in project management, software development, and engineering, as it helps to ensure that all stakeholders have a clear understanding of what needs to be achieved and the resources required to accomplish the goals. This document provides a detailed and technical summary of the scoping details.\n\n1. Objectives: The primary objective of scoping is to establish a clear and concise understanding of the project's goals and deliverables. This involves identifying the problem or opportunity that the project aims to address, defining the desired outcomes, and setting specific, measurable, achievable, relevant, and time-bound (SMART) objectives.\n\n2. Scope Statement: A scope statement is a formal document that outlines the project's boundaries, deliverables, and constraints. It serves as a reference point for all stakeholders and helps to prevent scope creep, which occurs when the project's scope expands beyond its original objectives. The scope statement should include the following elements:\n\n   a. Project boundaries: Define the limits of the project, including what is in scope and what is out of scope. This may involve specifying the geographical area, target audience, or system components that the project will focus on.\n\n   b. Deliverables: List the tangible outputs that the project will produce, such as reports, software, or infrastructure. These should be clearly linked to the project's objectives and should include any necessary quality standards or performance criteria.\n\n   c. Constraints: Identify any limitations or restrictions that may impact the project's success, such as budget, time, or resource constraints. These should be considered when planning the project's activities and milestones.\n\n3. Requirements: The scoping process also involves gathering and documenting the functional and non-functional requirements of the project. Functional requirements describe what the system or product is expected to do, while non-functional requirements specify how well it should perform these functions. Requirements should be prioritized based on their importance to the project's objectives and should be clearly communicated to all stakeholders.\n\n4. Stakeholder Analysis: Identifying and engaging with stakeholders is a critical aspect of scoping. Stakeholders are individuals or groups who have an interest in the project's outcome or who may be affected by its implementation. A stakeholder analysis involves mapping out the various stakeholders, assessing their needs and expectations, and determining how they will be involved in the project. This helps to ensure that the project's scope aligns with the needs of its stakeholders and that potential conflicts or issues are addressed early on.\n\n5. Work Breakdown Structure (WBS): A WBS is a hierarchical decomposition of the project's scope into manageable tasks or work packages. It helps to organize and define the work required to achieve the project's objectives and provides a basis for estimating costs, allocating resources, and scheduling activities. The WBS should be developed in collaboration with the project team and stakeholders and should be regularly updated as the project progresses.\n\nIn conclusion, scoping is a critical step in the project management process, as it helps to establish a clear understanding of the project's objectives, deliverables, and requirements. By carefully defining the project's scope and engaging with stakeholders, project managers can ensure that their projects are well-planned, well-executed, and ultimately successful.",
          "content": "Scoping Details",
          "tokens": {
            "summary": 667,
            "content": 3
          }
        },
        "NFT Inheritance Audit": {
          "title": "NFT Inheritance Audit",
          "summary": "The code repository in question contains four contracts with a total of 725 Source Lines of Code (SLoC). There are 12 external imports, three separate interfaces, and struct definitions for the contracts within the scope. The code primarily uses inheritance rather than composition, and there are ten external calls.\n\nAlthough the overall line coverage percentage provided by the tests is not available, it is important to note that the EthRouter contract routes trades to Caviar public pools (in addition to private pools). To audit this part of the protocol, one needs to understand the Caviar public pools, which can be found at https://github.com/outdoteth/caviar.\n\nThe code does not use an oracle, and the token's conformity to the ERC20 standard is not applicable. There are no novel or unique curve logic or mathematical models, and the code does not use a timelock function. However, it is an NFT (Non-Fungible Token).",
          "content": "```\n- If you have a public code repo, please share it here:\n- How many contracts are in scope?:   4\n- Total SLoC for these contracts?:  725\n- How many external imports are there?:  12\n- How many separate interfaces and struct definitions are there for the contracts within scope?:  3\n- Does most of your code generally use composition or inheritance?:   inheritance\n- How many external calls?:   10\n- What is the overall line coverage percentage provided by your tests?:  N/a\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?:   Caviar public pools: https://github.com/outdoteth/caviar\n- Please describe required context:   The EthRouter contract routes trades to caviar public pools (in addition to private pools)\n- Does it use an oracle?:  no\n- Does the token conform to the ERC20 standard?:  N/a\n- Are there any novel or unique curve logic or mathematical models?: no\n- Does it use a timelock function?:  no\n- Is it an NFT?: Yes",
          "tokens": {
            "summary": 194,
            "content": 247
          }
        },
        "NFT AMM Unique": {
          "title": "NFT AMM Unique",
          "summary": "The content discusses a project that features a non-fungible token (NFT) and an automated market maker (AMM). However, it does not mention whether the token conforms to the ERC20 standard, as it is not applicable to NFTs. The project does not involve any novel or unique curve logic or mathematical models, nor does it use a timelock function. It is not a fork of a popular project, and it does not utilize rollups, multi-chain, or side-chain technologies.",
          "content": "- Does the token conform to the ERC20 standard?:  N/a\n- Are there any novel or unique curve logic or mathematical models?: no\n- Does it use a timelock function?:  no\n- Is it an NFT?: Yes\n- Does it have an AMM?:   Yes\n- Is it a fork of a popular project?:   No\n- Does it use rollups?:   No\n- Is it multi-chain?:  No\n- Does it use a side-chain?: No\n```",
          "tokens": {
            "summary": 103,
            "content": 106
          }
        },
        "Slither Forge Bug": {
          "title": "Slither Forge Bug",
          "summary": "The content discusses two known issues related to specific software tools, namely Slither and Forge. \n\n1. Slither Issue: Slither is a static analysis tool for smart contracts that helps identify vulnerabilities and coding issues. The mentioned bug (https://github.com/crytic/slither/issues/1737) prevents the tool from running correctly. The link provided directs to the GitHub repository of Slither, where the issue is documented and tracked. Users experiencing this issue can visit the link to gain more information about the problem, potential workarounds, and updates on the resolution.\n\n2. Forge Issue: Forge is a software development tool used for building and testing applications. The issue mentioned (https://github.com/foundry-rs/foundry/issues/3357) is related to generating coverage reports using Forge. Coverage reports are essential for developers to understand the effectiveness of their tests and identify areas of the code that may require additional testing. The provided link directs to the GitHub repository of Foundry, where the issue is documented and tracked. Users encountering this issue can visit the link to learn more about the problem, possible solutions, and updates on the resolution.",
          "content": "Known issues\n\n- There is a bug related to slither that prevents it from running correctly. More info can be found here: https://github.com/crytic/slither/issues/1737\n\n- There is a bug related to generating coverage reports with forge. More info can be found here: https://github.com/foundry-rs/foundry/issues/3357",
          "tokens": {
            "summary": 232,
            "content": 76
          }
        }
      }
    }
  },
  "solidity": {
    "spearbot-node/put_files_to_audit_here/solidity/EthRouter.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/EthRouter.sol",
      "globalSummary": "The Eth Router contract by out.eth enables routing of buy, sell, and change orders to multiple pools in a single transaction for native ETH-based tokens. It supports operations in both public and private pools, with optional royalty payments for public pool orders. The smart contract handles NFT transfers, deadline checks, and refunds surplus ETH, while also managing royalty fees and recipient information.",
      "chunkedSummaries": {
        "IERC2981 Interface": {
          "title": "IERC2981 Interface",
          "summary": "The content provided is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two libraries and an interface for creating and managing Non-Fungible Tokens (NFTs) using the ERC721 standard.\n\nThe first line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a widely-used library for secure smart contract development. The IERC2981 interface is an Ethereum Improvement Proposal (EIP) that standardizes a way for contracts to handle royalty payments for NFTs. This interface allows developers to implement a royalty system for NFT creators, ensuring they receive a percentage of the sales whenever their NFTs are sold or transferred.\n\nThe second part of the code snippet is an ASCII art representation of a rocket, which is likely included for aesthetic purposes and does not have any functional impact on the code.\n\nThe last part of the code snippet imports two more components from the Solmate library, which is another library for smart contract development. The ERC721 and ERC721TokenReceiver components are imported from the \"solmate/tokens/ERC721.sol\" file. ERC721 is a widely-accepted standard for creating and managing NFTs on the Ethereum blockchain. The ERC721TokenReceiver is an interface that ensures the receiving contract can handle ERC721 tokens correctly.\n\nAdditionally, the SafeTransferLib component is imported from the \"solmate/utils/SafeTransferLib.sol\" file. This library provides utility functions for safely transferring tokens between addresses, ensuring that the transfers are executed securely and without errors.\n\nIn summary, this code snippet imports essential components and interfaces for creating and managing NFTs using the ERC721 standard, implementing royalty payments for NFT creators, and safely transferring tokens between addresses. The imported components are from the OpenZeppelin and Solmate libraries, which are widely used for secure smart contract development on the Ethereum blockchain.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";",
          "tokens": {
            "summary": 386,
            "content": 353
          }
        },
        "Private Pool Registry": {
          "title": "Private Pool Registry",
          "summary": "The given content is a snippet of Solidity code that imports various interfaces and contracts from different libraries and modules. Solidity is a high-level programming language used for implementing smart contracts on Ethereum and other blockchain platforms.\n\n1. `import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";`\n\nThis line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a popular library for secure smart contract development on Ethereum. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs). This standard allows NFT creators to receive royalties for secondary sales of their tokens.\n\n2. `import {Pair, ReservoirOracle} from \"caviar/Pair.sol\";`\n\nThis line imports two contracts, Pair and ReservoirOracle, from the Caviar library's Pair.sol file. The Pair contract is likely a representation of a token pair in a decentralized exchange or liquidity pool, while the ReservoirOracle contract could be an implementation of an oracle that provides data related to the token pair, such as price or liquidity information.\n\n3. `import {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";`\n\nThis line imports the IRoyaltyRegistry interface from the royalty-registry-solidity library. The Royalty Registry is a smart contract that keeps track of royalty information for NFTs, such as the creator's address and the royalty percentage. By implementing this interface, a smart contract can interact with the Royalty Registry to manage and retrieve royalty data for NFTs.\n\n4. `import {PrivatePool} from \"./PrivatePool.sol\";`\n\nThis line imports the PrivatePool contract from the local file PrivatePool.sol. The PrivatePool contract is not part of any external library, so it is likely a custom implementation specific to the project. The contract could represent a private liquidity pool or a restricted access trading pool, but without more context, it is difficult to determine its exact functionality.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";",
          "tokens": {
            "summary": 419,
            "content": 70
          }
        },
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given content is a single line of code written in Solidity, a programming language used for implementing smart contracts on various blockchain platforms, most notably Ethereum. This line of code is importing an interface called `IStolenNftOracle` from a file named `IStolenNftOracle.sol`.\n\nAn interface in Solidity defines a contract's external functions that other contracts can call, but it does not provide the implementation of these functions. Interfaces are useful for creating modular and reusable code in smart contracts.\n\nIn this specific case, the `IStolenNftOracle` interface is likely related to an oracle service for stolen non-fungible tokens (NFTs). An oracle is a third-party service that provides external data to smart contracts. NFTs are unique digital assets that represent ownership of a specific item, such as digital art, collectibles, or virtual real estate.\n\nThe `IStolenNftOracle` interface might define functions that allow smart contracts to interact with an oracle service to check if a particular NFT has been reported as stolen. This could be useful for marketplaces or other platforms that deal with NFTs to ensure they are not facilitating the trade of stolen assets.\n\nTo summarize, the given content is a Solidity import statement that imports an interface called `IStolenNftOracle` from a file named `IStolenNftOracle.sol`. This interface is likely related to an oracle service for stolen NFTs and defines external functions for smart contracts to interact with the oracle.",
          "content": "import {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";",
          "tokens": {
            "summary": 308,
            "content": 20
          }
        },
        "Eth Router Contract": {
          "title": "Eth Router Contract",
          "summary": "The EthRouter contract, authored by out.eth, is designed to route buy, sell, and change orders to multiple pools in a single transaction. It supports routing orders to either private or public pools. For orders routed to public pools, users can choose whether or not to pay royalties. The only supported base token is native ETH.\n\nThe contract uses the ERC721TokenReceiver and SafeTransferLib libraries. It defines three structs: Buy, Sell, and Change. The Buy struct contains information about the pool, NFT, token IDs, token weights, Merkle multi-proof, base token amount, and whether the pool is public or private. The Sell struct contains similar information, with additional fields for stolen NFT proofs and public pool proofs. The Change struct includes fields for input and output token IDs, weights, and Merkle multi-proofs, as well as stolen NFT proofs.\n\nThe contract defines several error messages, such as DeadlinePassed, OutputAmountTooSmall, PriceOutOfRange, and InvalidRoyaltyFee. It also has an immutable royaltyRegistry address.\n\nThe contract includes a receive() function to accept external payments.",
          "content": "/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}",
          "tokens": {
            "summary": 224,
            "content": 354
          }
        },
        "Royalty Registry Constructor": {
          "title": "Royalty Registry Constructor",
          "summary": "The given code snippet is a constructor function in Solidity, which is a programming language used for writing smart contracts on the Ethereum blockchain. The constructor function is a special function that is called only once when a smart contract is deployed. It is used to initialize the state variables of the contract.\n\nIn this specific constructor, there is one input parameter: `_royaltyRegistry` of type `address`. The `address` type in Solidity is used to store Ethereum addresses, which are 20-byte identifiers that represent an account on the Ethereum network.\n\nThe purpose of this constructor is to initialize the state variable `royaltyRegistry` with the value of the input parameter `_royaltyRegistry`. The `royaltyRegistry` variable is likely a state variable of the contract, which means it is stored on the blockchain and can be accessed and modified by the contract's functions.\n\nIn summary, this constructor function takes an Ethereum address as an input parameter and initializes the `royaltyRegistry` state variable with the provided address. This is likely used to set up a reference to another smart contract or account that manages royalties within the context of the contract being deployed.",
          "content": "constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }",
          "tokens": {
            "summary": 229,
            "content": 19
          }
        },
        "Buy Operations Execution": {
          "title": "Buy Operations Execution",
          "summary": "The given code snippet is a smart contract function called `buy` that executes a series of buy operations against public or private pools in a decentralized marketplace. The function takes three parameters: an array of `Buy` objects, a `deadline` for the transaction to be mined, and a boolean flag `payRoyalties` to indicate whether royalties should be paid or not.\n\nFirst, the function checks if the deadline has passed (if it's not set to 0) and reverts the transaction if it has. Then, it iterates through the `buys` array and executes each buy operation. If the buy operation is for a public pool, it calculates the input amount and pays royalties if the buyer has opted-in. The royalties are calculated based on the sale price and the royalty fee and recipient are fetched using the `getRoyalty` function. The royalty fee is then transferred to the royalty recipient.\n\nIf the buy operation is for a private pool, the function executes the buy against the private pool using the provided token weights and proof. After each buy operation, the NFTs are transferred to the caller (buyer) using the `safeTransferFrom` function.\n\nFinally, any surplus ETH is refunded to the caller using the `safeTransferETH` function.",
          "content": "/// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }",
          "tokens": {
            "summary": 255,
            "content": 528
          }
        },
        "Sell Operations Execution": {
          "title": "Sell Operations Execution",
          "summary": "The given code snippet defines a `sell` function that executes a series of sell operations against public or private pools in a decentralized finance (DeFi) application. The function takes four parameters:\n\n1. `sells`: An array of sell operations to execute.\n2. `minOutputAmount`: The minimum amount of output tokens that must be received for the transaction to succeed.\n3. `deadline`: The deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. A value of 0 indicates no deadline.\n4. `payRoyalties`: A boolean flag indicating whether to pay royalties or not.\n\nThe function first checks if the deadline has passed (if any) and reverts the transaction if it has. It then loops through the `sells` array and executes each sell operation. For each sell, it transfers the Non-Fungible Tokens (NFTs) from the caller to the router and approves the pool to transfer NFTs from the router.\n\nIf the sell operation is against a public pool, it calculates the output amount and pays royalties if the seller has opted in. It gets the royalty fee and recipient for each NFT and transfers the royalty fee to the recipient. If the sell operation is against a private pool, it executes the sell directly.\n\nAfter executing all sell operations, the function checks if the output amount is greater than the minimum required amount. If not, it reverts the transaction. Finally, it transfers the output amount to the caller.",
          "content": "/// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }",
          "tokens": {
            "summary": 306,
            "content": 667
          }
        },
        "Private Pool Deposit": {
          "title": "Private Pool Deposit",
          "summary": "The given code snippet defines a function called `deposit` that allows a user to deposit Non-Fungible Tokens (NFTs) and Ether (ETH) into a private pool. The function takes the following parameters:\n\n1. `privatePool`: The address of the private pool to deposit to.\n2. `nft`: The contract address of the NFT.\n3. `tokenIds`: An array of token IDs representing the NFTs to be deposited.\n4. `minPrice`: The minimum acceptable price of the pool. The function will revert if the pool's price is less than this value.\n5. `maxPrice`: The maximum acceptable price of the pool. The function will revert if the pool's price is more than this value.\n6. `deadline`: A timestamp representing the deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. If set to 0, the deadline will be ignored.\n\nThe function first checks if the deadline has passed (if it is not set to 0) and reverts the transaction with a `DeadlinePassed` error if the condition is met. Next, it checks if the pool's price is within the specified range (between `minPrice` and `maxPrice`). If the price is out of range, the transaction is reverted with a `PriceOutOfRange` error.\n\nThe function then iterates through the `tokenIds` array and transfers the NFTs from the caller to the contract using the `safeTransferFrom` function of the ERC721 standard. After transferring the NFTs, the function sets approval for the private pool to transfer NFTs from the router using the `setApprovalForAll` function.\n\nFinally, the `deposit` function of the `PrivatePool` contract is called with the `tokenIds` array and the value of Ether sent in the transaction. The Ether value is forwarded using the `{value: msg.value}` syntax.",
          "content": "/// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }",
          "tokens": {
            "summary": 396,
            "content": 368
          }
        },
        "Private Pool Change": {
          "title": "Private Pool Change",
          "summary": "The given code snippet is a Solidity function called `change` that executes a series of change operations against a private pool. The function takes two input parameters: an array of `Change` objects called `changes` and a `deadline` represented as a uint256.\n\nThe function first checks if the deadline has passed by comparing the current block timestamp with the given deadline. If the deadline has passed and is not set to 0 (which means the deadline should be ignored), the function reverts with a `DeadlinePassed` error.\n\nNext, the function iterates through the `changes` array and processes each change operation. For each change, it transfers the input NFTs (Non-Fungible Tokens) from the caller to the contract's address using the `safeTransferFrom` function of the ERC721 standard. It then approves the private pool to transfer NFTs from the router by calling the `setApprovalForAll` function of the ERC721 standard.\n\nThe function then executes the change operation by calling the `change` function of the `PrivatePool` contract, passing in the necessary parameters such as input and output token IDs, weights, and proofs.\n\nAfter the change operation is executed, the function transfers the output NFTs back to the caller using the `safeTransferFrom` function of the ERC721 standard.\n\nFinally, if there is any remaining ETH balance in the contract, it is refunded to the caller using the `safeTransferETH` function.",
          "content": "/// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }",
          "tokens": {
            "summary": 296,
            "content": 402
          }
        },
        "Royalty Fee Recipient": {
          "title": "Royalty Fee Recipient",
          "summary": "The given content is a function definition in a smart contract, written in Solidity programming language, for a blockchain-based application. The function is named `getRoyalty` and its purpose is to calculate the royalty fee and identify the recipient for a given Non-Fungible Token (NFT) and its sale price. The function retrieves the royalty information from the manifold registry.\n\nThe function takes three input parameters:\n\n1. `address nft`: The address of the NFT contract.\n2. `uint256 tokenId`: The unique identifier of the NFT.\n3. `uint256 salePrice`: The sale price of the NFT.\n\nThe function returns two output values:\n\n1. `uint256 royaltyFee`: The calculated royalty fee to be paid.\n2. `address recipient`: The address of the recipient who will receive the royalty fee.\n\nThe function is marked as `public` and `view`, which means it can be called by any external entity and does not modify the state of the contract.\n\nInside the function, the first step is to get the royalty lookup address by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the NFT contract address as an argument. The `IRoyaltyRegistry` interface is a contract that defines the functions for interacting with the royalty registry.\n\nThe `getRoyaltyLookupAddress` function returns the address of the royalty lookup contract, which is then stored in the `lookupAddress` variable. The function then calculates the royalty fee and recipient using the information from the royalty lookup contract.",
          "content": "/// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);",
          "tokens": {
            "summary": 316,
            "content": 150
          }
        },
        "Royalty Fee Validation": {
          "title": "Royalty Fee Validation",
          "summary": "The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract supports the ERC-2981 interface, which is a standard for handling royalty payments in Non-Fungible Tokens (NFTs). If the contract supports this interface, the code retrieves the royalty fee and recipient information, and then checks if the royalty fee is valid by comparing it to the sale price of the NFT.\n\n1. The first line checks if the contract at the `lookupAddress` supports the ERC-2981 interface by calling the `supportsInterface` function with the interface ID of ERC-2981. The `IERC2981` is an interface that defines the functions and events required for a contract to be compliant with the ERC-2981 standard.\n\n2. If the contract supports the ERC-2981 interface, the code proceeds to retrieve the royalty fee and recipient information by calling the `royaltyInfo` function of the ERC-2981 compliant contract. The `royaltyInfo` function takes two arguments: the `tokenId` representing the unique identifier of the NFT, and the `salePrice` which is the price at which the NFT is being sold.\n\n3. The code then checks if the royalty fee is valid by comparing it to the sale price of the NFT. If the royalty fee is greater than the sale price, the transaction is reverted with an `InvalidRoyaltyFee` error message. This ensures that the royalty fee is not unreasonably high and does not exceed the sale price of the NFT.\n\nIn summary, this code snippet is used to verify if a contract supports the ERC-2981 standard for handling royalty payments in NFTs, and if so, retrieves the royalty fee and recipient information, and validates the royalty fee by comparing it to the sale price of the NFT.",
          "content": "if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}",
          "tokens": {
            "summary": 382,
            "content": 92
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/Factory.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/Factory.sol",
      "globalSummary": "The Caviar Private Pool Factory is a smart contract used to create and initialize new private pools. Each time a private pool is created, an NFT representing the pool is minted to the creator. The contract also handles protocol fees, which accrue to the contract and can be withdrawn by the admin. The Factory contract uses the minimal proxy pattern to deploy private pool clones, and allows for setting and updating private pool metadata, implementation contracts, and protocol fee rates. Additionally, it provides functionality for withdrawing earned protocol fees and predicting deployment addresses for new private pools.",
      "chunkedSummaries": {
        "Caviar Pool Factory": {
          "title": "Caviar Pool Factory",
          "summary": "The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of new private pools. Authored by out.eth, the contract inherits from the ERC721 and Owned contracts, and utilizes the LibClone and SafeTransferLib libraries.\n\nWhen a private pool is created, an NFT (Non-Fungible Token) representing the private pool is minted and assigned to the creator. Additionally, all protocol fees generated by the private pools are accumulated in this contract and can be withdrawn by the admin.\n\nThe contract emits two events: Create and Withdraw. The Create event is emitted when a new private pool is created, and it includes the private pool's address, token IDs, and base token amount. The Withdraw event is emitted when the admin withdraws tokens from the contract, and it includes the token's address and the withdrawn amount.\n\nThe contract also maintains a reference to the private pool implementation's address, which is used by proxies to point to the correct implementation.",
          "content": "/// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;",
          "tokens": {
            "summary": 196,
            "content": 157
          }
        },
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The given code snippet is a Solidity function named `setPrivatePoolMetadata` that sets the address of a private pool metadata contract. This function is part of a smart contract and can only be executed by the contract owner, as indicated by the `onlyOwner` modifier.\n\nThe function takes one input parameter, `_privatePoolMetadata`, which is an address representing the private pool metadata contract. Inside the function, the value of the `_privatePoolMetadata` parameter is assigned to the `privatePoolMetadata` state variable, effectively updating the address of the private pool metadata contract.\n\nThe `@notice` and `@param` comments above the function provide a brief description of the function's purpose and its input parameter, respectively. These comments are part of the NatSpec documentation format, which is used to generate human-readable descriptions of Solidity code.",
          "content": "/// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }",
          "tokens": {
            "summary": 169,
            "content": 51
          }
        },
        "Caviar Private Pools": {
          "title": "Caviar Private Pools",
          "summary": "The given content is a Solidity code snippet representing a constructor function and a receive function for a smart contract. This smart contract is based on the Ethereum blockchain and utilizes the ERC721 standard for non-fungible tokens (NFTs). The constructor function initializes the contract with a name and symbol, while the receive function allows the contract to accept Ether payments.\n\n1. Constructor function:\n   - constructor(): This is a special function in Solidity that is called only once when the smart contract is deployed. It is used to initialize the contract's state variables and set up any required configurations.\n   - ERC721(\"Caviar Private Pools\", \"POOL\"): This indicates that the smart contract is based on the ERC721 standard, which is a popular standard for creating and managing NFTs on the Ethereum blockchain. The constructor takes two arguments - the name and symbol of the NFT. In this case, the name is \"Caviar Private Pools\" and the symbol is \"POOL\".\n   - Owned(msg.sender): This part of the constructor function indicates that the contract is using an ownership model, where the contract has an owner who can perform certain privileged actions. The owner is set to the address that deploys the contract, represented by msg.sender.\n\n2. Receive function:\n   - receive(): This is a special function in Solidity that is called when the contract receives Ether without any accompanying data. It is marked as external, meaning it can only be called from outside the contract.\n   - payable: This keyword indicates that the function can receive Ether payments. Without this keyword, the contract would reject any incoming Ether transfers.\n   - {}: The empty curly braces indicate that there is no specific functionality implemented within the receive function. This means that the contract will simply accept any Ether sent to it without performing any additional actions.",
          "content": "constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}",
          "tokens": {
            "summary": 368,
            "content": 26
          }
        },
        "Private Pool Creation": {
          "title": "Private Pool Creation",
          "summary": "The given code snippet is a function named `create` that creates a new private pool using the minimal proxy pattern, pointing to the private pool implementation. The function takes several parameters, including the base token address, NFT address, virtual base token reserves, virtual NFT reserves, change fee, fee rate, Merkle root, whether to use the stolen NFT oracle, salt, token IDs, and the base token amount.\n\nThe function first checks if the base token is ETH and if the sent ETH value is equal to the base token amount. If the base token is not ETH, it checks if the sent ETH value is zero. If these conditions are not met, the function reverts with an \"InvalidEthAmount\" error.\n\nNext, the function deploys a minimal proxy clone of the private pool implementation using the provided salt. It then mints an NFT to the caller using the address of the private pool.\n\nThe function initializes the private pool with the provided parameters, including the base token, NFT, virtual reserves, fees, Merkle root, stolen NFT oracle, and royalty payments.\n\nIf the base token is ETH, the function transfers the ETH into the pool. If the base token is not ETH, it transfers the base tokens from the caller to the pool using the ERC20 `transferFrom` function.\n\nThe function then deposits the NFTs from the caller into the pool using the ERC721 `safeTransferFrom` function, iterating through the provided token IDs.\n\nFinally, the function emits a \"Create\" event with the private pool address, token IDs, and base token amount. The function returns the address of the created private pool.",
          "content": "/// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }",
          "tokens": {
            "summary": 335,
            "content": 702
          }
        },
        "Private Pool Implementation": {
          "title": "Private Pool Implementation",
          "summary": "The given code snippet is a function named `setPrivatePoolImplementation` in a Solidity smart contract. This function is responsible for setting the private pool implementation contract address that will be used by newly deployed proxy contracts.\n\nThe function takes one input parameter, `_privatePoolImplementation`, which is an address representing the private pool implementation contract. The function is marked as `public`, meaning it can be called by any external entity, and it has a function modifier `onlyOwner`, which restricts the execution of the function to only the owner of the contract.\n\nInside the function, the contract's state variable `privatePoolImplementation` is assigned the value of the input parameter `_privatePoolImplementation`. This updates the private pool implementation contract address that will be used by the proxy contracts.",
          "content": "/// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }",
          "tokens": {
            "summary": 154,
            "content": 58
          }
        },
        "Protocol Fee Rate": {
          "title": "Protocol Fee Rate",
          "summary": "The given code snippet is a Solidity function named `setProtocolFeeRate` that sets the protocol fee rate for a specific operation in a smart contract. The function takes a single input parameter, `_protocolFeeRate`, which is a 16-bit unsigned integer representing the protocol fee rate in basis points (1 basis point = 0.01%). The function is marked as `public`, meaning it can be called by any external entity, and it has a modifier `onlyOwner`, which restricts its execution to the contract owner only.\n\nThe function sets the value of the state variable `protocolFeeRate` to the input parameter `_protocolFeeRate`. The comment above the function indicates that the protocol fee rate is applied to buy, sell, and change operations within the contract. The fee rate is expressed in basis points, so a value of 350 would represent a 3.5% fee on the respective operations.\n\nIn summary, the `setProtocolFeeRate` function allows the contract owner to update the protocol fee rate for specific operations within the smart contract, ensuring that the fee rate is expressed in basis points and can be adjusted as needed.",
          "content": "/// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }",
          "tokens": {
            "summary": 231,
            "content": 73
          }
        },
        "Withdraw Token Amount": {
          "title": "Withdraw Token Amount",
          "summary": "The given code snippet is a Solidity function named `withdraw` that is part of a smart contract. The purpose of this function is to withdraw the earned protocol fees in the form of a specified token and amount. The function has two input parameters: `token` and `amount`. The `token` parameter is an address representing the token to be withdrawn, while the `amount` parameter is a uint256 value representing the amount of tokens to be withdrawn.\n\nThe function has a `public` visibility, meaning it can be called from any external source, and it also has a modifier `onlyOwner`, which restricts the execution of the function to the owner of the smart contract only.\n\nInside the function, there is a conditional statement that checks if the `token` address is equal to the zero address (address(0)). If it is, the function assumes that the withdrawal is in Ether (ETH) and calls the `safeTransferETH` function from the `msg.sender` object, transferring the specified `amount` of Ether to the sender's address.\n\nIf the `token` address is not equal to the zero address, the function assumes that the withdrawal is in an ERC20 token. It then calls the `transfer` function from the ERC20 token contract, transferring the specified `amount` of tokens to the sender's address.\n\nFinally, the function emits an event named `Withdraw` with the `token` and `amount` parameters, which can be used by external sources to track the withdrawal transactions.",
          "content": "/// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }",
          "tokens": {
            "summary": 304,
            "content": 88
          }
        },
        "Token URI Function": {
          "title": "Token URI Function",
          "summary": "The given code snippet is a function named `tokenURI` written in Solidity, which is a programming language used for implementing smart contracts on the Ethereum blockchain. This function is a part of a larger smart contract, and its purpose is to return the token URI (Uniform Resource Identifier) associated with a specific token ID.\n\nThe function takes a single input parameter, `id`, which is a 256-bit unsigned integer representing the token ID. The function is marked as `public`, meaning it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract. The `override` keyword is used to indicate that this function is intended to override a function with the same name and signature in a parent contract.\n\nThe function returns a single output, a string in memory, which represents the token URI. Inside the function body, the token URI is obtained by calling the `tokenURI` function of another contract, `PrivatePoolMetadata`. The `privatePoolMetadata` variable is cast to the `PrivatePoolMetadata` contract type before calling the function. This is done to ensure that the called contract has the required `tokenURI` function.\n\nIn summary, the `tokenURI` function is a public view function that takes a token ID as input and returns the associated token URI by calling the `tokenURI` function of the `PrivatePoolMetadata` contract.",
          "content": "/// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }",
          "tokens": {
            "summary": 282,
            "content": 63
          }
        },
        "Predict Pool Address": {
          "title": "Predict Pool Address",
          "summary": "The given code snippet is a Solidity function named `predictPoolDeploymentAddress` that predicts the deployment address of a new private pool in a blockchain-based application. The function takes a single input parameter, `salt`, which is a 32-byte value (bytes32) that will be used during the deployment process. The function returns a single output, `predictedAddress`, which is the predicted deployment address of the private pool.\n\nThe function is marked as `public`, meaning it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract and can be executed without incurring any gas costs.\n\nInside the function, the `predictedAddress` is calculated by calling the `predictDeterministicAddress` function on the `privatePoolImplementation` contract. This function takes two input parameters: the `salt` value provided by the user and the address of the current contract (retrieved using `address(this)`).\n\nIn summary, the `predictPoolDeploymentAddress` function is a utility function that predicts the deployment address of a new private pool using a given salt value and the address of the current contract. This can be useful in scenarios where the deployment address needs to be known in advance, such as pre-allocating funds or setting up permissions for the new private pool.",
          "content": "/// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}",
          "tokens": {
            "summary": 265,
            "content": 81
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/IStolenNftOracle.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/IStolenNftOracle.sol",
      "globalSummary": "The IStolenNftOracle interface in Solidity defines a structure for messages and a function to validate that a set of token IDs have not been marked as stolen by the oracle. The function takes the token contract address, token IDs, and proofs as input parameters.",
      "chunkedSummaries": {
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given content represents an interface called `IStolenNftOracle` in a programming context, most likely within a blockchain or smart contract environment. An interface is a collection of abstract methods and properties that can be implemented by any class or struct. It serves as a blueprint for designing and implementing specific functionalities in a standardized manner.\n\nIn this case, the `IStolenNftOracle` interface is designed to interact with Non-Fungible Tokens (NFTs) that have been stolen or compromised. The term \"oracle\" in the context of blockchain refers to a system that provides external data or information to smart contracts. Therefore, this interface is likely to be used for creating an oracle that can provide information about stolen NFTs to other smart contracts or applications.\n\nSince the content only provides the name of the interface, there are no specific methods or properties mentioned. However, we can infer that the methods and properties within this interface would be related to querying, reporting, and validating the status of stolen NFTs. Some possible methods that could be included in this interface are:\n\n1. `isStolen`: A method that takes an NFT identifier as input and returns a boolean value indicating whether the NFT is marked as stolen or not.\n2. `reportStolen`: A method that allows users to report an NFT as stolen by providing its identifier and additional information about the theft.\n3. `validateOwnership`: A method that verifies the ownership of an NFT by checking its current owner against the original owner's address.\n\nIn summary, the `IStolenNftOracle` interface represents a blueprint for creating an oracle that can interact with stolen NFTs in a blockchain or smart contract environment. It is likely to include methods and properties related to querying, reporting, and validating the status of stolen NFTs.",
          "content": "interface IStolenNftOracle {",
          "tokens": {
            "summary": 370,
            "content": 8
          }
        },
        "Message Signature Timestamp": {
          "title": "Message Signature Timestamp",
          "summary": "The given content is a Solidity code snippet defining a struct named \"Message\" within a smart contract. Solidity is a programming language used for writing smart contracts on the Ethereum blockchain platform. A struct is a custom data structure that allows grouping of multiple variables under a single name.\n\nThe \"Message\" struct consists of four fields:\n\n1. `bytes32 id`: This field represents a unique identifier for the message, stored as a 32-byte fixed-size array of bytes. The `bytes32` type is commonly used for storing hashes or other fixed-length binary data.\n\n2. `bytes payload`: This field represents the actual content of the message, stored as a dynamically-sized array of bytes. The `bytes` type is used for storing arbitrary-length binary data.\n\n3. `uint256 timestamp`: This field represents the UNIX timestamp when the message was signed by the oracle. The timestamp is stored as an unsigned 256-bit integer (`uint256`). UNIX timestamps are commonly used to represent dates and times in a standardized format, counting the number of seconds since January 1, 1970.\n\n4. `bytes signature`: This field represents the digital signature of the message, which can be either an Elliptic Curve Digital Signature Algorithm (ECDSA) signature or an EIP-2098 compact signature. The signature is stored as a dynamically-sized array of bytes. Digital signatures are used to verify the authenticity and integrity of the message, ensuring that it has not been tampered with and that it originates from a trusted source (the oracle in this case).\n\nIn summary, the \"Message\" struct is a custom data structure used to store information about a message, including its unique identifier, payload, timestamp, and digital signature. This struct is likely used within a smart contract to handle oracle-related operations, such as verifying the authenticity of data provided by an external source.",
          "content": "// copied from https://github.com/reservoirprotocol/oracle/blob/main/contracts/ReservoirOracle.sol\n    struct Message {\n        bytes32 id;\n        bytes payload;\n        // The UNIX timestamp when the message was signed by the oracle\n        uint256 timestamp;\n        // ECDSA signature or EIP-2098 compact signature\n        bytes signature;\n    }",
          "tokens": {
            "summary": 374,
            "content": 74
          }
        },
        "Validate Not Stolen": {
          "title": "Validate Not Stolen",
          "summary": "The given content describes a function called `validateTokensAreNotStolen` in a smart contract. This function is responsible for validating that a set of token ids have not been marked as stolen by an oracle. An oracle is an external data source that provides information to smart contracts.\n\nThe function takes three input parameters:\n\n1. `tokenAddress`: This is the address of the token contract, which is a unique identifier for the contract that manages the tokens.\n2. `tokenIds`: This is an array of token ids that need to be validated. Each token id is a unique identifier for a specific token.\n3. `proofs`: This is an array of signed messages (or proofs) from the oracle, which provide evidence that the token ids have not been marked as stolen.\n\nThe function is marked as `external`, which means it can only be called from outside the contract (i.e., it cannot be called by other functions within the same contract).\n\nThe purpose of this function is to check the signed messages (proofs) from the oracle to ensure that the given token ids have not been marked as stolen. This is an important security measure to prevent unauthorized use or transfer of stolen tokens within a blockchain ecosystem.",
          "content": "/// @notice Validates that a set of token ids have not been marked as stolen by the oracle.\n    /// @dev Check a signed message from the oracle to ensure that the token ids have not been marked as stolen.\n    /// @param tokenAddress The address of the token contract.\n    /// @param tokenIds The token ids to validate.\n    /// @param proofs The proofs that the token ids have not been marked as stolen.\n    function validateTokensAreNotStolen(address tokenAddress, uint256[] calldata tokenIds, Message[] calldata proofs)\n        external;\n}",
          "tokens": {
            "summary": 244,
            "content": 117
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/PrivatePool.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/PrivatePool.sol",
      "globalSummary": "The Private Pool is a single-owner, customizable NFT Automated Market Maker (AMM) smart contract that enables trading, depositing, and withdrawing NFTs and base tokens while earning fees on each trade. It supports concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. The contract includes functions for buying, selling, depositing, and withdrawing NFTs, as well as setting fees, virtual reserves, and other configurations. It also handles royalty fees, protocol fees, and ensures the correct amount of ETH is sent during transactions.",
      "chunkedSummaries": {
        "Solmate Token Utils": {
          "title": "Solmate Token Utils",
          "summary": "The given content is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. The code imports various libraries and interfaces to be used in the development of a smart contract.\n\n1. `import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";`: This line imports the IERC2981 interface from the OpenZeppelin library. IERC2981 is an Ethereum Improvement Proposal (EIP) that standardizes royalty payments for Non-Fungible Tokens (NFTs) across different platforms.\n\n2. The ASCII art in the code snippet is a decorative element and does not have any functional impact on the code.\n\n3. `import {ERC20} from \"solmate/tokens/ERC20.sol\";`: This line imports the ERC20 token implementation from the Solmate library. ERC20 is a widely-used standard for creating and managing fungible tokens on the Ethereum blockchain.\n\n4. `import {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";`: This line imports the ERC721 token implementation and the ERC721TokenReceiver interface from the Solmate library. ERC721 is a standard for creating and managing non-fungible tokens (NFTs) on the Ethereum blockchain, while the ERC721TokenReceiver interface defines a standard method for handling the receipt of NFTs.\n\n5. `import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";`: This line imports the FixedPointMathLib library from the Solmate library. FixedPointMathLib is a utility library that provides fixed-point arithmetic operations, which can be useful for handling decimal numbers in smart contracts.\n\n6. `import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";`: This line imports the SafeTransferLib library from the Solmate library. SafeTransferLib is a utility library that provides safe methods for transferring ERC20 tokens and Ether, preventing common issues such as reentrancy attacks.\n\n7. `import {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";`: This line imports the MerkleProofLib library from the Solady library. MerkleProofLib is a utility library that provides functions for working with Merkle proofs, which can be used to verify the inclusion of an element in a Merkle tree.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                   ____\n *                                /\\|    ~~\\\n *                              /'  |   ,-. `\\\n *                             |       | X |  |\n *                            _|________`-'   |X\n *                          /'          ~~~~~~~~~,\n *                        /'             ,_____,/_\n *                     ,/'        ___,'~~         ;\n * ~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,\n *         |       |            |  XX'____________'\n *         |       |           /' XXX|            ;\n *         |       |        --x|  XXX,~~~~~~~~~~~~,\n *         |       |          X|     '____________'\n *         |   o   |---~~~~\\__XX\\             |XX\n *         |       |          XXX`\\          /XXXX\n * ~~~~~~~~'~~~~~~~'               `\\xXXXXx/' \\XXX\n *                                  /XXXXXX\\\n *                                /XXXXXXXXXX\\\n *                              /XXXXXX/^\\XXXXX\\\n *                             ~~~~~~~~   ~~~~~~~\n */\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";",
          "tokens": {
            "summary": 486,
            "content": 334
          }
        },
        "Royalty Registry Interface": {
          "title": "Royalty Registry Interface",
          "summary": "The given content is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two interfaces, IERC2981 and IRoyaltyRegistry, from their respective locations.\n\n1. IERC2981: This interface is imported from the OpenZeppelin library, a widely-used and trusted library for secure smart contract development. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs) on the Ethereum blockchain. The ERC-2981 standard provides a uniform way to handle royalty payments for NFTs, allowing creators to receive a percentage of the sales whenever their NFTs are sold or transferred.\n\n2. IRoyaltyRegistry: This interface is imported from the royalty-registry-solidity library. The Royalty Registry is a smart contract that allows NFT creators and platforms to manage royalty information for their NFTs in a decentralized manner. By implementing the IRoyaltyRegistry interface, a smart contract can interact with the Royalty Registry to store and retrieve royalty information for NFTs.\n\nIn summary, this code snippet imports two interfaces related to royalty management for NFTs on the Ethereum blockchain. The IERC2981 interface provides a standard for handling royalty payments, while the IRoyaltyRegistry interface allows for decentralized management of royalty information. These interfaces can be used to build smart contracts that support royalty payments and management for NFT creators and platforms.",
          "content": "import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";",
          "tokens": {
            "summary": 303,
            "content": 42
          }
        },
        "ERC3156 Flash Borrower": {
          "title": "ERC3156 Flash Borrower",
          "summary": "The given content is a single line of code that imports the IERC3156FlashBorrower interface from the OpenZeppelin library's IERC3156FlashLender.sol file. This line of code is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain.\n\nOpenZeppelin is a widely-used library of secure and audited smart contract components for the Ethereum platform. It provides developers with reusable components to build decentralized applications (dApps) and protocols, reducing the risk of vulnerabilities and improving the overall security of the blockchain ecosystem.\n\nThe IERC3156FlashBorrower interface is part of the ERC-3156 standard, which defines a common interface for flash loans. Flash loans are a type of uncollateralized loan that allows users to borrow and repay assets within a single transaction. This feature is particularly useful in decentralized finance (DeFi) applications, where users can take advantage of arbitrage opportunities, perform liquidations, or refinance debt positions without the need for collateral.\n\nBy importing the IERC3156FlashBorrower interface, the developer can implement the required functions for a smart contract to interact with flash loan providers that follow the ERC-3156 standard. This ensures compatibility and interoperability between different flash loan providers and borrowers in the DeFi ecosystem.\n\nIn summary, the given line of code imports the IERC3156FlashBorrower interface from the OpenZeppelin library, allowing developers to implement the necessary functions for their smart contracts to interact with ERC-3156 compliant flash loan providers on the Ethereum blockchain.",
          "content": "import {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashLender.sol\";",
          "tokens": {
            "summary": 317,
            "content": 27
          }
        },
        "Stolen NFT Oracle": {
          "title": "Stolen NFT Oracle",
          "summary": "The given code snippet is a Solidity function named `setUseStolenNftOracle` that is used to set the flag for using a stolen NFT oracle in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newUseStolenNftOracle`, which is a boolean value representing the new state of the flag for using the stolen NFT oracle. The function sets the value of the `useStolenNftOracle` variable to the value of the input parameter.\n\nAfter updating the flag, the function emits an event called `SetUseStolenNftOracle` with the new value of the flag as its argument. This event can be used by external systems or applications to track changes in the state of the flag.\n\nIn summary, this function allows the owner of the pool to enable or disable the use of a stolen NFT oracle, which is responsible for checking if an NFT is stolen, by updating the flag and emitting an event to notify external systems of the change.",
          "content": "/// @notice Sets the whether or not to use the stolen NFT oracle. Can only be called by the owner of the pool. The\n    /// stolen NFT oracle is used to check if an NFT is stolen.\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    function setUseStolenNftOracle(bool newUseStolenNftOracle) public onlyOwner {\n        // set the use stolen NFT oracle flag\n        useStolenNftOracle = newUseStolenNftOracle;\n\n        // emit the set use stolen NFT oracle event\n        emit SetUseStolenNftOracle(newUseStolenNftOracle);\n    }",
          "tokens": {
            "summary": 225,
            "content": 146
          }
        },
        "Private Pool NFT": {
          "title": "Private Pool NFT",
          "summary": "The PrivatePool contract is an NFT Automated Market Maker (AMM) controlled by a single owner, featuring concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. Users can create a pool and modify its parameters according to their preferences. Depositing NFTs and base tokens (or ETH) into the pool enables trading and allows users to earn fees on each trade.\n\nThe contract uses the SafeTransferLib library for secure transfers and includes a MerkleMultiProof struct for inputting Merkle proofs. Several events are emitted for different actions, such as initializing the pool, buying and selling NFTs, depositing and withdrawing tokens, changing parameters, and setting various options.\n\nThe contract stores information about the base ERC20 token, the NFT address, change/flash fees, buy/sell fee rates, initialization status, royalty payment status, stolen NFT oracle usage, virtual base token reserves, virtual NFT reserves, and the Merkle root of all token weights in the pool. The stolen NFT oracle is an immutable address.\n\nErrors are defined for various situations, such as unauthorized access, invalid inputs, insufficient input weight, high fee rates, flash loan unavailability, flash loan failure, and invalid royalty fees.",
          "content": "/// @title Private Pool\n/// @author out.eth (@outdoteth)\n/// @notice A private pool is a an NFT AMM controlled by a single owner with concentrated liquidity, custom fee rates,\n/// stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. You can create a pool and change\n/// these parameters to your liking. Deposit NFTs and base tokens (or ETH) into the pool to enable trading. Earn fees on\n/// each trade.\ncontract PrivatePool is ERC721TokenReceiver {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    /// @notice Merkle proof input for a sparse merkle multi proof. It can be generated with a library like:\n    /// https://github.com/OpenZeppelin/merkle-tree#treegetmultiproof\n    struct MerkleMultiProof {\n        bytes32[] proof;\n        bool[] flags;\n    }\n\n    // forgefmt: disable-start\n    event Initialize(address indexed baseToken, address indexed nft, uint128 virtualBaseTokenReserves, uint128 virtualNftReserves, uint56 changeFee, uint16 feeRate, bytes32 merkleRoot, bool useStolenNftOracle, bool payRoyalties);\n    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Sell(uint256[] tokenIds, uint256[] tokenWeights, uint256 outputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Deposit(uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed nft, uint256[] tokenIds, address token, uint256 amount);\n    event Change(uint256[] inputTokenIds, uint256[] inputTokenWeights, uint256[] outputTokenIds, uint256[] outputTokenWeights, uint256 feeAmount, uint256 protocolFeeAmount);\n    event SetVirtualReserves(uint128 virtualBaseTokenReserves, uint128 virtualNftReserves);\n    event SetMerkleRoot(bytes32 merkleRoot);\n    event SetFeeRate(uint16 feeRate);\n    event SetUseStolenNftOracle(bool useStolenNftOracle);\n    event SetPayRoyalties(bool payRoyalties);\n    // forgefmt: disable-end\n\n    error AlreadyInitialized();\n    error Unauthorized();\n    error InvalidEthAmount();\n    error InvalidMerkleProof();\n    error InsufficientInputWeight();\n    error FeeRateTooHigh();\n    error NotAvailableForFlashLoan();\n    error FlashLoanFailed();\n    error InvalidRoyaltyFee();\n\n    /// @notice The address of the base ERC20 token.\n    address public baseToken;\n\n    /// @notice The address of the nft.\n    address public nft;\n\n    /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n    uint56 public changeFee;\n\n    /// @notice The buy/sell fee rate (in basis points) 200 = 2%\n    uint16 public feeRate;\n\n    /// @notice Whether or not the pool has been initialized.\n    bool public initialized;\n\n    /// @notice Whether or not the pool pays royalties to the NFT creator on each trade.\n    bool public payRoyalties;\n\n    /// @notice Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen.\n    bool public useStolenNftOracle;\n\n    /// @notice The virtual base token reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    uint128 public virtualBaseTokenReserves;\n\n    /// @notice The virtual nft reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    /// @dev The virtual NFT reserves that a user sets. If it's desired to set the reserves to match 16 NFTs then the\n    /// virtual reserves should be set to 16e18. If weights are enabled by setting the merkle root to be non-zero then\n    /// the virtual reserves should be set to the sum of the weights of the NFTs; where floor NFTs all have a weight of\n    /// 1e18. A rarer NFT may have a weight of 2.3e18 if it's 2.3x more valuable than a floor.\n    uint128 public virtualNftReserves;\n\n    /// @notice The merkle root of all the token weights in the pool. If the merkle root is set to bytes32(0) then all\n    /// NFTs are set to have a weight of 1e18.\n    bytes32 public merkleRoot;\n\n    /// @notice The NFT oracle to check if an NFT is stolen.\n    address public immutable stolenNftOracle;",
          "tokens": {
            "summary": 259,
            "content": 1046
          }
        },
        "Factory Contract Creator": {
          "title": "Factory Contract Creator",
          "summary": "The given content is a snippet of a Solidity smart contract code that defines a factory contract, a royalty registry, and a modifier for access control.\n\n1. `address payable public immutable factory;` - This line declares a public, immutable, and payable variable named `factory` of type `address`. This variable represents the factory contract that created the current pool. Being immutable, its value is set during the contract's deployment and cannot be changed afterward.\n\n2. `address public immutable royaltyRegistry;` - This line declares a public and immutable variable named `royaltyRegistry` of type `address`. This variable represents the royalty registry from manifold.xyz, a platform for managing royalties and licensing for digital assets. Similar to the `factory` variable, its value is set during the contract's deployment and cannot be changed afterward.\n\n3. The `modifier onlyOwner() virtual` block defines a modifier named `onlyOwner` that can be used to restrict access to certain functions within the contract. This modifier checks if the sender of the transaction (`msg.sender`) is the owner of the contract by comparing it with the owner returned by the `Factory(factory).ownerOf(uint160(address(this)))` function call. If the sender is not the owner, the modifier will revert the transaction with an \"Unauthorized\" error message. The `virtual` keyword indicates that this modifier can be overridden in derived contracts.\n\n4. `receive() external payable {}` - This line defines a fallback function that allows the contract to receive Ether payments. The `external` keyword specifies that this function can only be called from outside the contract, and the `payable` keyword allows the function to accept Ether. The empty function body `{}` indicates that no additional logic is executed when Ether is received.",
          "content": "/// @notice The factory contract that created this pool.\n    address payable public immutable factory;\n\n    /// @notice The royalty registry from manifold.xyz.\n    address public immutable royaltyRegistry;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != Factory(factory).ownerOf(uint160(address(this)))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    receive() external payable {}",
          "tokens": {
            "summary": 354,
            "content": 77
          }
        },
        "Immutable Parameters Constructor": {
          "title": "Immutable Parameters Constructor",
          "summary": "The given code snippet is a constructor function for a smart contract in the Solidity programming language. This constructor is called only when the base implementation contract is deployed. It sets three immutable parameters: factory, royaltyRegistry, and stolenNftOracle. These parameters represent the addresses of the factory contract, the royalty registry from manifold.xyz, and the stolen NFT oracle, respectively.\n\nThe constructor takes three input arguments: _factory, _royaltyRegistry, and _stolenNftOracle, which are the addresses for the respective contracts. Inside the constructor, the factory address is converted to a payable address and assigned to the factory variable. The royaltyRegistry and stolenNftOracle variables are assigned the respective input addresses without any conversion.\n\nStoring these parameters in immutable storage allows all minimal proxy contracts to read them without incurring additional deployment costs and re-initializing them at the point of creation in the factory contract. This approach optimizes the contract's gas usage and ensures that these parameters remain constant throughout the contract's lifecycle.",
          "content": "/// @dev This is only called when the base implementation contract is deployed. The following immutable parameters\n    /// are set:\n    /// - factory: The address of the factory contract\n    /// - royaltyRegistry: The address of the royalty registry from manifold.xyz\n    /// - stolenNftOracle: The address of the stolen NFT oracle\n    /// These are all stored in immutable storage, which enables all minimal proxy contracts to read them without\n    /// incurring additional deployment costs and re-initializing them at point of creation in the factory contract.\n    constructor(address _factory, address _royaltyRegistry, address _stolenNftOracle) {\n        factory = payable(_factory);\n        royaltyRegistry = _royaltyRegistry;\n        stolenNftOracle = _stolenNftOracle;\n    }",
          "tokens": {
            "summary": 204,
            "content": 164
          }
        },
        "Private Pool Initialization": {
          "title": "Private Pool Initialization",
          "summary": "The given code snippet is a function named `initialize` that initializes a private pool and sets its initial parameters. This function should only be called once by the factory. The function takes the following input parameters:\n\n1. `_baseToken`: The address of the base token.\n2. `_nft`: The address of the NFT (Non-Fungible Token).\n3. `_virtualBaseTokenReserves`: The virtual base token reserves.\n4. `_virtualNftReserves`: The virtual NFT reserves.\n5. `_changeFee`: The change fee.\n6. `_feeRate`: The fee rate (in basis points), where 200 equals 2%.\n7. `_merkleRoot`: The Merkle root.\n8. `_useStolenNftOracle`: A boolean value indicating whether the pool uses the stolen NFT oracle to check if an NFT is stolen.\n9. `_payRoyalties`: A boolean value indicating whether to pay royalties.\n\nThe function first checks if the pool has already been initialized, and if so, it reverts with an `AlreadyInitialized` error. It then checks if the fee rate is less than 50%, and if not, it reverts with a `FeeRateTooHigh` error.\n\nNext, the function sets the state variables with the input parameters. It marks the pool as initialized and emits an `Initialize` event with the input parameters.\n\nIn summary, the `initialize` function is responsible for setting up a private pool with the specified parameters, ensuring that it is only initialized once and that the fee rate is within acceptable limits.",
          "content": "/// @notice Initializes the private pool and sets the initial parameters. Should only be called once by the factory.\n    /// @param _baseToken The address of the base token\n    /// @param _nft The address of the NFT\n    /// @param _virtualBaseTokenReserves The virtual base token reserves\n    /// @param _virtualNftReserves The virtual NFT reserves\n    /// @param _feeRate The fee rate (in basis points) 200 = 2%\n    /// @param _merkleRoot The merkle root\n    /// @param _useStolenNftOracle Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen\n    function initialize(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties\n    ) public {\n        // prevent duplicate initialization\n        if (initialized) revert AlreadyInitialized();\n\n        // check that the fee rate is less than 50%\n        if (_feeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the state variables\n        baseToken = _baseToken;\n        nft = _nft;\n        virtualBaseTokenReserves = _virtualBaseTokenReserves;\n        virtualNftReserves = _virtualNftReserves;\n        changeFee = _changeFee;\n        feeRate = _feeRate;\n        merkleRoot = _merkleRoot;\n        useStolenNftOracle = _useStolenNftOracle;\n        payRoyalties = _payRoyalties;\n\n        // mark the pool as initialized\n        initialized = true;\n\n        // emit the event\n        emit Initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n    }",
          "tokens": {
            "summary": 321,
            "content": 458
          }
        },
        "NFT Pool Purchase": {
          "title": "NFT Pool Purchase",
          "summary": "The given content describes a function called `buy` that allows users to purchase Non-Fungible Tokens (NFTs) from a pool using base tokens. The function takes three parameters: `tokenIds`, `tokenWeights`, and `proof`. The `tokenIds` parameter represents the IDs of the NFTs to be purchased, while `tokenWeights` represents the weights of the NFTs. The `proof` parameter is a Merkle proof for the weights of each NFT to be purchased.\n\nThe function returns three values: `netInputAmount`, `feeAmount`, and `protocolFeeAmount`. The `netInputAmount` is the total amount of base tokens spent, including fees. The `feeAmount` is the amount of base tokens spent on fees, and the `protocolFeeAmount` is the amount of base tokens spent on protocol fees.\n\nThe function first calculates the sum of weights of the NFTs to be purchased and validates the Merkle proof. It then calculates the required net input amount and fee amount based on the sum of weights. If the base token is not Ethereum (ETH), the function checks that the caller sent 0 ETH.\n\nNext, the function updates the virtual reserves by adding the net input amount minus the fee amount and protocol fee amount to the virtual base token reserves and subtracting the sum of weights from the virtual NFT reserves.\n\nThe function then calculates the sale price for each NFT, assuming it's the same for each NFT even if weights differ. It transfers the NFTs to the caller and, if royalties are to be paid, calculates the royalty fee for each NFT and adds it to the total royalty fee amount. Finally, the function adds the royalty fee amount to the net input amount.\n\nIf the base token is not ETH, the function transfers the base tokens from the caller to the contract, and if royalties are to be paid, it transfers the royalty fees to the respective recipients. The function also transfers the protocol fee amount to the protocol fee recipient.",
          "content": "/// @notice Buys NFTs from the pool, paying with base tokens from the caller. Then transfers the bought NFTs to the\n    /// caller. The net cost depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the max input amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to buy.\n    /// @param tokenWeights The weights of the NFTs to buy.\n    /// @param proof The merkle proof for the weights of each NFT to buy.\n    /// @return netInputAmount The amount of base tokens spent inclusive of fees.\n    /// @return feeAmount The amount of base tokens spent on fees.\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to buy\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the required net input amount and fee amount\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n        // check that the caller sent 0 ETH if the base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n        virtualNftReserves -= uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer the NFT to the caller\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            if (payRoyalties) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n                // add the royalty fee to the total royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n            }\n        }\n\n        // add the royalty fee amount to the net input aount\n        netInputAmount += royaltyFeeAmount;\n\n        if (baseToken != address(0)) {",
          "tokens": {
            "summary": 409,
            "content": 603
          }
        },
        "Token Transfer Protocol": {
          "title": "Token Transfer Protocol",
          "summary": "The given code snippet is a part of a smart contract that deals with the transfer of tokens and payment of fees in a decentralized marketplace. The contract is written in Solidity and uses the ERC20 standard for token transfers.\n\n1. The first line transfers the base token (ERC20) from the caller (msg.sender) to the contract's address. The amount transferred is the net input amount, which is calculated elsewhere in the contract.\n\n2. If the protocol fee is set (greater than 0), the contract transfers the protocol fee amount from the base token to the factory address.\n\n3. If the base token is not set (i.e., it is an ETH transaction), the contract checks if the caller has sent enough ETH to cover the net required input. If not, it reverts the transaction with an \"InvalidEthAmount\" error.\n\n4. If the protocol fee is set for an ETH transaction, the contract transfers the protocol fee amount in ETH to the factory address.\n\n5. If the caller has sent excess ETH, the contract refunds the excess amount back to the caller.\n\n6. If the \"payRoyalties\" flag is set, the contract iterates through the tokenIds array and calculates the royalty fee for each NFT. If the royalty fee is greater than 0 and the recipient address is valid, the contract transfers the royalty fee to the recipient. This is done either in the base token (if set) or in ETH.\n\n7. Finally, the contract emits a \"Buy\" event with the relevant information, including tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, and royaltyFeeAmount. This event can be used by external applications to track and monitor the transactions happening in the marketplace.",
          "content": "// transfer the base token from the caller to the contract\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the net required input\n            if (msg.value < netInputAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n        }\n\n        if (payRoyalties) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // emit the buy event\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }",
          "tokens": {
            "summary": 351,
            "content": 344
          }
        },
        "NFT Pool Sale": {
          "title": "NFT Pool Sale",
          "summary": "The `sell` function is designed to sell Non-Fungible Tokens (NFTs) into a pool and transfer base tokens to the caller. The NFTs are transferred from the caller to the pool, and the net sale amount depends on the current price, fee rate, and assigned NFT weights. Developers are advised not to call this function directly unless they are aware of the consequences. Instead, they should use a wrapper contract that checks the minimum output amount and reverts if the slippage is too high.\n\nThe function takes the following parameters:\n- `tokenIds`: The token IDs of the NFTs to sell.\n- `tokenWeights`: The weights of the NFTs to sell.\n- `proof`: The Merkle proof for the weights of each NFT to sell.\n- `stolenNftProofs`: The proofs that show each NFT is not stolen.\n\nThe function returns the following values:\n- `netOutputAmount`: The amount of base tokens received inclusive of fees.\n- `feeAmount`: The amount of base tokens to pay in fees.\n\nThe function first calculates the sum of weights of the NFTs to sell and validates the Merkle proof. It then calculates the net output amount and fee amount. If the `useStolenNftOracle` flag is set, the function checks that the NFTs are not stolen using the `IStolenNftOracle` interface.\n\nNext, the function updates the virtual reserves by subtracting the net output amount, protocol fee amount, and fee amount from the virtual base token reserves and adding the weight sum to the virtual NFT reserves.\n\nThe function then transfers each NFT from the caller to the contract address. If the `payRoyalties` flag is set, the function calculates the sale price for each NFT, gets the royalty fee and recipient, and transfers the royalty fee to the recipient if it is greater than 0. The royalty fee amount is then subtracted from the net output amount.\n\nFinally, the function transfers the base tokens (or ETH) to the caller and pays the protocol fee if it is set. The function emits a `Sell` event with the token IDs, token weights, net output amount, fee amount, protocol fee amount, and royalty fee amount.",
          "content": "/// @notice Sells NFTs into the pool and transfers base tokens to the caller. NFTs are transferred from the caller\n    /// to the pool. The net sale amount depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the min output amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to sell.\n    /// @param tokenWeights The weights of the NFTs to sell.\n    /// @param proof The merkle proof for the weights of each NFT to sell.\n    /// @param stolenNftProofs The proofs that show each NFT is not stolen.\n    /// @return netOutputAmount The amount of base tokens received inclusive of fees.\n    /// @return feeAmount The amount of base tokens to pay in fees.\n    function sell(\n        uint256[] calldata tokenIds,\n        uint256[] calldata tokenWeights,\n        MerkleMultiProof calldata proof,\n        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error\n    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to sell\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the net output amount and fee amount\n        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n        //  check the nfts are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n        }\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n        virtualNftReserves += uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer each nft from the caller\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n            if (payRoyalties) {\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // tally the royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // subtract the royalty fee amount from the net output amount\n        netOutputAmount -= royaltyFeeAmount;\n\n        if (baseToken == address(0)) {\n            // transfer ETH to the caller\n            msg.sender.safeTransferETH(netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n        } else {\n            // transfer base tokens to the caller\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        }\n\n        // emit the sell event\n        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }",
          "tokens": {
            "summary": 462,
            "content": 888
          }
        },
        "NFT Pool Change": {
          "title": "NFT Pool Change",
          "summary": "The `change` function allows a user to swap a set of NFTs they own for another set of NFTs in the pool. The user must first approve the pool to transfer their NFTs. The sum of the user's NFT weights must be less than or equal to the sum of the output pool NFTs weights. Additionally, the user must pay a fee based on the net input weight and change fee amount.\n\nThe function takes the following parameters:\n\n- `inputTokenIds`: The token IDs of the NFTs to be swapped.\n- `inputTokenWeights`: The weights of the NFTs to be swapped.\n- `inputProof`: The Merkle proof for the weights of each NFT to be swapped.\n- `stolenNftProofs`: The proofs that show each input NFT is not stolen.\n- `outputTokenIds`: The token IDs of the NFTs to be received.\n- `outputTokenWeights`: The weights of the NFTs to be received.\n- `outputProof`: The Merkle proof for the weights of each NFT to be received.\n\nThe function performs several checks:\n\n1. If the base token is not ETH, it ensures that the caller sent 0 ETH.\n2. If the `useStolenNftOracle` flag is set, it checks that the NFTs are not stolen using the `IStolenNftOracle` interface.\n3. It calculates the sum of weights for the input and output NFTs and validates the Merkle proofs.\n4. It ensures that the input weights are greater than or equal to the output weights.\n5. It calculates the fee amount and protocol fee amount based on the input weight sum.\n\nThe function then performs several interactions:\n\n1. If the base token is not ETH, it transfers the fee amount of base tokens from the caller to the pool and the protocol fee amount to the factory.\n2. If the base token is ETH, it checks that the caller sent enough ETH to cover the fee amount and protocol fee amount, transfers the protocol fee to the factory, and refunds any excess ETH to the caller.\n3. It transfers the input NFTs from the caller to the pool.\n4. It transfers the output NFTs from the pool to the caller.\n\nFinally, the function emits a `Change` event with the input and output token IDs, weights, fee amount, and protocol fee amount.",
          "content": "/// @notice Changes a set of NFTs that the caller owns for another set of NFTs in the pool. The caller must approve\n    /// the pool to transfer the NFTs. The sum of the caller's NFT weights must be less than or equal to the sum of the\n    /// output pool NFTs weights. The caller must also pay a fee depending the net input weight and change fee amount.\n    /// @param inputTokenIds The token IDs of the NFTs to change.\n    /// @param inputTokenWeights The weights of the NFTs to change.\n    /// @param inputProof The merkle proof for the weights of each NFT to change.\n    /// @param stolenNftProofs The proofs that show each input NFT is not stolen.\n    /// @param outputTokenIds The token IDs of the NFTs to receive.\n    /// @param outputTokenWeights The weights of the NFTs to receive.\n    /// @param outputProof The merkle proof for the weights of each NFT to receive.\n    function change(\n        uint256[] memory inputTokenIds,\n        uint256[] memory inputTokenWeights,\n        MerkleMultiProof memory inputProof,\n        IStolenNftOracle.Message[] memory stolenNftProofs,\n        uint256[] memory outputTokenIds,\n        uint256[] memory outputTokenWeights,\n        MerkleMultiProof memory outputProof\n    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // check that the caller sent 0 ETH if base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // check that NFTs are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);\n        }\n\n        // fix stack too deep\n        {\n            // calculate the sum of weights for the input nfts\n            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);\n\n            // calculate the sum of weights for the output nfts\n            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);\n\n            // check that the input weights are greater than or equal to the output weights\n            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();\n\n            // calculate the fee amount\n            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        if (baseToken != address(0)) {\n            // transfer the fee amount of base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the fee amount and protocol fee\n            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > feeAmount + protocolFeeAmount) {\n                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);\n            }\n        }\n\n        // transfer the input nfts from the caller\n        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n        }\n\n        // transfer the output nfts to the caller\n        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n        }\n\n        // emit the change event\n        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);\n    }",
          "tokens": {
            "summary": 494,
            "content": 912
          }
        },
        "Execute Target Contract": {
          "title": "Execute Target Contract",
          "summary": "The given code snippet is a Solidity function named `execute`, which is designed to execute a transaction from a pool account to a target contract. This function can only be called by the owner of the pool, enabling use cases such as claiming airdrops.\n\nThe function takes two input parameters:\n\n1. `address target`: The address of the target contract to which the transaction will be executed.\n2. `bytes memory data`: The data to be sent to the target contract as part of the transaction.\n\nThe function returns `bytes memory returnData`, which is the return data of the executed transaction.\n\nInside the function, a call is made to the target contract with the specified value and data using the `call` function. The result of the call is stored in two variables: `bool success` and `bytes memory returnData`. If the call is successful, the function returns the `returnData`.\n\nIf the call is not successful and there is an error, the function checks if the `returnData` has a length greater than 0. If so, it uses inline assembly to revert the transaction and bubble up the error message. If the `returnData` length is 0, the function simply reverts the transaction without any error message.",
          "content": "/// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\n    /// pool. This allows for use cases such as claiming airdrops.\n    /// @param target The address of the target contract.\n    /// @param data The data to send to the target contract.\n    /// @return returnData The return data of the transaction.\n    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n        // call the target with the value and data\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n        // if the call succeeded return the return data\n        if (success) return returnData;\n\n        // if we got an error bubble up the error message\n        if (returnData.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert();\n        }\n    }",
          "tokens": {
            "summary": 251,
            "content": 227
          }
        },
        "Deposit Tokens NFTs": {
          "title": "Deposit Tokens NFTs",
          "summary": "The given code snippet is a function named `deposit` that allows users to deposit base tokens and NFTs (Non-Fungible Tokens) into a pool. The function takes two parameters: an array of token IDs (`tokenIds`) representing the NFTs to be deposited, and a `baseTokenAmount` representing the amount of base tokens to be deposited.\n\nBefore executing the deposit, the function checks if the base token is ETH (Ethereum) and if the sent ETH amount (`msg.value`) is equal to the specified `baseTokenAmount`. If the base token is not ETH, it checks if the sent ETH amount is 0. If these conditions are not met, the function reverts with an `InvalidEthAmount` error.\n\nThe function then proceeds to transfer the NFTs from the caller to the pool by iterating through the `tokenIds` array and using the `safeTransferFrom` function of the ERC721 standard. If the base token is not ETH, it transfers the base tokens from the caller to the pool using the `safeTransferFrom` function of the ERC20 standard.\n\nFinally, the function emits a `Deposit` event with the deposited `tokenIds` and `baseTokenAmount`.\n\nIt is important to note that the function is marked with a `@dev` comment, warning developers not to call this function directly unless they know what they are doing. Instead, they should use a wrapper contract that checks if the current price is within the desired bounds.",
          "content": "/// @notice Deposits base tokens and NFTs into the pool. The caller must approve the pool to transfer their NFTs and\n    /// base tokens.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the current price is within the desired bounds.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param baseTokenAmount The amount of base tokens to deposit.\n    function deposit(uint256[] calldata tokenIds, uint256 baseTokenAmount) public payable {\n        // ~~~ Checks ~~~ //\n\n        // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\n        // is not ETH\n        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\n            revert InvalidEthAmount();\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts from the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        if (baseToken != address(0)) {\n            // transfer the base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        // emit the deposit event\n        emit Deposit(tokenIds, baseTokenAmount);\n    }",
          "tokens": {
            "summary": 302,
            "content": 329
          }
        },
        "Withdraw NFT Tokens": {
          "title": "Withdraw NFT Tokens",
          "summary": "The given code snippet is a function named \"withdraw\" that allows the owner of a pool to withdraw Non-Fungible Tokens (NFTs) and tokens from the pool. The function takes four input parameters: the address of the NFT (_nft), an array of token IDs (tokenIds) representing the NFTs to be withdrawn, the address of the token (token) to be withdrawn, and the amount of tokens (tokenAmount) to be withdrawn.\n\nThe function is marked as \"public\" and can only be called by the owner of the pool, as indicated by the \"onlyOwner\" modifier.\n\nThe function starts by transferring the specified NFTs to the caller (msg.sender) using a for loop that iterates through the tokenIds array. It does this by calling the \"safeTransferFrom\" function of the ERC721 contract, passing the NFT address, the caller's address, and the current token ID in the loop.\n\nNext, the function checks if the token address is equal to the zero address (address(0)). If it is, the function transfers the specified amount of Ether (ETH) to the caller using the \"safeTransferETH\" function. If the token address is not the zero address, the function transfers the specified amount of tokens to the caller using the \"transfer\" function of the ERC20 contract.\n\nFinally, the function emits a \"Withdraw\" event with the NFT address, token IDs array, token address, and token amount as its parameters. This event can be used by external applications to track and monitor the withdrawal of NFTs and tokens from the pool.",
          "content": "/// @notice Withdraws NFTs and tokens from the pool. Can only be called by the owner of the pool.\n    /// @param _nft The address of the NFT.\n    /// @param tokenIds The token IDs of the NFTs to withdraw.\n    /// @param token The address of the token to withdraw.\n    /// @param tokenAmount The amount of tokens to withdraw.\n    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts to the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        if (token == address(0)) {\n            // transfer the ETH to the caller\n            msg.sender.safeTransferETH(tokenAmount);\n        } else {\n            // transfer the tokens to the caller\n            ERC20(token).transfer(msg.sender, tokenAmount);\n        }\n\n        // emit the withdraw event\n        emit Withdraw(_nft, tokenIds, token, tokenAmount);\n    }",
          "tokens": {
            "summary": 328,
            "content": 249
          }
        },
        "Set Virtual Reserves": {
          "title": "Set Virtual Reserves",
          "summary": "The given code snippet is a function called `setVirtualReserves` that sets the virtual base token reserves and virtual NFT (Non-Fungible Token) reserves for a pool. This function can only be called by the owner of the pool. The parameters of this function are `newVirtualBaseTokenReserves` and `newVirtualNftReserves`, which represent the new virtual base token reserves and virtual NFT reserves, respectively. These parameters affect the price and liquidity depth of the pool.\n\nThe function is defined with the `public` visibility specifier, meaning it can be called from any external contract or account. The `onlyOwner` modifier is used to restrict access to this function, ensuring that only the owner of the pool can call it.\n\nInside the function, the virtual base token reserves and virtual NFT reserves are updated with the new values provided as arguments. The new values are assigned to the `virtualBaseTokenReserves` and `virtualNftReserves` variables, respectively.\n\nAfter updating the reserves, the function emits an event called `SetVirtualReserves` with the new virtual base token reserves and virtual NFT reserves as its arguments. This event allows external entities, such as front-end applications or other smart contracts, to listen for changes in the virtual reserves and react accordingly.",
          "content": "/// @notice Sets the virtual base token reserves and virtual NFT reserves. Can only be called by the owner of the\n    /// pool. These parameters affect the price and liquidity depth of the pool.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    function setVirtualReserves(uint128 newVirtualBaseTokenReserves, uint128 newVirtualNftReserves) public onlyOwner {\n        // set the virtual base token reserves and virtual nft reserves\n        virtualBaseTokenReserves = newVirtualBaseTokenReserves;\n        virtualNftReserves = newVirtualNftReserves;\n\n        // emit the set virtual reserves event\n        emit SetVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n    }",
          "tokens": {
            "summary": 263,
            "content": 176
          }
        },
        "Set Merkle Root": {
          "title": "Set Merkle Root",
          "summary": "The given code snippet is a Solidity function named `setMerkleRoot` that sets the Merkle root for a specific use case, which is to validate the weights of Non-Fungible Tokens (NFTs). The function takes a single input parameter, `newMerkleRoot`, which is a 32-byte hash representing the new Merkle root.\n\nThe function is marked as `public`, meaning it can be called by any external entity, and it has a function modifier `onlyOwner`, which restricts its execution to only the owner of the pool. This ensures that only the authorized owner can update the Merkle root.\n\nInside the function, the new Merkle root is assigned to the state variable `merkleRoot`. After updating the Merkle root, an event named `SetMerkleRoot` is emitted with the new Merkle root as its argument. This event allows external entities, such as front-end applications or other smart contracts, to listen for changes in the Merkle root and react accordingly.\n\nIn summary, the `setMerkleRoot` function is a public function that can only be called by the owner of the pool, and it updates the Merkle root used for validating NFT weights. The function takes a new Merkle root as input, assigns it to the state variable, and emits an event to notify external entities of the change.",
          "content": "/// @notice Sets the merkle root. Can only be called by the owner of the pool. The merkle root is used to validate\n    /// the NFT weights.\n    /// @param newMerkleRoot The new merkle root.\n    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        // set the merkle root\n        merkleRoot = newMerkleRoot;\n\n        // emit the set merkle root event\n        emit SetMerkleRoot(newMerkleRoot);\n    }",
          "tokens": {
            "summary": 280,
            "content": 114
          }
        },
        "Fee Rate Setter": {
          "title": "Fee Rate Setter",
          "summary": "The given code snippet is a function called `setFeeRate` that sets the fee rate for a pool. This function can only be called by the owner of the pool. The fee rate is used to calculate the fee amount when swapping or changing NFTs (Non-Fungible Tokens). The fee rate is expressed in basis points, where 1 basis point is equal to 1/100th of a percent. For instance, 10,000 basis points represent 100%, 200 basis points represent 2%, and 1 basis point represents 0.01%.\n\nThe function takes a single parameter, `newFeeRate`, which is the new fee rate in basis points. Inside the function, there is a check to ensure that the new fee rate is less than 50% (5,000 basis points). If the new fee rate is greater than 50%, the function reverts with a `FeeRateTooHigh` error.\n\nIf the new fee rate is valid, the function sets the fee rate to the new value and emits an event called `SetFeeRate` with the new fee rate as its parameter. This event can be used by external systems to track changes in the fee rate.",
          "content": "/// @notice Sets the fee rate. Can only be called by the owner of the pool. The fee rate is used to calculate the\n    /// fee amount when swapping or changing NFTs. The fee rate is in basis points (1/100th of a percent). For example,\n    /// 10_000 == 100%, 200 == 2%, 1 == 0.01%.\n    /// @param newFeeRate The new fee rate (in basis points)\n    function setFeeRate(uint16 newFeeRate) public onlyOwner {\n        // check that the fee rate is less than 50%\n        if (newFeeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the fee rate\n        feeRate = newFeeRate;\n\n        // emit the set fee rate event\n        emit SetFeeRate(newFeeRate);\n    }",
          "tokens": {
            "summary": 245,
            "content": 181
          }
        },
        "Set Pay Royalties": {
          "title": "Set Pay Royalties",
          "summary": "The given code snippet is a Solidity function named `setPayRoyalties` that is used to set the pay royalties flag in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newPayRoyalties`, which is a boolean value representing the new pay royalties flag. When royalties are enabled (i.e., `newPayRoyalties` is set to `true`), the pool will pay royalties when buying or selling NFTs (Non-Fungible Tokens).\n\nInside the function, the `payRoyalties` state variable is updated with the value of `newPayRoyalties`. After updating the state variable, an event named `SetPayRoyalties` is emitted with the new pay royalties flag as its argument. This event can be used by external entities to listen for changes in the pay royalties flag and take appropriate actions accordingly.\n\nIn summary, the `setPayRoyalties` function is a public function that allows the owner of the pool to enable or disable the payment of royalties when buying or selling NFTs in the pool. The function updates the `payRoyalties` state variable and emits an event to notify external entities of the change.",
          "content": "/// @notice Sets the pay royalties flag. Can only be called by the owner of the pool. If royalties are enabled then\n    /// the pool will pay royalties when buying or selling NFTs.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setPayRoyalties(bool newPayRoyalties) public onlyOwner {\n        // set the pay royalties flag\n        payRoyalties = newPayRoyalties;\n\n        // emit the set pay royalties event\n        emit SetPayRoyalties(newPayRoyalties);\n    }",
          "tokens": {
            "summary": 257,
            "content": 111
          }
        },
        "Set All Parameters": {
          "title": "Set All Parameters",
          "summary": "The given code snippet is a function called `setAllParameters` in a smart contract, which updates multiple parameter settings at once. The function takes six input parameters:\n\n1. `newVirtualBaseTokenReserves`: A uint128 value representing the new virtual base token reserves.\n2. `newVirtualNftReserves`: A uint128 value representing the new virtual NFT (Non-Fungible Token) reserves.\n3. `newMerkleRoot`: A bytes32 value representing the new Merkle root.\n4. `newFeeRate`: A uint16 value representing the new fee rate in basis points.\n5. `newUseStolenNftOracle`: A boolean value representing the new flag for using a stolen NFT oracle.\n6. `newPayRoyalties`: A boolean value representing the new flag for paying royalties.\n\nInside the function, the following methods are called to update the respective parameters:\n\n1. `setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves)`: Updates the virtual base token and NFT reserves with the new values provided.\n2. `setMerkleRoot(newMerkleRoot)`: Updates the Merkle root with the new value provided.\n3. `setFeeRate(newFeeRate)`: Updates the fee rate with the new value provided.\n4. `setUseStolenNftOracle(newUseStolenNftOracle)`: Updates the flag for using a stolen NFT oracle with the new value provided.\n5. `setPayRoyalties(newPayRoyalties)`: Updates the flag for paying royalties with the new value provided.\n\nThis function allows for efficient and simultaneous updating of multiple parameter settings in the smart contract.",
          "content": "/// @notice Updates all parameter settings in one go.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    /// @param newMerkleRoot The new merkle root.\n    /// @param newFeeRate The new fee rate (in basis points)\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setAllParameters(\n        uint128 newVirtualBaseTokenReserves,\n        uint128 newVirtualNftReserves,\n        bytes32 newMerkleRoot,\n        uint16 newFeeRate,\n        bool newUseStolenNftOracle,\n        bool newPayRoyalties\n    ) public {\n        setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n        setMerkleRoot(newMerkleRoot);\n        setFeeRate(newFeeRate);\n        setUseStolenNftOracle(newUseStolenNftOracle);\n        setPayRoyalties(newPayRoyalties);\n    }",
          "tokens": {
            "summary": 345,
            "content": 240
          }
        },
        "Flash Loan Execution": {
          "title": "Flash Loan Execution",
          "summary": "The given code snippet is a function called `flashLoan` that executes a flash loan in a smart contract. The function takes four parameters: `receiver`, `token`, `tokenId`, and `data`. The `receiver` is the address of the entity receiving the flash loan, `token` is the address of the Non-Fungible Token (NFT) contract, `tokenId` is the ID of the NFT, and `data` is any additional data to be passed to the receiver.\n\nThe function is marked as `external` and `payable`, meaning it can be called from outside the contract and can receive Ether (ETH) as payment. The function returns a boolean value indicating whether the flash loan was successful or not.\n\nFirst, the function checks if the NFT is available for a flash loan using the `availableForFlashLoan` function. If it's not available, the function reverts with a `NotAvailableForFlashLoan` error.\n\nNext, the function calculates the fee for the flash loan using the `flashFee` function. If the base token is ETH (i.e., `baseToken` is the zero address), the function checks if the caller sent enough ETH to cover the fee. If not, it reverts with an `InvalidEthAmount` error.\n\nThe function then transfers the NFT to the borrower using the `safeTransferFrom` function of the ERC721 contract. After that, it calls the `onFlashLoan` function of the borrower's contract, passing the necessary parameters, and checks if the flash loan was successful by comparing the returned value with the expected hash of the \"ERC3156FlashBorrower.onFlashLoan\" string.\n\nIf the flash loan was not successful, the function reverts with a `FlashLoanFailed` error. If it was successful, the function transfers the NFT back from the borrower to the contract using the `safeTransferFrom` function of the ERC721 contract.\n\nFinally, the function transfers the fee from the borrower to the contract. If the base token is not ETH (i.e., `baseToken` is not the zero address), it uses the `transferFrom` function of the ERC20 contract to transfer the fee. The function then returns the `success` boolean value, indicating the outcome of the flash loan.",
          "content": "/// @notice Executes a flash loan.\n    /// @param receiver The receiver of the flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @param data The data to pass to the receiver.\n    /// @return success Whether or not the flash loan was successful.\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }",
          "tokens": {
            "summary": 467,
            "content": 351
          }
        },
        "Sum Validate Proof": {
          "title": "Sum Validate Proof",
          "summary": "The given code snippet is a Solidity function called `sumWeightsAndValidateProof` that takes three input parameters: an array of token IDs (`tokenIds`), an array of corresponding token weights (`tokenWeights`), and a Merkle multi-proof object (`proof`). The function's purpose is to calculate the sum of the weights of each NFT (Non-Fungible Token) and validate that the weights are correct by verifying the provided Merkle proof.\n\nInitially, the function checks if the `merkleRoot` is not set (i.e., equal to `bytes32(0)`). If this is the case, it returns the product of the number of token IDs and 1e18, effectively setting the weight of each NFT to be 1e18.\n\nIf the `merkleRoot` is set, the function initializes a variable `sum` to store the sum of the token weights and creates a new array `leafs` to store the Merkle proof leaves. It then iterates through the `tokenIds` array, and for each token ID, it creates a leaf by hashing the concatenated result of the hashed encoding of the token ID and its corresponding weight. The function also adds the token weight to the `sum` variable.\n\nAfter iterating through all the token IDs, the function verifies the Merkle proof using the `MerkleProofLib.verifyMultiProof` function, which takes the proof, merkle root, leafs, and proof flags as input parameters. If the Merkle proof is not valid, the function reverts with an `InvalidMerkleProof` error.\n\nFinally, if the Merkle proof is valid, the function returns the sum of the token weights.",
          "content": "/// @notice Sums the weights of each NFT and validates that the weights are correct by verifying the merkle proof.\n    /// @param tokenIds The token IDs of the NFTs to sum the weights for.\n    /// @param tokenWeights The weights of each NFT in the token IDs array.\n    /// @param proof The merkle proof for the weights of each NFT.\n    /// @return sum The sum of the weights of each NFT.\n    function sumWeightsAndValidateProof(\n        uint256[] memory tokenIds,\n        uint256[] memory tokenWeights,\n        MerkleMultiProof memory proof\n    ) public view returns (uint256) {\n        // if the merkle root is not set then set the weight of each nft to be 1e18\n        if (merkleRoot == bytes32(0)) {\n            return tokenIds.length * 1e18;\n        }\n\n        uint256 sum;\n        bytes32[] memory leafs = new bytes32[](tokenIds.length);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // create the leaf for the merkle proof\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n\n            // sum each token weight\n            sum += tokenWeights[i];\n        }\n\n        // validate that the weights are valid against the merkle proof\n        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\n            revert InvalidMerkleProof();\n        }\n\n        return sum;\n    }",
          "tokens": {
            "summary": 346,
            "content": 339
          }
        },
        "NFT Buy Quote": {
          "title": "NFT Buy Quote",
          "summary": "The given code snippet is a function called `buyQuote` in a smart contract, which calculates the required input amount of base tokens needed to buy a specified amount of NFTs (Non-Fungible Tokens), along with the associated fee amounts.\n\nThe function takes a single input parameter, `outputAmount`, which represents the desired amount of NFTs to buy, multiplied by 1e18 for precision. It returns three values: `netInputAmount`, `feeAmount`, and `protocolFeeAmount`.\n\nThe function calculates the input amount using the xy=k invariant, a formula used in automated market makers (AMMs) to maintain a constant product of token reserves. The input amount is calculated by multiplying the `outputAmount` by the `virtualBaseTokenReserves` and dividing by the difference between `virtualNftReserves` and `outputAmount`. The result is rounded up by 1 wei for precision.\n\nNext, the function calculates the protocol fee amount by multiplying the input amount by the `protocolFeeRate` obtained from the Factory contract and dividing by 10,000. Similarly, the fee amount is calculated by multiplying the input amount by the `feeRate` and dividing by 10,000.\n\nFinally, the function calculates the net input amount by adding the input amount, fee amount, and protocol fee amount. The function then returns the net input amount, fee amount, and protocol fee amount as output.",
          "content": "/// @notice Returns the required input of buying a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param outputAmount The amount of NFTs to buy multiplied by 1e18.\n    /// @return netInputAmount The required input amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function buyQuote(uint256 outputAmount)\n        public\n        view\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the input amount based on xy=k invariant and round up by 1 wei\n        uint256 inputAmount =\n            FixedPointMathLib.mulDivUp(outputAmount, virtualBaseTokenReserves, (virtualNftReserves - outputAmount));\n\n        protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = inputAmount * feeRate / 10_000;\n        netInputAmount = inputAmount + feeAmount + protocolFeeAmount;\n    }",
          "tokens": {
            "summary": 288,
            "content": 225
          }
        },
        "NFT Sell Quote": {
          "title": "NFT Sell Quote",
          "summary": "The `sellQuote` function is a public view function that returns the output amount of selling a given amount of NFTs, inclusive of the fee, which depends on the currently set fee rate. It takes one input parameter, `inputAmount`, which represents the amount of NFTs to sell multiplied by 1e18. The function returns three values: `netOutputAmount`, `feeAmount`, and `protocolFeeAmount`.\n\nThe function first calculates the output amount based on the xy=k invariant, using the formula `outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount)`. This calculation determines the amount of base tokens that will be received when selling the specified amount of NFTs.\n\nNext, the function calculates the protocol fee amount by multiplying the output amount by the protocol fee rate obtained from the factory contract, and dividing the result by 10,000. The formula for this calculation is `protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000`.\n\nThe fee amount is then calculated by multiplying the output amount by the fee rate and dividing the result by 10,000. The formula for this calculation is `feeAmount = outputAmount * feeRate / 10_000`.\n\nFinally, the net output amount is calculated by subtracting the fee amount and the protocol fee amount from the output amount. The formula for this calculation is `netOutputAmount = outputAmount - feeAmount - protocolFeeAmount`.",
          "content": "/// @notice Returns the output amount of selling a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param inputAmount The amount of NFTs to sell multiplied by 1e18.\n    /// @return netOutputAmount The output amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function sellQuote(uint256 inputAmount)\n        public\n        view\n        returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the output amount based on xy=k invariant\n        uint256 outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount);\n\n        protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = outputAmount * feeRate / 10_000;\n        netOutputAmount = outputAmount - feeAmount - protocolFeeAmount;\n    }",
          "tokens": {
            "summary": 304,
            "content": 209
          }
        },
        "NFT Change Fee": {
          "title": "NFT Change Fee",
          "summary": "The `changeFeeQuote` function calculates the fee required to change a given amount of Non-Fungible Tokens (NFTs) based on the current `changeFee`. The function takes `inputAmount` as a parameter, which represents the amount of NFTs to change multiplied by 1e18. It returns two values: `feeAmount` and `protocolFeeAmount`.\n\nFirst, the function calculates the exponent based on the base token decimals. If the base token is zero, the exponent is set to 14 (18 - 4). Otherwise, the exponent is calculated as the difference between the base token's decimals and 4. This is done to maintain 4 decimals of precision in the fee calculation.\n\nNext, the function calculates the fee per NFT by multiplying the `changeFee` with 10 raised to the power of the exponent. This ensures that the fee per NFT has the same precision as the `changeFee`.\n\nThe `feeAmount` is then calculated by multiplying the `inputAmount` with the fee per NFT and dividing the result by 1e18. This scales the fee amount according to the input amount of NFTs.\n\nFinally, the `protocolFeeAmount` is calculated by multiplying the `feeAmount` with the protocol fee rate (obtained from the Factory contract) and dividing the result by 10,000. This calculates the portion of the fee that goes to the protocol.\n\nIn summary, the `changeFeeQuote` function calculates the fee and protocol fee amounts for changing a given amount of NFTs based on the current `changeFee` and the base token decimals.",
          "content": "/// @notice Returns the fee required to change a given amount of NFTs. The fee is based on the current changeFee\n    /// (which contains 4 decimals of precision) multiplied by some exponent depending on the base token decimals.\n    /// @param inputAmount The amount of NFTs to change multiplied by 1e18.\n    /// @return feeAmount The fee amount.\n    /// @return protocolFeeAmount The protocol fee amount.\n    function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n        uint256 feePerNft = changeFee * 10 ** exponent;\n\n        feeAmount = inputAmount * feePerNft / 1e18;\n        protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n    }",
          "tokens": {
            "summary": 332,
            "content": 224
          }
        },
        "Pool Price Function": {
          "title": "Pool Price Function",
          "summary": "The given code snippet is a Solidity function named `price()` that returns the price of a pool with 18 decimals of accuracy. The function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe function calculates the price by first determining the exponent to be used for scaling the result. This is done by checking if the `baseToken` address is equal to the zero address (i.e., the Ethereum native currency, Ether). If it is, the exponent is set to 18, otherwise, it is set to 36 minus the number of decimals of the `baseToken` as defined in its ERC20 contract.\n\nNext, the function calculates the price by multiplying the `virtualBaseTokenReserves` by 10 raised to the power of the previously calculated exponent. This result is then divided by the `virtualNftReserves` to obtain the final price.\n\nFinally, the function returns the calculated price as a `uint256` value.",
          "content": "/// @notice Returns the price of the pool to 18 decimals of accuracy.\n    /// @return price The price of the pool.\n    function price() public view returns (uint256) {\n        // ensure that the exponent is always to 18 decimals of accuracy\n        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals());\n        return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\n    }",
          "tokens": {
            "summary": 208,
            "content": 104
          }
        },
        "NFT Flash Fee": {
          "title": "NFT Flash Fee",
          "summary": "The given code snippet is a Solidity function named `flashFee` that is part of a smart contract. This function is responsible for returning the fee required to perform a flash swap of a specific Non-Fungible Token (NFT).\n\nThe function takes two input parameters:\n\n1. `address`: This is the Ethereum address associated with the NFT.\n2. `uint256`: This is an unsigned integer representing the unique identifier of the NFT.\n\nThe function is marked as `public`, which means it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract. The `view` keyword ensures that the function only reads data from the blockchain and does not make any changes.\n\nThe function returns a single output parameter:\n\n1. `uint256 feeAmount`: This is an unsigned integer representing the fee amount required to perform the flash swap of the given NFT.\n\nInside the function, the fee amount is obtained from a variable named `changeFee`. This variable is likely defined elsewhere in the smart contract and represents the current fee for flash swaps. The function simply returns the value of this variable as the fee amount.\n\nIn summary, the `flashFee` function provides a way for external entities to query the fee required to perform a flash swap of a specific NFT by providing the NFT's associated address and unique identifier. The function returns the fee amount as an unsigned integer.",
          "content": "/// @notice Returns the fee required to flash swap a given NFT.\n    /// @return feeAmount The fee amount.\n    function flashFee(address, uint256) public view returns (uint256) {\n        return changeFee;\n    }",
          "tokens": {
            "summary": 289,
            "content": 49
          }
        },
        "Flash Fee Token": {
          "title": "Flash Fee Token",
          "summary": "The given code snippet is a part of a smart contract written in Solidity language for the Ethereum blockchain. It defines a function called `flashFeeToken()` which is a public and view function, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe purpose of this function is to return the address of the token that is used to pay the flash fee. In this specific implementation, the function simply returns the value of a variable called `baseToken`. The `baseToken` variable is assumed to be defined elsewhere in the contract and holds the address of the token used for paying the flash fee.\n\nThe function signature specifies that it returns a value of type `address`, which is a 20-byte value representing the address of an Ethereum account or a smart contract. In this case, it represents the address of the token contract used for paying the flash fee.",
          "content": "/// @notice Returns the token that is used to pay the flash fee.\n    function flashFeeToken() public view returns (address) {\n        return baseToken;\n    }",
          "tokens": {
            "summary": 178,
            "content": 35
          }
        },
        "NFT Flash Loan": {
          "title": "NFT Flash Loan",
          "summary": "The given code snippet is a function definition in a smart contract, written in Solidity programming language. The function is named `availableForFlashLoan` and it is used to determine if a specific Non-Fungible Token (NFT) is available for a flash loan.\n\nThe function takes two input parameters:\n\n1. `address token`: This parameter represents the address of the NFT contract. It is of type `address`, which is a 160-bit identifier for a specific Ethereum account.\n\n2. `uint256 tokenId`: This parameter represents the unique identifier of the NFT within the contract. It is of type `uint256`, which is an unsigned 256-bit integer.\n\nThe function is marked as `public`, meaning it can be called from any external contract or account, and `view`, which indicates that it does not modify the state of the contract. This allows the function to be called without incurring any gas costs.\n\nThe function returns a single output:\n\n1. `bool available`: This is a boolean value that indicates whether the specified NFT is available for a flash loan or not.\n\nThe function works by querying the state of the NFT contract and checking if the given NFT (identified by its `tokenId`) is available for a flash loan. The result is then returned as a boolean value.",
          "content": "/// @notice Returns whether or not an NFT is available for a flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @return available Whether or not the NFT is available for a flash loan.\n    function availableForFlashLoan(address token, uint256 tokenId) public view returns (bool) {",
          "tokens": {
            "summary": 265,
            "content": 80
          }
        },
        "NFT Ownership Check": {
          "title": "NFT Ownership Check",
          "summary": "The given code snippet is a function that checks if a specific Non-Fungible Token (NFT) is owned by the current smart contract. It does this by interacting with the ERC721 standard, which is a widely used standard for creating and managing NFTs on the Ethereum blockchain.\n\nThe function first attempts to call the `ownerOf` function from the ERC721 smart contract, which is identified by the `token` address. The `ownerOf` function takes a `tokenId` as its argument, which is a unique identifier for the NFT within the ERC721 contract. The `ownerOf` function returns the address of the current owner of the NFT.\n\nThe function then checks if the returned owner address (`result`) is equal to the address of the current smart contract (`address(this)`). If the addresses match, it means that the NFT is owned by the current smart contract, and the function returns `true`. If the addresses do not match, the function returns `false`, indicating that the NFT is not owned by the current smart contract.\n\nAdditionally, the function is wrapped in a `try-catch` block. This is used to handle any errors that may occur while calling the `ownerOf` function from the ERC721 contract. If an error occurs, the catch block is executed, and the function returns `false`. This ensures that the function does not throw an error and instead provides a safe way to determine if the NFT is owned by the current smart contract.",
          "content": "// return if the NFT is owned by this contract\n        try ERC721(token).ownerOf(tokenId) returns (address result) {\n            return result == address(this);\n        } catch {\n            return false;\n        }\n    }",
          "tokens": {
            "summary": 302,
            "content": 48
          }
        },
        "Get Royalty Function": {
          "title": "Get Royalty Function",
          "summary": "The given content is a function definition in a smart contract, written in Solidity programming language, for a blockchain-based application. The function is named `_getRoyalty` and is used to calculate the royalty fee and the recipient address for a given Non-Fungible Token (NFT) and its sale price. The function fetches the royalty information from the Manifold registry.\n\nThe function takes two input parameters:\n\n1. `tokenId`: A `uint256` data type representing the unique identifier of the NFT.\n2. `salePrice`: A `uint256` data type representing the sale price of the NFT.\n\nThe function returns two output values:\n\n1. `royaltyFee`: A `uint256` data type representing the royalty fee to be paid.\n2. `recipient`: An `address` data type representing the address to which the royalty fee should be paid.\n\nThe function is marked as `internal`, which means it can only be called from within the same contract or contracts derived from it. It is also marked as `view`, which indicates that it does not modify the state of the contract and can be executed without incurring any gas costs.\n\nInside the function, the royalty lookup address is fetched by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the `nft` address as an argument. The `IRoyaltyRegistry` interface is a contract that defines the functions for interacting with the Manifold registry, which stores the royalty information for NFTs.",
          "content": "/// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function _getRoyalty(uint256 tokenId, uint256 salePrice)\n        internal\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);",
          "tokens": {
            "summary": 310,
            "content": 147
          }
        },
        "Royalty Fee Validation": {
          "title": "Royalty Fee Validation",
          "summary": "The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract supports the ERC-2981 interface, which is a standard for handling royalty payments in Non-Fungible Tokens (NFTs).\n\n1. First, the code checks if the contract at the `lookupAddress` supports the ERC-2981 interface by calling the `supportsInterface` function with the interface ID of ERC-2981. The interface ID is obtained using `type(IERC2981).interfaceId`. If the contract supports the interface, the code proceeds to the next step.\n\n2. The royalty information for a specific token (identified by `tokenId`) is retrieved by calling the `royaltyInfo` function of the ERC-2981 contract at the `lookupAddress`. The function returns two values: the recipient address (`recipient`) and the royalty fee (`royaltyFee`) as a percentage of the sale price (`salePrice`).\n\n3. The code then checks if the calculated royalty fee is greater than the sale price of the token. If it is, the transaction is reverted with an `InvalidRoyaltyFee` error message. This ensures that the royalty fee does not exceed the actual sale price of the token.\n\nIn summary, this code snippet is used to verify if a contract supports the ERC-2981 royalty standard, retrieve the royalty information for a specific NFT, and ensure that the royalty fee does not exceed the token's sale price.",
          "content": "if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}",
          "tokens": {
            "summary": 304,
            "content": 92
          }
        }
      }
    },
    "spearbot-node/put_files_to_audit_here/solidity/PrivatePoolMetadata.sol": {
      "filename": "spearbot-node/put_files_to_audit_here/solidity/PrivatePoolMetadata.sol",
      "globalSummary": "The PrivatePoolMetadata contract generates NFT metadata for private pools. It includes functions to return the tokenURI with its metadata, attributes encoded as JSON, and an SVG image for a pool. The contract imports and utilizes various libraries such as Strings, Base64, ERC20, and ERC721.",
      "chunkedSummaries": {
        "Private Pool Metadata": {
          "title": "Private Pool Metadata",
          "summary": "The Private Pool Metadata contract, authored by out.eth (@outdoteth), is designed to generate Non-Fungible Token (NFT) metadata for private pools. NFTs are unique digital assets that can represent various types of content, such as art, music, or virtual real estate. Metadata is the information that describes the attributes and characteristics of these NFTs.\n\nIn this contract, the primary purpose is to create and manage metadata for private pools, which are exclusive groups or communities within a blockchain ecosystem. These private pools may have specific requirements for membership, such as holding a certain amount of tokens or possessing a particular NFT.\n\nThe contract begins with the declaration of the `PrivatePoolMetadata` contract, which inherits from the base contract. The contract includes various functions and data structures to manage the metadata generation process.\n\nKey components of the contract include:\n\n1. Data Structures: The contract defines several data structures to store information about the private pools and their associated metadata. These structures include mappings to store the pool's metadata, as well as arrays to keep track of the pool's members and their respective NFTs.\n\n2. Constructor: The constructor function initializes the contract by setting the initial values for the contract's variables and data structures. This includes the contract's owner, the base URI for the metadata, and any other necessary parameters.\n\n3. Metadata Generation: The contract includes functions to generate metadata for the private pools. This process involves creating a unique identifier for each pool, as well as generating a JSON object that contains the pool's attributes and characteristics. The metadata is then stored in the contract's data structures and can be accessed by the pool's members.\n\n4. Access Control: The contract includes various access control mechanisms to ensure that only authorized users can interact with the contract's functions. This includes modifiers to restrict access to the contract's owner, as well as functions to add or remove members from the private pools.\n\n5. Utility Functions: The contract also includes several utility functions to help manage the metadata generation process. These functions include methods to retrieve the metadata for a specific pool, as well as functions to update the base URI for the metadata.\n\nIn summary, the Private Pool Metadata contract is a specialized contract designed to generate and manage NFT metadata for private pools within a blockchain ecosystem. The contract includes various data structures, functions, and access control mechanisms to ensure the secure and efficient generation of metadata for these exclusive communities.",
          "content": "/// @title Private Pool Metadata\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to generate NFT metadata for private pools.\ncontract PrivatePoolMetadata {",
          "tokens": {
            "summary": 487,
            "content": 38
          }
        },
        "Pool TokenURI Metadata": {
          "title": "Pool TokenURI Metadata",
          "summary": "The given code snippet is a Solidity function named `tokenURI` that takes a single input parameter, `tokenId`, of type `uint256`. The function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the contract's state. The function returns a `string` in memory.\n\nThe purpose of this function is to return the tokenURI for a private pool with its metadata. The metadata is constructed using the `abi.encodePacked` function, which concatenates the input arguments into a single bytes array. The metadata includes the following properties:\n\n1. \"name\": A string that concatenates \"Private Pool \" with the `tokenId` converted to a string using the `Strings.toString` function.\n2. \"description\": A static string \"Caviar private pool AMM position.\"\n3. \"image\": A data URI that represents an SVG image encoded in base64 format. The SVG image is generated by calling the `svg` function with the `tokenId` as its argument, and the result is encoded using the `Base64.encode` function.\n4. \"attributes\": An array of attributes obtained by calling the `attributes` function with the `tokenId` as its argument.\n\nFinally, the metadata bytes array is converted to a JSON string and encoded in base64 format using the `Base64.encode` function. The resulting string is concatenated with the \"data:application/json;base64,\" prefix to form the final tokenURI, which is returned by the function.",
          "content": "/// @notice Returns the tokenURI for a pool with it's metadata.\n    /// @param tokenId The private pool's token ID.\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // forgefmt: disable-next-item\n        bytes memory metadata = abi.encodePacked(\n            \"{\",\n                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',\n                '\"description\": \"Caviar private pool AMM position.\",',\n                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',\n                '\"attributes\": [',\n                    attributes(tokenId),\n                \"]\",\n            \"}\"\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }",
          "tokens": {
            "summary": 306,
            "content": 160
          }
        },
        "Pool Attributes Function": {
          "title": "Pool Attributes Function",
          "summary": "The given code snippet is a Solidity function named `attributes` that returns the attributes of a private pool encoded as a JSON string. The function takes a single input parameter, `tokenId`, which represents the private pool's token ID.\n\nFirst, the function creates a `PrivatePool` object named `privatePool` by casting the `tokenId` to an address and making it payable. Then, it initializes a bytes array named `_attributes` and encodes the attributes of the private pool using the `abi.encodePacked` function. The attributes include:\n\n1. Pool address: The address of the private pool.\n2. Base token: The address of the base token in the private pool.\n3. NFT: The address of the NFT in the private pool.\n4. Virtual base token reserves: The virtual reserves of the base token in the private pool.\n5. Virtual NFT reserves: The virtual reserves of the NFT in the private pool.\n6. Fee rate (bps): The fee rate of the private pool in basis points.\n7. NFT balance: The balance of the NFT in the private pool.\n8. Base token balance: The balance of the base token in the private pool.\n\nEach attribute is encoded using the `trait` function, which takes two parameters: the attribute name and its value. The attributes are separated by commas to form a JSON string.\n\nFinally, the function returns the `_attributes` bytes array as a string.",
          "content": "/// @notice Returns the attributes for a pool encoded as json.\n    /// @param tokenId The private pool's token ID.\n    function attributes(uint256 tokenId) public view returns (string memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // forgefmt: disable-next-item\n        bytes memory _attributes = abi.encodePacked(\n            trait(\"Pool address\", Strings.toHexString(address(privatePool))), ',',\n            trait(\"Base token\", Strings.toHexString(privatePool.baseToken())), ',',\n            trait(\"NFT\", Strings.toHexString(privatePool.nft())), ',',\n            trait(\"Virtual base token reserves\",Strings.toString(privatePool.virtualBaseTokenReserves())), ',',\n            trait(\"Virtual NFT reserves\", Strings.toString(privatePool.virtualNftReserves())), ',',\n            trait(\"Fee rate (bps): \", Strings.toString(privatePool.feeRate())), ',',\n            trait(\"NFT balance\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool)))), ',',\n            trait(\"Base token balance\",  Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))))\n        );\n\n        return string(_attributes);\n    }",
          "tokens": {
            "summary": 295,
            "content": 256
          }
        },
        "SVG Pool Image": {
          "title": "SVG Pool Image",
          "summary": "The given code snippet is a Solidity function named `svg` that takes a `tokenId` as input and returns an SVG image in bytes format. The function is designed to generate an SVG image containing information about a private pool in an Automated Market Maker (AMM) system called Caviar.\n\nThe function first creates a `PrivatePool` object using the provided `tokenId`. It then constructs the SVG image in three separate scopes to avoid stack too deep errors. The SVG image is built using the `abi.encodePacked` function, which concatenates the input arguments into a single bytes array.\n\nIn the first scope, the SVG image is initialized with a black background, white fill, and a serif font. It includes the following text elements:\n1. \"Caviar AMM private pool position\"\n2. \"Private pool: \" followed by the hexadecimal representation of the `privatePool` address\n3. \"Base token: \" followed by the hexadecimal representation of the `baseToken` address\n4. \"NFT: \" followed by the hexadecimal representation of the `nft` address\n\nIn the second scope, the SVG image is updated with the following text elements:\n1. \"Virtual base token reserves: \" followed by the string representation of the `virtualBaseTokenReserves` value\n2. \"Virtual NFT reserves: \" followed by the string representation of the `virtualNftReserves` value\n3. \"Fee rate (bps): \" followed by the string representation of the `feeRate` value\n\nIn the third scope, the SVG image is finalized with the following text elements:\n1. \"NFT balance: \" followed by the string representation of the NFT balance of the `privatePool` address\n2. \"Base token balance: \" followed by the string representation of the base token balance of the `privatePool` address\n\nFinally, the function returns the constructed SVG image in bytes format.",
          "content": "/// @notice Returns an svg image for a pool.\n    /// @param tokenId The private pool's token ID.\n    function svg(uint256 tokenId) public view returns (bytes memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // break up svg building into multiple scopes to avoid stack too deep errors\n        bytes memory _svg;\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:black;fill:white;font-family:serif;\">',\n                    '<text x=\"24px\" y=\"24px\" font-size=\"12\">',\n                        \"Caviar AMM private pool position\",\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"48px\" font-size=\"12\">',\n                        \"Private pool: \", Strings.toHexString(address(privatePool)),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"72px\" font-size=\"12\">',\n                        \"Base token: \", Strings.toHexString(privatePool.baseToken()),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"96px\" font-size=\"12\">',\n                        \"NFT: \", Strings.toHexString(privatePool.nft()),\n                    \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"120px\" font-size=\"12\">',\n                    \"Virtual base token reserves: \", Strings.toString(privatePool.virtualBaseTokenReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"144px\" font-size=\"12\">',\n                    \"Virtual NFT reserves: \", Strings.toString(privatePool.virtualNftReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"168px\" font-size=\"12\">',\n                    \"Fee rate (bps): \", Strings.toString(privatePool.feeRate()),\n                \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg, \n                    '<text x=\"24px\" y=\"192px\" font-size=\"12\">',\n                        \"NFT balance: \", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"216px\" font-size=\"12\">',\n                        \"Base token balance: \", Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                \"</svg>\"\n            );\n        }\n\n        return _svg;\n    }",
          "tokens": {
            "summary": 391,
            "content": 575
          }
        },
        "Trait Type Value": {
          "title": "Trait Type Value",
          "summary": "The given code snippet is a function named `trait` written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This function takes two input parameters, both of type `string memory`: `traitType` and `value`. The function is marked as `internal`, meaning it can only be called from within the same contract or contracts derived from it, and `pure`, which indicates that it does not modify the contract's state or access any external data.\n\nThe purpose of this function is to generate a JSON-formatted string representing a trait object with two properties: \"trait_type\" and \"value\". The values of these properties are derived from the input parameters `traitType` and `value`, respectively.\n\nTo achieve this, the function uses the `abi.encodePacked` function, which is part of the Ethereum Application Binary Interface (ABI). This function takes a variable number of arguments and returns a tightly packed byte array representation of the input data. In this case, the input data consists of a series of string literals and the input parameters, concatenated together to form the desired JSON structure.\n\nAfter encoding the data, the function converts the resulting byte array back into a string using the `string` keyword. Finally, the resulting JSON-formatted string is returned as the output of the function.",
          "content": "function trait(string memory traitType, string memory value) internal pure returns (string memory) {\n        // forgefmt: disable-next-item\n        return string(\n            abi.encodePacked(\n                '{ \"trait_type\": \"', traitType, '\",', '\"value\": \"', value, '\" }'\n            )\n        );\n    }\n}",
          "tokens": {
            "summary": 264,
            "content": 66
          }
        }
      }
    }
  }
}