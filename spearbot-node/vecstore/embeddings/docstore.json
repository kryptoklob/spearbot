[["0",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The content provided is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two libraries and an interface for creating and managing Non-Fungible Tokens (NFTs) using the ERC721 standard.\n\nThe first line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a widely-used library for secure smart contract development. The IERC2981 interface is an Ethereum Improvement Proposal (EIP) that standardizes a way for contracts to handle royalty payments for NFTs. This interface allows developers to implement a royalty system for NFT creators, ensuring they receive a percentage of the sales whenever their NFTs are sold or transferred.\n\nThe second part of the code snippet is an ASCII art representation of a rocket, which is likely included for aesthetic purposes and does not have any functional impact on the code.\n\nThe last part of the code snippet imports two more components from the Solmate library, which is another library for smart contract development. The ERC721 and ERC721TokenReceiver components are imported from the \"solmate/tokens/ERC721.sol\" file. ERC721 is a widely-accepted standard for creating and managing NFTs on the Ethereum blockchain. The ERC721TokenReceiver is an interface that ensures the receiving contract can handle ERC721 tokens correctly.\n\nAdditionally, the SafeTransferLib component is imported from the \"solmate/utils/SafeTransferLib.sol\" file. This library provides utility functions for safely transferring tokens between addresses, ensuring that the transfers are executed securely and without errors.\n\nIn summary, this code snippet imports essential components and interfaces for creating and managing NFTs using the ERC721 standard, implementing royalty payments for NFT creators, and safely transferring tokens between addresses. The imported components are from the OpenZeppelin and Solmate libraries, which are widely used for secure smart contract development on the Ethereum blockchain.\n\nSection Content: import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";","metadata":{}}],["1",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given content is a snippet of Solidity code that imports various interfaces and contracts from different libraries and modules. Solidity is a high-level programming language used for implementing smart contracts on Ethereum and other blockchain platforms.\n\n1. `import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";`\n\nThis line imports the IERC2981 interface from the OpenZeppelin library. OpenZeppelin is a popular library for secure smart contract development on Ethereum. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs). This standard allows NFT creators to receive royalties for secondary sales of their tokens.\n\n2. `import {Pair, ReservoirOracle} from \"caviar/Pair.sol\";`\n\nThis line imports two contracts, Pair and ReservoirOracle, from the Caviar library's Pair.sol file. The Pair contract is likely a representation of a token pair in a decentralized exchange or liquidity pool, while the ReservoirOracle contract could be an implementation of an oracle that provides data related to the token pair, such as price or liquidity information.\n\n3. `import {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";`\n\nThis line imports the IRoyaltyRegistry interface from the royalty-registry-solidity library. The Royalty Registry is a smart contract that keeps track of royalty information for NFTs, such as the creator's address and the royalty percentage. By implementing this interface, a smart contract can interact with the Royalty Registry to manage and retrieve royalty data for NFTs.\n\n4. `import {PrivatePool} from \"./PrivatePool.sol\";`\n\nThis line imports the PrivatePool contract from the local file PrivatePool.sol. The PrivatePool contract is not part of any external library, so it is likely a custom implementation specific to the project. The contract could represent a private liquidity pool or a restricted access trading pool, but without more context, it is difficult to determine its exact functionality.\n\nSection Content: import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";","metadata":{}}],["2",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given content is a single line of code written in Solidity, a programming language used for implementing smart contracts on various blockchain platforms, most notably Ethereum. This line of code is importing an interface called `IStolenNftOracle` from a file named `IStolenNftOracle.sol`.\n\nAn interface in Solidity defines a contract's external functions that other contracts can call, but it does not provide the implementation of these functions. Interfaces are useful for creating modular and reusable code in smart contracts.\n\nIn this specific case, the `IStolenNftOracle` interface is likely related to an oracle service for stolen non-fungible tokens (NFTs). An oracle is a third-party service that provides external data to smart contracts. NFTs are unique digital assets that represent ownership of a specific item, such as digital art, collectibles, or virtual real estate.\n\nThe `IStolenNftOracle` interface might define functions that allow smart contracts to interact with an oracle service to check if a particular NFT has been reported as stolen. This could be useful for marketplaces or other platforms that deal with NFTs to ensure they are not facilitating the trade of stolen assets.\n\nTo summarize, the given content is a Solidity import statement that imports an interface called `IStolenNftOracle` from a file named `IStolenNftOracle.sol`. This interface is likely related to an oracle service for stolen NFTs and defines external functions for smart contracts to interact with the oracle.\n\nSection Content: import {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";","metadata":{}}],["3",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The EthRouter contract, authored by out.eth, is designed to route buy, sell, and change orders to multiple pools in a single transaction. It supports routing orders to either private or public pools. For orders routed to public pools, users can choose whether or not to pay royalties. The only supported base token is native ETH.\n\nThe contract uses the ERC721TokenReceiver and SafeTransferLib libraries. It defines three structs: Buy, Sell, and Change. The Buy struct contains information about the pool, NFT, token IDs, token weights, Merkle multi-proof, base token amount, and whether the pool is public or private. The Sell struct contains similar information, with additional fields for stolen NFT proofs and public pool proofs. The Change struct includes fields for input and output token IDs, weights, and Merkle multi-proofs, as well as stolen NFT proofs.\n\nThe contract defines several error messages, such as DeadlinePassed, OutputAmountTooSmall, PriceOutOfRange, and InvalidRoyaltyFee. It also has an immutable royaltyRegistry address.\n\nThe contract includes a receive() function to accept external payments.\n\nSection Content: /// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}","metadata":{}}],["4",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet is a constructor function in Solidity, which is a programming language used for writing smart contracts on the Ethereum blockchain. The constructor function is a special function that is called only once when a smart contract is deployed. It is used to initialize the state variables of the contract.\n\nIn this specific constructor, there is one input parameter: `_royaltyRegistry` of type `address`. The `address` type in Solidity is used to store Ethereum addresses, which are 20-byte identifiers that represent an account on the Ethereum network.\n\nThe purpose of this constructor is to initialize the state variable `royaltyRegistry` with the value of the input parameter `_royaltyRegistry`. The `royaltyRegistry` variable is likely a state variable of the contract, which means it is stored on the blockchain and can be accessed and modified by the contract's functions.\n\nIn summary, this constructor function takes an Ethereum address as an input parameter and initializes the `royaltyRegistry` state variable with the provided address. This is likely used to set up a reference to another smart contract or account that manages royalties within the context of the contract being deployed.\n\nSection Content: constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }","metadata":{}}],["5",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet is a smart contract function called `buy` that executes a series of buy operations against public or private pools in a decentralized marketplace. The function takes three parameters: an array of `Buy` objects, a `deadline` for the transaction to be mined, and a boolean flag `payRoyalties` to indicate whether royalties should be paid or not.\n\nFirst, the function checks if the deadline has passed (if it's not set to 0) and reverts the transaction if it has. Then, it iterates through the `buys` array and executes each buy operation. If the buy operation is for a public pool, it calculates the input amount and pays royalties if the buyer has opted-in. The royalties are calculated based on the sale price and the royalty fee and recipient are fetched using the `getRoyalty` function. The royalty fee is then transferred to the royalty recipient.\n\nIf the buy operation is for a private pool, the function executes the buy against the private pool using the provided token weights and proof. After each buy operation, the NFTs are transferred to the caller (buyer) using the `safeTransferFrom` function.\n\nFinally, any surplus ETH is refunded to the caller using the `safeTransferETH` function.\n\nSection Content: /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }","metadata":{}}],["6",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet defines a `sell` function that executes a series of sell operations against public or private pools in a decentralized finance (DeFi) application. The function takes four parameters:\n\n1. `sells`: An array of sell operations to execute.\n2. `minOutputAmount`: The minimum amount of output tokens that must be received for the transaction to succeed.\n3. `deadline`: The deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. A value of 0 indicates no deadline.\n4. `payRoyalties`: A boolean flag indicating whether to pay royalties or not.\n\nThe function first checks if the deadline has passed (if any) and reverts the transaction if it has. It then loops through the `sells` array and executes each sell operation. For each sell, it transfers the Non-Fungible Tokens (NFTs) from the caller to the router and approves the pool to transfer NFTs from the router.\n\nIf the sell operation is against a public pool, it calculates the output amount and pays royalties if the seller has opted in. It gets the royalty fee and recipient for each NFT and transfers the royalty fee to the recipient. If the sell operation is against a private pool, it executes the sell directly.\n\nAfter executing all sell operations, the function checks if the output amount is greater than the minimum required amount. If not, it reverts the transaction. Finally, it transfers the output amount to the caller.\n\nSection Content: /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }","metadata":{}}],["7",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet defines a function called `deposit` that allows a user to deposit Non-Fungible Tokens (NFTs) and Ether (ETH) into a private pool. The function takes the following parameters:\n\n1. `privatePool`: The address of the private pool to deposit to.\n2. `nft`: The contract address of the NFT.\n3. `tokenIds`: An array of token IDs representing the NFTs to be deposited.\n4. `minPrice`: The minimum acceptable price of the pool. The function will revert if the pool's price is less than this value.\n5. `maxPrice`: The maximum acceptable price of the pool. The function will revert if the pool's price is more than this value.\n6. `deadline`: A timestamp representing the deadline for the transaction to be mined. The function will revert if the current timestamp is greater than the deadline. If set to 0, the deadline will be ignored.\n\nThe function first checks if the deadline has passed (if it is not set to 0) and reverts the transaction with a `DeadlinePassed` error if the condition is met. Next, it checks if the pool's price is within the specified range (between `minPrice` and `maxPrice`). If the price is out of range, the transaction is reverted with a `PriceOutOfRange` error.\n\nThe function then iterates through the `tokenIds` array and transfers the NFTs from the caller to the contract using the `safeTransferFrom` function of the ERC721 standard. After transferring the NFTs, the function sets approval for the private pool to transfer NFTs from the router using the `setApprovalForAll` function.\n\nFinally, the `deposit` function of the `PrivatePool` contract is called with the `tokenIds` array and the value of Ether sent in the transaction. The Ether value is forwarded using the `{value: msg.value}` syntax.\n\nSection Content: /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }","metadata":{}}],["8",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet is a Solidity function called `change` that executes a series of change operations against a private pool. The function takes two input parameters: an array of `Change` objects called `changes` and a `deadline` represented as a uint256.\n\nThe function first checks if the deadline has passed by comparing the current block timestamp with the given deadline. If the deadline has passed and is not set to 0 (which means the deadline should be ignored), the function reverts with a `DeadlinePassed` error.\n\nNext, the function iterates through the `changes` array and processes each change operation. For each change, it transfers the input NFTs (Non-Fungible Tokens) from the caller to the contract's address using the `safeTransferFrom` function of the ERC721 standard. It then approves the private pool to transfer NFTs from the router by calling the `setApprovalForAll` function of the ERC721 standard.\n\nThe function then executes the change operation by calling the `change` function of the `PrivatePool` contract, passing in the necessary parameters such as input and output token IDs, weights, and proofs.\n\nAfter the change operation is executed, the function transfers the output NFTs back to the caller using the `safeTransferFrom` function of the ERC721 standard.\n\nFinally, if there is any remaining ETH balance in the contract, it is refunded to the caller using the `safeTransferETH` function.\n\nSection Content: /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }","metadata":{}}],["9",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given content is a function definition in a smart contract, written in Solidity programming language, for a blockchain-based application. The function is named `getRoyalty` and its purpose is to calculate the royalty fee and identify the recipient for a given Non-Fungible Token (NFT) and its sale price. The function retrieves the royalty information from the manifold registry.\n\nThe function takes three input parameters:\n\n1. `address nft`: The address of the NFT contract.\n2. `uint256 tokenId`: The unique identifier of the NFT.\n3. `uint256 salePrice`: The sale price of the NFT.\n\nThe function returns two output values:\n\n1. `uint256 royaltyFee`: The calculated royalty fee to be paid.\n2. `address recipient`: The address of the recipient who will receive the royalty fee.\n\nThe function is marked as `public` and `view`, which means it can be called by any external entity and does not modify the state of the contract.\n\nInside the function, the first step is to get the royalty lookup address by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the NFT contract address as an argument. The `IRoyaltyRegistry` interface is a contract that defines the functions for interacting with the royalty registry.\n\nThe `getRoyaltyLookupAddress` function returns the address of the royalty lookup contract, which is then stored in the `lookupAddress` variable. The function then calculates the royalty fee and recipient using the information from the royalty lookup contract.\n\nSection Content: /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);","metadata":{}}],["10",{"pageContent":"File Context: The Eth Router contract facilitates streamlined trading of native ETH-based tokens by routing various order types to multiple pools, handling NFT transfers and royalty fees, and ensuring deadline compliance and surplus ETH refunds.\n\nSection Summary: The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract supports the ERC-2981 interface, which is a standard for handling royalty payments in Non-Fungible Tokens (NFTs). If the contract supports this interface, the code retrieves the royalty fee and recipient information, and then checks if the royalty fee is valid by comparing it to the sale price of the NFT.\n\n1. The first line checks if the contract at the `lookupAddress` supports the ERC-2981 interface by calling the `supportsInterface` function with the interface ID of ERC-2981. The `IERC2981` is an interface that defines the functions and events required for a contract to be compliant with the ERC-2981 standard.\n\n2. If the contract supports the ERC-2981 interface, the code proceeds to retrieve the royalty fee and recipient information by calling the `royaltyInfo` function of the ERC-2981 compliant contract. The `royaltyInfo` function takes two arguments: the `tokenId` representing the unique identifier of the NFT, and the `salePrice` which is the price at which the NFT is being sold.\n\n3. The code then checks if the royalty fee is valid by comparing it to the sale price of the NFT. If the royalty fee is greater than the sale price, the transaction is reverted with an `InvalidRoyaltyFee` error message. This ensures that the royalty fee is not unreasonably high and does not exceed the sale price of the NFT.\n\nIn summary, this code snippet is used to verify if a contract supports the ERC-2981 standard for handling royalty payments in NFTs, and if so, retrieves the royalty fee and recipient information, and validates the royalty fee by comparing it to the sale price of the NFT.\n\nSection Content: if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}","metadata":{}}],["11",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of new private pools. Authored by out.eth, the contract inherits from the ERC721 and Owned contracts, and utilizes the LibClone and SafeTransferLib libraries.\n\nWhen a private pool is created, an NFT (Non-Fungible Token) representing the private pool is minted and assigned to the creator. Additionally, all protocol fees generated by the private pools are accumulated in this contract and can be withdrawn by the admin.\n\nThe contract emits two events: Create and Withdraw. The Create event is emitted when a new private pool is created, and it includes the private pool's address, token IDs, and base token amount. The Withdraw event is emitted when the admin withdraws tokens from the contract, and it includes the token's address and the withdrawn amount.\n\nThe contract also maintains a reference to the private pool implementation's address, which is used by proxies to point to the correct implementation.\n\nSection Content: /// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;","metadata":{}}],["12",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a Solidity function named `setPrivatePoolMetadata` that sets the address of a private pool metadata contract. This function is part of a smart contract and can only be executed by the contract owner, as indicated by the `onlyOwner` modifier.\n\nThe function takes one input parameter, `_privatePoolMetadata`, which is an address representing the private pool metadata contract. Inside the function, the value of the `_privatePoolMetadata` parameter is assigned to the `privatePoolMetadata` state variable, effectively updating the address of the private pool metadata contract.\n\nThe `@notice` and `@param` comments above the function provide a brief description of the function's purpose and its input parameter, respectively. These comments are part of the NatSpec documentation format, which is used to generate human-readable descriptions of Solidity code.\n\nSection Content: /// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }","metadata":{}}],["13",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given content is a Solidity code snippet representing a constructor function and a receive function for a smart contract. This smart contract is based on the Ethereum blockchain and utilizes the ERC721 standard for non-fungible tokens (NFTs). The constructor function initializes the contract with a name and symbol, while the receive function allows the contract to accept Ether payments.\n\n1. Constructor function:\n   - constructor(): This is a special function in Solidity that is called only once when the smart contract is deployed. It is used to initialize the contract's state variables and set up any required configurations.\n   - ERC721(\"Caviar Private Pools\", \"POOL\"): This indicates that the smart contract is based on the ERC721 standard, which is a popular standard for creating and managing NFTs on the Ethereum blockchain. The constructor takes two arguments - the name and symbol of the NFT. In this case, the name is \"Caviar Private Pools\" and the symbol is \"POOL\".\n   - Owned(msg.sender): This part of the constructor function indicates that the contract is using an ownership model, where the contract has an owner who can perform certain privileged actions. The owner is set to the address that deploys the contract, represented by msg.sender.\n\n2. Receive function:\n   - receive(): This is a special function in Solidity that is called when the contract receives Ether without any accompanying data. It is marked as external, meaning it can only be called from outside the contract.\n   - payable: This keyword indicates that the function can receive Ether payments. Without this keyword, the contract would reject any incoming Ether transfers.\n   - {}: The empty curly braces indicate that there is no specific functionality implemented within the receive function. This means that the contract will simply accept any Ether sent to it without performing any additional actions.\n\nSection Content: constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}","metadata":{}}],["14",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a function named `create` that creates a new private pool using the minimal proxy pattern, pointing to the private pool implementation. The function takes several parameters, including the base token address, NFT address, virtual base token reserves, virtual NFT reserves, change fee, fee rate, Merkle root, whether to use the stolen NFT oracle, salt, token IDs, and the base token amount.\n\nThe function first checks if the base token is ETH and if the sent ETH value is equal to the base token amount. If the base token is not ETH, it checks if the sent ETH value is zero. If these conditions are not met, the function reverts with an \"InvalidEthAmount\" error.\n\nNext, the function deploys a minimal proxy clone of the private pool implementation using the provided salt. It then mints an NFT to the caller using the address of the private pool.\n\nThe function initializes the private pool with the provided parameters, including the base token, NFT, virtual reserves, fees, Merkle root, stolen NFT oracle, and royalty payments.\n\nIf the base token is ETH, the function transfers the ETH into the pool. If the base token is not ETH, it transfers the base tokens from the caller to the pool using the ERC20 `transferFrom` function.\n\nThe function then deposits the NFTs from the caller into the pool using the ERC721 `safeTransferFrom` function, iterating through the provided token IDs.\n\nFinally, the function emits a \"Create\" event with the private pool address, token IDs, and base token amount. The function returns the address of the created private pool.\n\nSection Content: /// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }","metadata":{}}],["15",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a function named `setPrivatePoolImplementation` in a Solidity smart contract. This function is responsible for setting the private pool implementation contract address that will be used by newly deployed proxy contracts.\n\nThe function takes one input parameter, `_privatePoolImplementation`, which is an address representing the private pool implementation contract. The function is marked as `public`, meaning it can be called by any external entity, and it has a function modifier `onlyOwner`, which restricts the execution of the function to only the owner of the contract.\n\nInside the function, the contract's state variable `privatePoolImplementation` is assigned the value of the input parameter `_privatePoolImplementation`. This updates the private pool implementation contract address that will be used by the proxy contracts.\n\nSection Content: /// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }","metadata":{}}],["16",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a Solidity function named `setProtocolFeeRate` that sets the protocol fee rate for a specific operation in a smart contract. The function takes a single input parameter, `_protocolFeeRate`, which is a 16-bit unsigned integer representing the protocol fee rate in basis points (1 basis point = 0.01%). The function is marked as `public`, meaning it can be called by any external entity, and it has a modifier `onlyOwner`, which restricts its execution to the contract owner only.\n\nThe function sets the value of the state variable `protocolFeeRate` to the input parameter `_protocolFeeRate`. The comment above the function indicates that the protocol fee rate is applied to buy, sell, and change operations within the contract. The fee rate is expressed in basis points, so a value of 350 would represent a 3.5% fee on the respective operations.\n\nIn summary, the `setProtocolFeeRate` function allows the contract owner to update the protocol fee rate for specific operations within the smart contract, ensuring that the fee rate is expressed in basis points and can be adjusted as needed.\n\nSection Content: /// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }","metadata":{}}],["17",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a Solidity function named `withdraw` that is part of a smart contract. The purpose of this function is to withdraw the earned protocol fees in the form of a specified token and amount. The function has two input parameters: `token` and `amount`. The `token` parameter is an address representing the token to be withdrawn, while the `amount` parameter is a uint256 value representing the amount of tokens to be withdrawn.\n\nThe function has a `public` visibility, meaning it can be called from any external source, and it also has a modifier `onlyOwner`, which restricts the execution of the function to the owner of the smart contract only.\n\nInside the function, there is a conditional statement that checks if the `token` address is equal to the zero address (address(0)). If it is, the function assumes that the withdrawal is in Ether (ETH) and calls the `safeTransferETH` function from the `msg.sender` object, transferring the specified `amount` of Ether to the sender's address.\n\nIf the `token` address is not equal to the zero address, the function assumes that the withdrawal is in an ERC20 token. It then calls the `transfer` function from the ERC20 token contract, transferring the specified `amount` of tokens to the sender's address.\n\nFinally, the function emits an event named `Withdraw` with the `token` and `amount` parameters, which can be used by external sources to track the withdrawal transactions.\n\nSection Content: /// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }","metadata":{}}],["18",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a function named `tokenURI` written in Solidity, which is a programming language used for implementing smart contracts on the Ethereum blockchain. This function is a part of a larger smart contract, and its purpose is to return the token URI (Uniform Resource Identifier) associated with a specific token ID.\n\nThe function takes a single input parameter, `id`, which is a 256-bit unsigned integer representing the token ID. The function is marked as `public`, meaning it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract. The `override` keyword is used to indicate that this function is intended to override a function with the same name and signature in a parent contract.\n\nThe function returns a single output, a string in memory, which represents the token URI. Inside the function body, the token URI is obtained by calling the `tokenURI` function of another contract, `PrivatePoolMetadata`. The `privatePoolMetadata` variable is cast to the `PrivatePoolMetadata` contract type before calling the function. This is done to ensure that the called contract has the required `tokenURI` function.\n\nIn summary, the `tokenURI` function is a public view function that takes a token ID as input and returns the associated token URI by calling the `tokenURI` function of the `PrivatePoolMetadata` contract.\n\nSection Content: /// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }","metadata":{}}],["19",{"pageContent":"File Context: The Caviar Private Pool Factory is a smart contract that facilitates the creation and initialization of private pools, minting NFTs for creators, handling protocol fees, deploying pool clones, and managing private pool metadata, implementation contracts, and fee rates, while also enabling the withdrawal of earned fees and prediction of deployment addresses for new pools.\n\nSection Summary: The given code snippet is a Solidity function named `predictPoolDeploymentAddress` that predicts the deployment address of a new private pool in a blockchain-based application. The function takes a single input parameter, `salt`, which is a 32-byte value (bytes32) that will be used during the deployment process. The function returns a single output, `predictedAddress`, which is the predicted deployment address of the private pool.\n\nThe function is marked as `public`, meaning it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract and can be executed without incurring any gas costs.\n\nInside the function, the `predictedAddress` is calculated by calling the `predictDeterministicAddress` function on the `privatePoolImplementation` contract. This function takes two input parameters: the `salt` value provided by the user and the address of the current contract (retrieved using `address(this)`).\n\nIn summary, the `predictPoolDeploymentAddress` function is a utility function that predicts the deployment address of a new private pool using a given salt value and the address of the current contract. This can be useful in scenarios where the deployment address needs to be known in advance, such as pre-allocating funds or setting up permissions for the new private pool.\n\nSection Content: /// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}","metadata":{}}],["20",{"pageContent":"File Context: The IStolenNftOracle interface in Solidity allows validation of non-stolen token IDs by defining a message structure and incorporating the token contract address, token IDs, and proofs as input parameters for its function.\n\nSection Summary: The given content represents an interface called `IStolenNftOracle` in a programming context, most likely within a blockchain or smart contract environment. An interface is a collection of abstract methods and properties that can be implemented by any class or struct. It serves as a blueprint for designing and implementing specific functionalities in a standardized manner.\n\nIn this case, the `IStolenNftOracle` interface is designed to interact with Non-Fungible Tokens (NFTs) that have been stolen or compromised. The term \"oracle\" in the context of blockchain refers to a system that provides external data or information to smart contracts. Therefore, this interface is likely to be used for creating an oracle that can provide information about stolen NFTs to other smart contracts or applications.\n\nSince the content only provides the name of the interface, there are no specific methods or properties mentioned. However, we can infer that the methods and properties within this interface would be related to querying, reporting, and validating the status of stolen NFTs. Some possible methods that could be included in this interface are:\n\n1. `isStolen`: A method that takes an NFT identifier as input and returns a boolean value indicating whether the NFT is marked as stolen or not.\n2. `reportStolen`: A method that allows users to report an NFT as stolen by providing its identifier and additional information about the theft.\n3. `validateOwnership`: A method that verifies the ownership of an NFT by checking its current owner against the original owner's address.\n\nIn summary, the `IStolenNftOracle` interface represents a blueprint for creating an oracle that can interact with stolen NFTs in a blockchain or smart contract environment. It is likely to include methods and properties related to querying, reporting, and validating the status of stolen NFTs.\n\nSection Content: interface IStolenNftOracle {","metadata":{}}],["21",{"pageContent":"File Context: The IStolenNftOracle interface in Solidity allows validation of non-stolen token IDs by defining a message structure and incorporating the token contract address, token IDs, and proofs as input parameters for its function.\n\nSection Summary: The given content is a Solidity code snippet defining a struct named \"Message\" within a smart contract. Solidity is a programming language used for writing smart contracts on the Ethereum blockchain platform. A struct is a custom data structure that allows grouping of multiple variables under a single name.\n\nThe \"Message\" struct consists of four fields:\n\n1. `bytes32 id`: This field represents a unique identifier for the message, stored as a 32-byte fixed-size array of bytes. The `bytes32` type is commonly used for storing hashes or other fixed-length binary data.\n\n2. `bytes payload`: This field represents the actual content of the message, stored as a dynamically-sized array of bytes. The `bytes` type is used for storing arbitrary-length binary data.\n\n3. `uint256 timestamp`: This field represents the UNIX timestamp when the message was signed by the oracle. The timestamp is stored as an unsigned 256-bit integer (`uint256`). UNIX timestamps are commonly used to represent dates and times in a standardized format, counting the number of seconds since January 1, 1970.\n\n4. `bytes signature`: This field represents the digital signature of the message, which can be either an Elliptic Curve Digital Signature Algorithm (ECDSA) signature or an EIP-2098 compact signature. The signature is stored as a dynamically-sized array of bytes. Digital signatures are used to verify the authenticity and integrity of the message, ensuring that it has not been tampered with and that it originates from a trusted source (the oracle in this case).\n\nIn summary, the \"Message\" struct is a custom data structure used to store information about a message, including its unique identifier, payload, timestamp, and digital signature. This struct is likely used within a smart contract to handle oracle-related operations, such as verifying the authenticity of data provided by an external source.\n\nSection Content: // copied from https://github.com/reservoirprotocol/oracle/blob/main/contracts/ReservoirOracle.sol\n    struct Message {\n        bytes32 id;\n        bytes payload;\n        // The UNIX timestamp when the message was signed by the oracle\n        uint256 timestamp;\n        // ECDSA signature or EIP-2098 compact signature\n        bytes signature;\n    }","metadata":{}}],["22",{"pageContent":"File Context: The IStolenNftOracle interface in Solidity allows validation of non-stolen token IDs by defining a message structure and incorporating the token contract address, token IDs, and proofs as input parameters for its function.\n\nSection Summary: The given content describes a function called `validateTokensAreNotStolen` in a smart contract. This function is responsible for validating that a set of token ids have not been marked as stolen by an oracle. An oracle is an external data source that provides information to smart contracts.\n\nThe function takes three input parameters:\n\n1. `tokenAddress`: This is the address of the token contract, which is a unique identifier for the contract that manages the tokens.\n2. `tokenIds`: This is an array of token ids that need to be validated. Each token id is a unique identifier for a specific token.\n3. `proofs`: This is an array of signed messages (or proofs) from the oracle, which provide evidence that the token ids have not been marked as stolen.\n\nThe function is marked as `external`, which means it can only be called from outside the contract (i.e., it cannot be called by other functions within the same contract).\n\nThe purpose of this function is to check the signed messages (proofs) from the oracle to ensure that the given token ids have not been marked as stolen. This is an important security measure to prevent unauthorized use or transfer of stolen tokens within a blockchain ecosystem.\n\nSection Content: /// @notice Validates that a set of token ids have not been marked as stolen by the oracle.\n    /// @dev Check a signed message from the oracle to ensure that the token ids have not been marked as stolen.\n    /// @param tokenAddress The address of the token contract.\n    /// @param tokenIds The token ids to validate.\n    /// @param proofs The proofs that the token ids have not been marked as stolen.\n    function validateTokensAreNotStolen(address tokenAddress, uint256[] calldata tokenIds, Message[] calldata proofs)\n        external;\n}","metadata":{}}],["23",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. The code imports various libraries and interfaces to be used in the development of a smart contract.\n\n1. `import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";`: This line imports the IERC2981 interface from the OpenZeppelin library. IERC2981 is an Ethereum Improvement Proposal (EIP) that standardizes royalty payments for Non-Fungible Tokens (NFTs) across different platforms.\n\n2. The ASCII art in the code snippet is a decorative element and does not have any functional impact on the code.\n\n3. `import {ERC20} from \"solmate/tokens/ERC20.sol\";`: This line imports the ERC20 token implementation from the Solmate library. ERC20 is a widely-used standard for creating and managing fungible tokens on the Ethereum blockchain.\n\n4. `import {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";`: This line imports the ERC721 token implementation and the ERC721TokenReceiver interface from the Solmate library. ERC721 is a standard for creating and managing non-fungible tokens (NFTs) on the Ethereum blockchain, while the ERC721TokenReceiver interface defines a standard method for handling the receipt of NFTs.\n\n5. `import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";`: This line imports the FixedPointMathLib library from the Solmate library. FixedPointMathLib is a utility library that provides fixed-point arithmetic operations, which can be useful for handling decimal numbers in smart contracts.\n\n6. `import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";`: This line imports the SafeTransferLib library from the Solmate library. SafeTransferLib is a utility library that provides safe methods for transferring ERC20 tokens and Ether, preventing common issues such as reentrancy attacks.\n\n7. `import {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";`: This line imports the MerkleProofLib library from the Solady library. MerkleProofLib is a utility library that provides functions for working with Merkle proofs, which can be used to verify the inclusion of an element in a Merkle tree.\n\nSection Content: import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";*                                   ____\n *                                /\\|    ~~\\\n *                              /'  |   ,-. `\\\n *                             |       | X |  |\n *                            _|________`-'   |X\n *                          /'          ~~~~~~~~~,\n *                        /'             ,_____,/_\n *                     ,/'        ___,'~~         ;\n * ~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,\n *         |       |            |  XX'____________'\n *         |       |           /' XXX|            ;\n *         |       |        --x|  XXX,~~~~~~~~~~~~,\n *         |       |          X|     '____________'\n *         |   o   |---~~~~\\__XX\\             |XX\n *         |       |          XXX`\\          /XXXX\n * ~~~~~~~~'~~~~~~~'               `\\xXXXXx/' \\XXX\n *                                  /XXXXXX\\\n *                                /XXXXXXXXXX\\\n *                              /XXXXXX/^\\XXXXX\\\n *                             ~~~~~~~~   ~~~~~~~\n */\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";","metadata":{}}],["24",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content is a code snippet written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This code snippet imports two interfaces, IERC2981 and IRoyaltyRegistry, from their respective locations.\n\n1. IERC2981: This interface is imported from the OpenZeppelin library, a widely-used and trusted library for secure smart contract development. IERC2981 is an interface for the ERC-2981 standard, which is a royalty standard for Non-Fungible Tokens (NFTs) on the Ethereum blockchain. The ERC-2981 standard provides a uniform way to handle royalty payments for NFTs, allowing creators to receive a percentage of the sales whenever their NFTs are sold or transferred.\n\n2. IRoyaltyRegistry: This interface is imported from the royalty-registry-solidity library. The Royalty Registry is a smart contract that allows NFT creators and platforms to manage royalty information for their NFTs in a decentralized manner. By implementing the IRoyaltyRegistry interface, a smart contract can interact with the Royalty Registry to store and retrieve royalty information for NFTs.\n\nIn summary, this code snippet imports two interfaces related to royalty management for NFTs on the Ethereum blockchain. The IERC2981 interface provides a standard for handling royalty payments, while the IRoyaltyRegistry interface allows for decentralized management of royalty information. These interfaces can be used to build smart contracts that support royalty payments and management for NFT creators and platforms.\n\nSection Content: import {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";","metadata":{}}],["25",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content is a single line of code that imports the IERC3156FlashBorrower interface from the OpenZeppelin library's IERC3156FlashLender.sol file. This line of code is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain.\n\nOpenZeppelin is a widely-used library of secure and audited smart contract components for the Ethereum platform. It provides developers with reusable components to build decentralized applications (dApps) and protocols, reducing the risk of vulnerabilities and improving the overall security of the blockchain ecosystem.\n\nThe IERC3156FlashBorrower interface is part of the ERC-3156 standard, which defines a common interface for flash loans. Flash loans are a type of uncollateralized loan that allows users to borrow and repay assets within a single transaction. This feature is particularly useful in decentralized finance (DeFi) applications, where users can take advantage of arbitrage opportunities, perform liquidations, or refinance debt positions without the need for collateral.\n\nBy importing the IERC3156FlashBorrower interface, the developer can implement the required functions for a smart contract to interact with flash loan providers that follow the ERC-3156 standard. This ensures compatibility and interoperability between different flash loan providers and borrowers in the DeFi ecosystem.\n\nIn summary, the given line of code imports the IERC3156FlashBorrower interface from the OpenZeppelin library, allowing developers to implement the necessary functions for their smart contracts to interact with ERC-3156 compliant flash loan providers on the Ethereum blockchain.\n\nSection Content: import {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashLender.sol\";","metadata":{}}],["26",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `setUseStolenNftOracle` that is used to set the flag for using a stolen NFT oracle in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newUseStolenNftOracle`, which is a boolean value representing the new state of the flag for using the stolen NFT oracle. The function sets the value of the `useStolenNftOracle` variable to the value of the input parameter.\n\nAfter updating the flag, the function emits an event called `SetUseStolenNftOracle` with the new value of the flag as its argument. This event can be used by external systems or applications to track changes in the state of the flag.\n\nIn summary, this function allows the owner of the pool to enable or disable the use of a stolen NFT oracle, which is responsible for checking if an NFT is stolen, by updating the flag and emitting an event to notify external systems of the change.\n\nSection Content: /// @notice Sets the whether or not to use the stolen NFT oracle. Can only be called by the owner of the pool. The\n    /// stolen NFT oracle is used to check if an NFT is stolen.\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    function setUseStolenNftOracle(bool newUseStolenNftOracle) public onlyOwner {\n        // set the use stolen NFT oracle flag\n        useStolenNftOracle = newUseStolenNftOracle;\n\n        // emit the set use stolen NFT oracle event\n        emit SetUseStolenNftOracle(newUseStolenNftOracle);\n    }","metadata":{}}],["27",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The PrivatePool contract is an NFT Automated Market Maker (AMM) controlled by a single owner, featuring concentrated liquidity, custom fee rates, stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. Users can create a pool and modify its parameters according to their preferences. Depositing NFTs and base tokens (or ETH) into the pool enables trading and allows users to earn fees on each trade.\n\nThe contract uses the SafeTransferLib library for secure transfers and includes a MerkleMultiProof struct for inputting Merkle proofs. Several events are emitted for different actions, such as initializing the pool, buying and selling NFTs, depositing and withdrawing tokens, changing parameters, and setting various options.\n\nThe contract stores information about the base ERC20 token, the NFT address, change/flash fees, buy/sell fee rates, initialization status, royalty payment status, stolen NFT oracle usage, virtual base token reserves, virtual NFT reserves, and the Merkle root of all token weights in the pool. The stolen NFT oracle is an immutable address.\n\nErrors are defined for various situations, such as unauthorized access, invalid inputs, insufficient input weight, high fee rates, flash loan unavailability, flash loan failure, and invalid royalty fees.\n\nSection Content: /// @title Private Pool\n/// @author out.eth (@outdoteth)\n/// @notice A private pool is a an NFT AMM controlled by a single owner with concentrated liquidity, custom fee rates,\n/// stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. You can create a pool and change\n/// these parameters to your liking. Deposit NFTs and base tokens (or ETH) into the pool to enable trading. Earn fees on\n/// each trade.\ncontract PrivatePool is ERC721TokenReceiver {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    /// @notice Merkle proof input for a sparse merkle multi proof. It can be generated with a library like:\n    /// https://github.com/OpenZeppelin/merkle-tree#treegetmultiproof\n    struct MerkleMultiProof {\n        bytes32[] proof;\n        bool[] flags;\n    }\n\n    // forgefmt: disable-start\n    event Initialize(address indexed baseToken, address indexed nft, uint128 virtualBaseTokenReserves, uint128 virtualNftReserves, uint56 changeFee, uint16 feeRate, bytes32 merkleRoot, bool useStolenNftOracle, bool payRoyalties);\n    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Sell(uint256[] tokenIds, uint256[] tokenWeights, uint256 outputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Deposit(uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed nft, uint256[] tokenIds, address token, uint256 amount);\n    event Change(uint256[] inputTokenIds, uint256[] inputTokenWeights, uint256[] outputTokenIds, uint256[] outputTokenWeights, uint256 feeAmount, uint256 protocolFeeAmount);\n    event SetVirtualReserves(uint128 virtualBaseTokenReserves, uint128 virtualNftReserves);\n    event SetMerkleRoot(bytes32 merkleRoot);\n    event SetFeeRate(uint16 feeRate);\n    event SetUseStolenNftOracle(bool useStolenNftOracle);\n    event SetPayRoyalties(bool payRoyalties);\n    // forgefmt: disable-end\n\n    error AlreadyInitialized();\n    error Unauthorized();\n    error InvalidEthAmount();\n    error InvalidMerkleProof();\n    error InsufficientInputWeight();\n    error FeeRateTooHigh();\n    error NotAvailableForFlashLoan();\n    error FlashLoanFailed();\n    error InvalidRoyaltyFee();\n\n    /// @notice The address of the base ERC20 token.\n    address public baseToken;\n\n    /// @notice The address of the nft.\n    address public nft;\n\n    /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n    uint56 public changeFee;\n\n    /// @notice The buy/sell fee rate (in basis points) 200 = 2%\n    uint16 public feeRate;\n\n    /// @notice Whether or not the pool has been initialized.\n    bool public initialized;\n\n    /// @notice Whether or not the pool pays royalties to the NFT creator on each trade.\n    bool public payRoyalties;\n\n    /// @notice Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen.\n    bool public useStolenNftOracle;\n\n    /// @notice The virtual base token reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    uint128 public virtualBaseTokenReserves;\n\n    /// @notice The virtual nft reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    /// @dev The virtual NFT reserves that a user sets. If it's desired to set the reserves to match 16 NFTs then the\n    /// virtual reserves should be set to 16e18. If weights are enabled by setting the merkle root to be non-zero then\n    /// the virtual reserves should be set to the sum of the weights of the NFTs; where floor NFTs all have a weight of\n    /// 1e18. A rarer NFT may have a weight of 2.3e18 if it's 2.3x more valuable than a floor.\n    uint128 public virtualNftReserves;\n\n    /// @notice The merkle root of all the token weights in the pool. If the merkle root is set to bytes32(0) then all\n    /// NFTs are set to have a weight of 1e18.\n    bytes32 public merkleRoot;\n\n    /// @notice The NFT oracle to check if an NFT is stolen.\n    address public immutable stolenNftOracle;","metadata":{}}],["28",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content is a snippet of a Solidity smart contract code that defines a factory contract, a royalty registry, and a modifier for access control.\n\n1. `address payable public immutable factory;` - This line declares a public, immutable, and payable variable named `factory` of type `address`. This variable represents the factory contract that created the current pool. Being immutable, its value is set during the contract's deployment and cannot be changed afterward.\n\n2. `address public immutable royaltyRegistry;` - This line declares a public and immutable variable named `royaltyRegistry` of type `address`. This variable represents the royalty registry from manifold.xyz, a platform for managing royalties and licensing for digital assets. Similar to the `factory` variable, its value is set during the contract's deployment and cannot be changed afterward.\n\n3. The `modifier onlyOwner() virtual` block defines a modifier named `onlyOwner` that can be used to restrict access to certain functions within the contract. This modifier checks if the sender of the transaction (`msg.sender`) is the owner of the contract by comparing it with the owner returned by the `Factory(factory).ownerOf(uint160(address(this)))` function call. If the sender is not the owner, the modifier will revert the transaction with an \"Unauthorized\" error message. The `virtual` keyword indicates that this modifier can be overridden in derived contracts.\n\n4. `receive() external payable {}` - This line defines a fallback function that allows the contract to receive Ether payments. The `external` keyword specifies that this function can only be called from outside the contract, and the `payable` keyword allows the function to accept Ether. The empty function body `{}` indicates that no additional logic is executed when Ether is received.\n\nSection Content: /// @notice The factory contract that created this pool.\n    address payable public immutable factory;\n\n    /// @notice The royalty registry from manifold.xyz.\n    address public immutable royaltyRegistry;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != Factory(factory).ownerOf(uint160(address(this)))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    receive() external payable {}","metadata":{}}],["29",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a constructor function for a smart contract in the Solidity programming language. This constructor is called only when the base implementation contract is deployed. It sets three immutable parameters: factory, royaltyRegistry, and stolenNftOracle. These parameters represent the addresses of the factory contract, the royalty registry from manifold.xyz, and the stolen NFT oracle, respectively.\n\nThe constructor takes three input arguments: _factory, _royaltyRegistry, and _stolenNftOracle, which are the addresses for the respective contracts. Inside the constructor, the factory address is converted to a payable address and assigned to the factory variable. The royaltyRegistry and stolenNftOracle variables are assigned the respective input addresses without any conversion.\n\nStoring these parameters in immutable storage allows all minimal proxy contracts to read them without incurring additional deployment costs and re-initializing them at the point of creation in the factory contract. This approach optimizes the contract's gas usage and ensures that these parameters remain constant throughout the contract's lifecycle.\n\nSection Content: /// @dev This is only called when the base implementation contract is deployed. The following immutable parameters\n    /// are set:\n    /// - factory: The address of the factory contract\n    /// - royaltyRegistry: The address of the royalty registry from manifold.xyz\n    /// - stolenNftOracle: The address of the stolen NFT oracle\n    /// These are all stored in immutable storage, which enables all minimal proxy contracts to read them without\n    /// incurring additional deployment costs and re-initializing them at point of creation in the factory contract.\n    constructor(address _factory, address _royaltyRegistry, address _stolenNftOracle) {\n        factory = payable(_factory);\n        royaltyRegistry = _royaltyRegistry;\n        stolenNftOracle = _stolenNftOracle;\n    }","metadata":{}}],["30",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function named `initialize` that initializes a private pool and sets its initial parameters. This function should only be called once by the factory. The function takes the following input parameters:\n\n1. `_baseToken`: The address of the base token.\n2. `_nft`: The address of the NFT (Non-Fungible Token).\n3. `_virtualBaseTokenReserves`: The virtual base token reserves.\n4. `_virtualNftReserves`: The virtual NFT reserves.\n5. `_changeFee`: The change fee.\n6. `_feeRate`: The fee rate (in basis points), where 200 equals 2%.\n7. `_merkleRoot`: The Merkle root.\n8. `_useStolenNftOracle`: A boolean value indicating whether the pool uses the stolen NFT oracle to check if an NFT is stolen.\n9. `_payRoyalties`: A boolean value indicating whether to pay royalties.\n\nThe function first checks if the pool has already been initialized, and if so, it reverts with an `AlreadyInitialized` error. It then checks if the fee rate is less than 50%, and if not, it reverts with a `FeeRateTooHigh` error.\n\nNext, the function sets the state variables with the input parameters. It marks the pool as initialized and emits an `Initialize` event with the input parameters.\n\nIn summary, the `initialize` function is responsible for setting up a private pool with the specified parameters, ensuring that it is only initialized once and that the fee rate is within acceptable limits.\n\nSection Content: /// @notice Initializes the private pool and sets the initial parameters. Should only be called once by the factory.\n    /// @param _baseToken The address of the base token\n    /// @param _nft The address of the NFT\n    /// @param _virtualBaseTokenReserves The virtual base token reserves\n    /// @param _virtualNftReserves The virtual NFT reserves\n    /// @param _feeRate The fee rate (in basis points) 200 = 2%\n    /// @param _merkleRoot The merkle root\n    /// @param _useStolenNftOracle Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen\n    function initialize(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties\n    ) public {\n        // prevent duplicate initialization\n        if (initialized) revert AlreadyInitialized();\n\n        // check that the fee rate is less than 50%\n        if (_feeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the state variables\n        baseToken = _baseToken;\n        nft = _nft;\n        virtualBaseTokenReserves = _virtualBaseTokenReserves;\n        virtualNftReserves = _virtualNftReserves;\n        changeFee = _changeFee;\n        feeRate = _feeRate;\n        merkleRoot = _merkleRoot;\n        useStolenNftOracle = _useStolenNftOracle;\n        payRoyalties = _payRoyalties;\n\n        // mark the pool as initialized\n        initialized = true;\n\n        // emit the event\n        emit Initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n    }","metadata":{}}],["31",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content describes a function called `buy` that allows users to purchase Non-Fungible Tokens (NFTs) from a pool using base tokens. The function takes three parameters: `tokenIds`, `tokenWeights`, and `proof`. The `tokenIds` parameter represents the IDs of the NFTs to be purchased, while `tokenWeights` represents the weights of the NFTs. The `proof` parameter is a Merkle proof for the weights of each NFT to be purchased.\n\nThe function returns three values: `netInputAmount`, `feeAmount`, and `protocolFeeAmount`. The `netInputAmount` is the total amount of base tokens spent, including fees. The `feeAmount` is the amount of base tokens spent on fees, and the `protocolFeeAmount` is the amount of base tokens spent on protocol fees.\n\nThe function first calculates the sum of weights of the NFTs to be purchased and validates the Merkle proof. It then calculates the required net input amount and fee amount based on the sum of weights. If the base token is not Ethereum (ETH), the function checks that the caller sent 0 ETH.\n\nNext, the function updates the virtual reserves by adding the net input amount minus the fee amount and protocol fee amount to the virtual base token reserves and subtracting the sum of weights from the virtual NFT reserves.\n\nThe function then calculates the sale price for each NFT, assuming it's the same for each NFT even if weights differ. It transfers the NFTs to the caller and, if royalties are to be paid, calculates the royalty fee for each NFT and adds it to the total royalty fee amount. Finally, the function adds the royalty fee amount to the net input amount.\n\nIf the base token is not ETH, the function transfers the base tokens from the caller to the contract, and if royalties are to be paid, it transfers the royalty fees to the respective recipients. The function also transfers the protocol fee amount to the protocol fee recipient.\n\nSection Content: /// @notice Buys NFTs from the pool, paying with base tokens from the caller. Then transfers the bought NFTs to the\n    /// caller. The net cost depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the max input amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to buy.\n    /// @param tokenWeights The weights of the NFTs to buy.\n    /// @param proof The merkle proof for the weights of each NFT to buy.\n    /// @return netInputAmount The amount of base tokens spent inclusive of fees.\n    /// @return feeAmount The amount of base tokens spent on fees.\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to buy\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the required net input amount and fee amount\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n        // check that the caller sent 0 ETH if the base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n        virtualNftReserves -= uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer the NFT to the caller\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            if (payRoyalties) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n                // add the royalty fee to the total royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n            }\n        }\n\n        // add the royalty fee amount to the net input aount\n        netInputAmount += royaltyFeeAmount;\n\n        if (baseToken != address(0)) {","metadata":{}}],["32",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a part of a smart contract that deals with the transfer of tokens and payment of fees in a decentralized marketplace. The contract is written in Solidity and uses the ERC20 standard for token transfers.\n\n1. The first line transfers the base token (ERC20) from the caller (msg.sender) to the contract's address. The amount transferred is the net input amount, which is calculated elsewhere in the contract.\n\n2. If the protocol fee is set (greater than 0), the contract transfers the protocol fee amount from the base token to the factory address.\n\n3. If the base token is not set (i.e., it is an ETH transaction), the contract checks if the caller has sent enough ETH to cover the net required input. If not, it reverts the transaction with an \"InvalidEthAmount\" error.\n\n4. If the protocol fee is set for an ETH transaction, the contract transfers the protocol fee amount in ETH to the factory address.\n\n5. If the caller has sent excess ETH, the contract refunds the excess amount back to the caller.\n\n6. If the \"payRoyalties\" flag is set, the contract iterates through the tokenIds array and calculates the royalty fee for each NFT. If the royalty fee is greater than 0 and the recipient address is valid, the contract transfers the royalty fee to the recipient. This is done either in the base token (if set) or in ETH.\n\n7. Finally, the contract emits a \"Buy\" event with the relevant information, including tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, and royaltyFeeAmount. This event can be used by external applications to track and monitor the transactions happening in the marketplace.\n\nSection Content: // transfer the base token from the caller to the contract\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the net required input\n            if (msg.value < netInputAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n        }\n\n        if (payRoyalties) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // emit the buy event\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }","metadata":{}}],["33",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The `sell` function is designed to sell Non-Fungible Tokens (NFTs) into a pool and transfer base tokens to the caller. The NFTs are transferred from the caller to the pool, and the net sale amount depends on the current price, fee rate, and assigned NFT weights. Developers are advised not to call this function directly unless they are aware of the consequences. Instead, they should use a wrapper contract that checks the minimum output amount and reverts if the slippage is too high.\n\nThe function takes the following parameters:\n- `tokenIds`: The token IDs of the NFTs to sell.\n- `tokenWeights`: The weights of the NFTs to sell.\n- `proof`: The Merkle proof for the weights of each NFT to sell.\n- `stolenNftProofs`: The proofs that show each NFT is not stolen.\n\nThe function returns the following values:\n- `netOutputAmount`: The amount of base tokens received inclusive of fees.\n- `feeAmount`: The amount of base tokens to pay in fees.\n\nThe function first calculates the sum of weights of the NFTs to sell and validates the Merkle proof. It then calculates the net output amount and fee amount. If the `useStolenNftOracle` flag is set, the function checks that the NFTs are not stolen using the `IStolenNftOracle` interface.\n\nNext, the function updates the virtual reserves by subtracting the net output amount, protocol fee amount, and fee amount from the virtual base token reserves and adding the weight sum to the virtual NFT reserves.\n\nThe function then transfers each NFT from the caller to the contract address. If the `payRoyalties` flag is set, the function calculates the sale price for each NFT, gets the royalty fee and recipient, and transfers the royalty fee to the recipient if it is greater than 0. The royalty fee amount is then subtracted from the net output amount.\n\nFinally, the function transfers the base tokens (or ETH) to the caller and pays the protocol fee if it is set. The function emits a `Sell` event with the token IDs, token weights, net output amount, fee amount, protocol fee amount, and royalty fee amount.\n\nSection Content: /// @notice Sells NFTs into the pool and transfers base tokens to the caller. NFTs are transferred from the caller\n    /// to the pool. The net sale amount depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the min output amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to sell.\n    /// @param tokenWeights The weights of the NFTs to sell.\n    /// @param proof The merkle proof for the weights of each NFT to sell.\n    /// @param stolenNftProofs The proofs that show each NFT is not stolen.\n    /// @return netOutputAmount The amount of base tokens received inclusive of fees.\n    /// @return feeAmount The amount of base tokens to pay in fees.\n    function sell(\n        uint256[] calldata tokenIds,\n        uint256[] calldata tokenWeights,\n        MerkleMultiProof calldata proof,\n        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error\n    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to sell\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the net output amount and fee amount\n        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n        //  check the nfts are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n        }\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n        virtualNftReserves += uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer each nft from the caller\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n            if (payRoyalties) {\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // tally the royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // subtract the royalty fee amount from the net output amount\n        netOutputAmount -= royaltyFeeAmount;\n\n        if (baseToken == address(0)) {\n            // transfer ETH to the caller\n            msg.sender.safeTransferETH(netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n        } else {\n            // transfer base tokens to the caller\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        }\n\n        // emit the sell event\n        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }","metadata":{}}],["34",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The `change` function allows a user to swap a set of NFTs they own for another set of NFTs in the pool. The user must first approve the pool to transfer their NFTs. The sum of the user's NFT weights must be less than or equal to the sum of the output pool NFTs weights. Additionally, the user must pay a fee based on the net input weight and change fee amount.\n\nThe function takes the following parameters:\n\n- `inputTokenIds`: The token IDs of the NFTs to be swapped.\n- `inputTokenWeights`: The weights of the NFTs to be swapped.\n- `inputProof`: The Merkle proof for the weights of each NFT to be swapped.\n- `stolenNftProofs`: The proofs that show each input NFT is not stolen.\n- `outputTokenIds`: The token IDs of the NFTs to be received.\n- `outputTokenWeights`: The weights of the NFTs to be received.\n- `outputProof`: The Merkle proof for the weights of each NFT to be received.\n\nThe function performs several checks:\n\n1. If the base token is not ETH, it ensures that the caller sent 0 ETH.\n2. If the `useStolenNftOracle` flag is set, it checks that the NFTs are not stolen using the `IStolenNftOracle` interface.\n3. It calculates the sum of weights for the input and output NFTs and validates the Merkle proofs.\n4. It ensures that the input weights are greater than or equal to the output weights.\n5. It calculates the fee amount and protocol fee amount based on the input weight sum.\n\nThe function then performs several interactions:\n\n1. If the base token is not ETH, it transfers the fee amount of base tokens from the caller to the pool and the protocol fee amount to the factory.\n2. If the base token is ETH, it checks that the caller sent enough ETH to cover the fee amount and protocol fee amount, transfers the protocol fee to the factory, and refunds any excess ETH to the caller.\n3. It transfers the input NFTs from the caller to the pool.\n4. It transfers the output NFTs from the pool to the caller.\n\nFinally, the function emits a `Change` event with the input and output token IDs, weights, fee amount, and protocol fee amount.\n\nSection Content: /// @notice Changes a set of NFTs that the caller owns for another set of NFTs in the pool. The caller must approve\n    /// the pool to transfer the NFTs. The sum of the caller's NFT weights must be less than or equal to the sum of the\n    /// output pool NFTs weights. The caller must also pay a fee depending the net input weight and change fee amount.\n    /// @param inputTokenIds The token IDs of the NFTs to change.\n    /// @param inputTokenWeights The weights of the NFTs to change.\n    /// @param inputProof The merkle proof for the weights of each NFT to change.\n    /// @param stolenNftProofs The proofs that show each input NFT is not stolen.\n    /// @param outputTokenIds The token IDs of the NFTs to receive.\n    /// @param outputTokenWeights The weights of the NFTs to receive.\n    /// @param outputProof The merkle proof for the weights of each NFT to receive.\n    function change(\n        uint256[] memory inputTokenIds,\n        uint256[] memory inputTokenWeights,\n        MerkleMultiProof memory inputProof,\n        IStolenNftOracle.Message[] memory stolenNftProofs,\n        uint256[] memory outputTokenIds,\n        uint256[] memory outputTokenWeights,\n        MerkleMultiProof memory outputProof\n    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // check that the caller sent 0 ETH if base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // check that NFTs are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);\n        }\n\n        // fix stack too deep\n        {\n            // calculate the sum of weights for the input nfts\n            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);\n\n            // calculate the sum of weights for the output nfts\n            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);\n\n            // check that the input weights are greater than or equal to the output weights\n            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();\n\n            // calculate the fee amount\n            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        if (baseToken != address(0)) {\n            // transfer the fee amount of base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the fee amount and protocol fee\n            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > feeAmount + protocolFeeAmount) {\n                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);\n            }\n        }\n\n        // transfer the input nfts from the caller\n        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n        }\n\n        // transfer the output nfts to the caller\n        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n        }\n\n        // emit the change event\n        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);\n    }","metadata":{}}],["35",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `execute`, which is designed to execute a transaction from a pool account to a target contract. This function can only be called by the owner of the pool, enabling use cases such as claiming airdrops.\n\nThe function takes two input parameters:\n\n1. `address target`: The address of the target contract to which the transaction will be executed.\n2. `bytes memory data`: The data to be sent to the target contract as part of the transaction.\n\nThe function returns `bytes memory returnData`, which is the return data of the executed transaction.\n\nInside the function, a call is made to the target contract with the specified value and data using the `call` function. The result of the call is stored in two variables: `bool success` and `bytes memory returnData`. If the call is successful, the function returns the `returnData`.\n\nIf the call is not successful and there is an error, the function checks if the `returnData` has a length greater than 0. If so, it uses inline assembly to revert the transaction and bubble up the error message. If the `returnData` length is 0, the function simply reverts the transaction without any error message.\n\nSection Content: /// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\n    /// pool. This allows for use cases such as claiming airdrops.\n    /// @param target The address of the target contract.\n    /// @param data The data to send to the target contract.\n    /// @return returnData The return data of the transaction.\n    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n        // call the target with the value and data\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n        // if the call succeeded return the return data\n        if (success) return returnData;\n\n        // if we got an error bubble up the error message\n        if (returnData.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert();\n        }\n    }","metadata":{}}],["36",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function named `deposit` that allows users to deposit base tokens and NFTs (Non-Fungible Tokens) into a pool. The function takes two parameters: an array of token IDs (`tokenIds`) representing the NFTs to be deposited, and a `baseTokenAmount` representing the amount of base tokens to be deposited.\n\nBefore executing the deposit, the function checks if the base token is ETH (Ethereum) and if the sent ETH amount (`msg.value`) is equal to the specified `baseTokenAmount`. If the base token is not ETH, it checks if the sent ETH amount is 0. If these conditions are not met, the function reverts with an `InvalidEthAmount` error.\n\nThe function then proceeds to transfer the NFTs from the caller to the pool by iterating through the `tokenIds` array and using the `safeTransferFrom` function of the ERC721 standard. If the base token is not ETH, it transfers the base tokens from the caller to the pool using the `safeTransferFrom` function of the ERC20 standard.\n\nFinally, the function emits a `Deposit` event with the deposited `tokenIds` and `baseTokenAmount`.\n\nIt is important to note that the function is marked with a `@dev` comment, warning developers not to call this function directly unless they know what they are doing. Instead, they should use a wrapper contract that checks if the current price is within the desired bounds.\n\nSection Content: /// @notice Deposits base tokens and NFTs into the pool. The caller must approve the pool to transfer their NFTs and\n    /// base tokens.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the current price is within the desired bounds.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param baseTokenAmount The amount of base tokens to deposit.\n    function deposit(uint256[] calldata tokenIds, uint256 baseTokenAmount) public payable {\n        // ~~~ Checks ~~~ //\n\n        // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\n        // is not ETH\n        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\n            revert InvalidEthAmount();\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts from the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        if (baseToken != address(0)) {\n            // transfer the base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        // emit the deposit event\n        emit Deposit(tokenIds, baseTokenAmount);\n    }","metadata":{}}],["37",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function named \"withdraw\" that allows the owner of a pool to withdraw Non-Fungible Tokens (NFTs) and tokens from the pool. The function takes four input parameters: the address of the NFT (_nft), an array of token IDs (tokenIds) representing the NFTs to be withdrawn, the address of the token (token) to be withdrawn, and the amount of tokens (tokenAmount) to be withdrawn.\n\nThe function is marked as \"public\" and can only be called by the owner of the pool, as indicated by the \"onlyOwner\" modifier.\n\nThe function starts by transferring the specified NFTs to the caller (msg.sender) using a for loop that iterates through the tokenIds array. It does this by calling the \"safeTransferFrom\" function of the ERC721 contract, passing the NFT address, the caller's address, and the current token ID in the loop.\n\nNext, the function checks if the token address is equal to the zero address (address(0)). If it is, the function transfers the specified amount of Ether (ETH) to the caller using the \"safeTransferETH\" function. If the token address is not the zero address, the function transfers the specified amount of tokens to the caller using the \"transfer\" function of the ERC20 contract.\n\nFinally, the function emits a \"Withdraw\" event with the NFT address, token IDs array, token address, and token amount as its parameters. This event can be used by external applications to track and monitor the withdrawal of NFTs and tokens from the pool.\n\nSection Content: /// @notice Withdraws NFTs and tokens from the pool. Can only be called by the owner of the pool.\n    /// @param _nft The address of the NFT.\n    /// @param tokenIds The token IDs of the NFTs to withdraw.\n    /// @param token The address of the token to withdraw.\n    /// @param tokenAmount The amount of tokens to withdraw.\n    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts to the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        if (token == address(0)) {\n            // transfer the ETH to the caller\n            msg.sender.safeTransferETH(tokenAmount);\n        } else {\n            // transfer the tokens to the caller\n            ERC20(token).transfer(msg.sender, tokenAmount);\n        }\n\n        // emit the withdraw event\n        emit Withdraw(_nft, tokenIds, token, tokenAmount);\n    }","metadata":{}}],["38",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function called `setVirtualReserves` that sets the virtual base token reserves and virtual NFT (Non-Fungible Token) reserves for a pool. This function can only be called by the owner of the pool. The parameters of this function are `newVirtualBaseTokenReserves` and `newVirtualNftReserves`, which represent the new virtual base token reserves and virtual NFT reserves, respectively. These parameters affect the price and liquidity depth of the pool.\n\nThe function is defined with the `public` visibility specifier, meaning it can be called from any external contract or account. The `onlyOwner` modifier is used to restrict access to this function, ensuring that only the owner of the pool can call it.\n\nInside the function, the virtual base token reserves and virtual NFT reserves are updated with the new values provided as arguments. The new values are assigned to the `virtualBaseTokenReserves` and `virtualNftReserves` variables, respectively.\n\nAfter updating the reserves, the function emits an event called `SetVirtualReserves` with the new virtual base token reserves and virtual NFT reserves as its arguments. This event allows external entities, such as front-end applications or other smart contracts, to listen for changes in the virtual reserves and react accordingly.\n\nSection Content: /// @notice Sets the virtual base token reserves and virtual NFT reserves. Can only be called by the owner of the\n    /// pool. These parameters affect the price and liquidity depth of the pool.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    function setVirtualReserves(uint128 newVirtualBaseTokenReserves, uint128 newVirtualNftReserves) public onlyOwner {\n        // set the virtual base token reserves and virtual nft reserves\n        virtualBaseTokenReserves = newVirtualBaseTokenReserves;\n        virtualNftReserves = newVirtualNftReserves;\n\n        // emit the set virtual reserves event\n        emit SetVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n    }","metadata":{}}],["39",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `setMerkleRoot` that sets the Merkle root for a specific use case, which is to validate the weights of Non-Fungible Tokens (NFTs). The function takes a single input parameter, `newMerkleRoot`, which is a 32-byte hash representing the new Merkle root.\n\nThe function is marked as `public`, meaning it can be called by any external entity, and it has a function modifier `onlyOwner`, which restricts its execution to only the owner of the pool. This ensures that only the authorized owner can update the Merkle root.\n\nInside the function, the new Merkle root is assigned to the state variable `merkleRoot`. After updating the Merkle root, an event named `SetMerkleRoot` is emitted with the new Merkle root as its argument. This event allows external entities, such as front-end applications or other smart contracts, to listen for changes in the Merkle root and react accordingly.\n\nIn summary, the `setMerkleRoot` function is a public function that can only be called by the owner of the pool, and it updates the Merkle root used for validating NFT weights. The function takes a new Merkle root as input, assigns it to the state variable, and emits an event to notify external entities of the change.\n\nSection Content: /// @notice Sets the merkle root. Can only be called by the owner of the pool. The merkle root is used to validate\n    /// the NFT weights.\n    /// @param newMerkleRoot The new merkle root.\n    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        // set the merkle root\n        merkleRoot = newMerkleRoot;\n\n        // emit the set merkle root event\n        emit SetMerkleRoot(newMerkleRoot);\n    }","metadata":{}}],["40",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function called `setFeeRate` that sets the fee rate for a pool. This function can only be called by the owner of the pool. The fee rate is used to calculate the fee amount when swapping or changing NFTs (Non-Fungible Tokens). The fee rate is expressed in basis points, where 1 basis point is equal to 1/100th of a percent. For instance, 10,000 basis points represent 100%, 200 basis points represent 2%, and 1 basis point represents 0.01%.\n\nThe function takes a single parameter, `newFeeRate`, which is the new fee rate in basis points. Inside the function, there is a check to ensure that the new fee rate is less than 50% (5,000 basis points). If the new fee rate is greater than 50%, the function reverts with a `FeeRateTooHigh` error.\n\nIf the new fee rate is valid, the function sets the fee rate to the new value and emits an event called `SetFeeRate` with the new fee rate as its parameter. This event can be used by external systems to track changes in the fee rate.\n\nSection Content: /// @notice Sets the fee rate. Can only be called by the owner of the pool. The fee rate is used to calculate the\n    /// fee amount when swapping or changing NFTs. The fee rate is in basis points (1/100th of a percent). For example,\n    /// 10_000 == 100%, 200 == 2%, 1 == 0.01%.\n    /// @param newFeeRate The new fee rate (in basis points)\n    function setFeeRate(uint16 newFeeRate) public onlyOwner {\n        // check that the fee rate is less than 50%\n        if (newFeeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the fee rate\n        feeRate = newFeeRate;\n\n        // emit the set fee rate event\n        emit SetFeeRate(newFeeRate);\n    }","metadata":{}}],["41",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `setPayRoyalties` that is used to set the pay royalties flag in a smart contract. This function can only be called by the owner of the pool, as indicated by the `onlyOwner` modifier.\n\nThe function takes a single input parameter, `newPayRoyalties`, which is a boolean value representing the new pay royalties flag. When royalties are enabled (i.e., `newPayRoyalties` is set to `true`), the pool will pay royalties when buying or selling NFTs (Non-Fungible Tokens).\n\nInside the function, the `payRoyalties` state variable is updated with the value of `newPayRoyalties`. After updating the state variable, an event named `SetPayRoyalties` is emitted with the new pay royalties flag as its argument. This event can be used by external entities to listen for changes in the pay royalties flag and take appropriate actions accordingly.\n\nIn summary, the `setPayRoyalties` function is a public function that allows the owner of the pool to enable or disable the payment of royalties when buying or selling NFTs in the pool. The function updates the `payRoyalties` state variable and emits an event to notify external entities of the change.\n\nSection Content: /// @notice Sets the pay royalties flag. Can only be called by the owner of the pool. If royalties are enabled then\n    /// the pool will pay royalties when buying or selling NFTs.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setPayRoyalties(bool newPayRoyalties) public onlyOwner {\n        // set the pay royalties flag\n        payRoyalties = newPayRoyalties;\n\n        // emit the set pay royalties event\n        emit SetPayRoyalties(newPayRoyalties);\n    }","metadata":{}}],["42",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function called `setAllParameters` in a smart contract, which updates multiple parameter settings at once. The function takes six input parameters:\n\n1. `newVirtualBaseTokenReserves`: A uint128 value representing the new virtual base token reserves.\n2. `newVirtualNftReserves`: A uint128 value representing the new virtual NFT (Non-Fungible Token) reserves.\n3. `newMerkleRoot`: A bytes32 value representing the new Merkle root.\n4. `newFeeRate`: A uint16 value representing the new fee rate in basis points.\n5. `newUseStolenNftOracle`: A boolean value representing the new flag for using a stolen NFT oracle.\n6. `newPayRoyalties`: A boolean value representing the new flag for paying royalties.\n\nInside the function, the following methods are called to update the respective parameters:\n\n1. `setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves)`: Updates the virtual base token and NFT reserves with the new values provided.\n2. `setMerkleRoot(newMerkleRoot)`: Updates the Merkle root with the new value provided.\n3. `setFeeRate(newFeeRate)`: Updates the fee rate with the new value provided.\n4. `setUseStolenNftOracle(newUseStolenNftOracle)`: Updates the flag for using a stolen NFT oracle with the new value provided.\n5. `setPayRoyalties(newPayRoyalties)`: Updates the flag for paying royalties with the new value provided.\n\nThis function allows for efficient and simultaneous updating of multiple parameter settings in the smart contract.\n\nSection Content: /// @notice Updates all parameter settings in one go.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    /// @param newMerkleRoot The new merkle root.\n    /// @param newFeeRate The new fee rate (in basis points)\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setAllParameters(\n        uint128 newVirtualBaseTokenReserves,\n        uint128 newVirtualNftReserves,\n        bytes32 newMerkleRoot,\n        uint16 newFeeRate,\n        bool newUseStolenNftOracle,\n        bool newPayRoyalties\n    ) public {\n        setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n        setMerkleRoot(newMerkleRoot);\n        setFeeRate(newFeeRate);\n        setUseStolenNftOracle(newUseStolenNftOracle);\n        setPayRoyalties(newPayRoyalties);\n    }","metadata":{}}],["43",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function called `flashLoan` that executes a flash loan in a smart contract. The function takes four parameters: `receiver`, `token`, `tokenId`, and `data`. The `receiver` is the address of the entity receiving the flash loan, `token` is the address of the Non-Fungible Token (NFT) contract, `tokenId` is the ID of the NFT, and `data` is any additional data to be passed to the receiver.\n\nThe function is marked as `external` and `payable`, meaning it can be called from outside the contract and can receive Ether (ETH) as payment. The function returns a boolean value indicating whether the flash loan was successful or not.\n\nFirst, the function checks if the NFT is available for a flash loan using the `availableForFlashLoan` function. If it's not available, the function reverts with a `NotAvailableForFlashLoan` error.\n\nNext, the function calculates the fee for the flash loan using the `flashFee` function. If the base token is ETH (i.e., `baseToken` is the zero address), the function checks if the caller sent enough ETH to cover the fee. If not, it reverts with an `InvalidEthAmount` error.\n\nThe function then transfers the NFT to the borrower using the `safeTransferFrom` function of the ERC721 contract. After that, it calls the `onFlashLoan` function of the borrower's contract, passing the necessary parameters, and checks if the flash loan was successful by comparing the returned value with the expected hash of the \"ERC3156FlashBorrower.onFlashLoan\" string.\n\nIf the flash loan was not successful, the function reverts with a `FlashLoanFailed` error. If it was successful, the function transfers the NFT back from the borrower to the contract using the `safeTransferFrom` function of the ERC721 contract.\n\nFinally, the function transfers the fee from the borrower to the contract. If the base token is not ETH (i.e., `baseToken` is not the zero address), it uses the `transferFrom` function of the ERC20 contract to transfer the fee. The function then returns the `success` boolean value, indicating the outcome of the flash loan.\n\nSection Content: /// @notice Executes a flash loan.\n    /// @param receiver The receiver of the flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @param data The data to pass to the receiver.\n    /// @return success Whether or not the flash loan was successful.\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }","metadata":{}}],["44",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function called `sumWeightsAndValidateProof` that takes three input parameters: an array of token IDs (`tokenIds`), an array of corresponding token weights (`tokenWeights`), and a Merkle multi-proof object (`proof`). The function's purpose is to calculate the sum of the weights of each NFT (Non-Fungible Token) and validate that the weights are correct by verifying the provided Merkle proof.\n\nInitially, the function checks if the `merkleRoot` is not set (i.e., equal to `bytes32(0)`). If this is the case, it returns the product of the number of token IDs and 1e18, effectively setting the weight of each NFT to be 1e18.\n\nIf the `merkleRoot` is set, the function initializes a variable `sum` to store the sum of the token weights and creates a new array `leafs` to store the Merkle proof leaves. It then iterates through the `tokenIds` array, and for each token ID, it creates a leaf by hashing the concatenated result of the hashed encoding of the token ID and its corresponding weight. The function also adds the token weight to the `sum` variable.\n\nAfter iterating through all the token IDs, the function verifies the Merkle proof using the `MerkleProofLib.verifyMultiProof` function, which takes the proof, merkle root, leafs, and proof flags as input parameters. If the Merkle proof is not valid, the function reverts with an `InvalidMerkleProof` error.\n\nFinally, if the Merkle proof is valid, the function returns the sum of the token weights.\n\nSection Content: /// @notice Sums the weights of each NFT and validates that the weights are correct by verifying the merkle proof.\n    /// @param tokenIds The token IDs of the NFTs to sum the weights for.\n    /// @param tokenWeights The weights of each NFT in the token IDs array.\n    /// @param proof The merkle proof for the weights of each NFT.\n    /// @return sum The sum of the weights of each NFT.\n    function sumWeightsAndValidateProof(\n        uint256[] memory tokenIds,\n        uint256[] memory tokenWeights,\n        MerkleMultiProof memory proof\n    ) public view returns (uint256) {\n        // if the merkle root is not set then set the weight of each nft to be 1e18\n        if (merkleRoot == bytes32(0)) {\n            return tokenIds.length * 1e18;\n        }\n\n        uint256 sum;\n        bytes32[] memory leafs = new bytes32[](tokenIds.length);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // create the leaf for the merkle proof\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n\n            // sum each token weight\n            sum += tokenWeights[i];\n        }\n\n        // validate that the weights are valid against the merkle proof\n        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\n            revert InvalidMerkleProof();\n        }\n\n        return sum;\n    }","metadata":{}}],["45",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function called `buyQuote` in a smart contract, which calculates the required input amount of base tokens needed to buy a specified amount of NFTs (Non-Fungible Tokens), along with the associated fee amounts.\n\nThe function takes a single input parameter, `outputAmount`, which represents the desired amount of NFTs to buy, multiplied by 1e18 for precision. It returns three values: `netInputAmount`, `feeAmount`, and `protocolFeeAmount`.\n\nThe function calculates the input amount using the xy=k invariant, a formula used in automated market makers (AMMs) to maintain a constant product of token reserves. The input amount is calculated by multiplying the `outputAmount` by the `virtualBaseTokenReserves` and dividing by the difference between `virtualNftReserves` and `outputAmount`. The result is rounded up by 1 wei for precision.\n\nNext, the function calculates the protocol fee amount by multiplying the input amount by the `protocolFeeRate` obtained from the Factory contract and dividing by 10,000. Similarly, the fee amount is calculated by multiplying the input amount by the `feeRate` and dividing by 10,000.\n\nFinally, the function calculates the net input amount by adding the input amount, fee amount, and protocol fee amount. The function then returns the net input amount, fee amount, and protocol fee amount as output.\n\nSection Content: /// @notice Returns the required input of buying a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param outputAmount The amount of NFTs to buy multiplied by 1e18.\n    /// @return netInputAmount The required input amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function buyQuote(uint256 outputAmount)\n        public\n        view\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the input amount based on xy=k invariant and round up by 1 wei\n        uint256 inputAmount =\n            FixedPointMathLib.mulDivUp(outputAmount, virtualBaseTokenReserves, (virtualNftReserves - outputAmount));\n\n        protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = inputAmount * feeRate / 10_000;\n        netInputAmount = inputAmount + feeAmount + protocolFeeAmount;\n    }","metadata":{}}],["46",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The `sellQuote` function is a public view function that returns the output amount of selling a given amount of NFTs, inclusive of the fee, which depends on the currently set fee rate. It takes one input parameter, `inputAmount`, which represents the amount of NFTs to sell multiplied by 1e18. The function returns three values: `netOutputAmount`, `feeAmount`, and `protocolFeeAmount`.\n\nThe function first calculates the output amount based on the xy=k invariant, using the formula `outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount)`. This calculation determines the amount of base tokens that will be received when selling the specified amount of NFTs.\n\nNext, the function calculates the protocol fee amount by multiplying the output amount by the protocol fee rate obtained from the factory contract, and dividing the result by 10,000. The formula for this calculation is `protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000`.\n\nThe fee amount is then calculated by multiplying the output amount by the fee rate and dividing the result by 10,000. The formula for this calculation is `feeAmount = outputAmount * feeRate / 10_000`.\n\nFinally, the net output amount is calculated by subtracting the fee amount and the protocol fee amount from the output amount. The formula for this calculation is `netOutputAmount = outputAmount - feeAmount - protocolFeeAmount`.\n\nSection Content: /// @notice Returns the output amount of selling a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param inputAmount The amount of NFTs to sell multiplied by 1e18.\n    /// @return netOutputAmount The output amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function sellQuote(uint256 inputAmount)\n        public\n        view\n        returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the output amount based on xy=k invariant\n        uint256 outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount);\n\n        protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = outputAmount * feeRate / 10_000;\n        netOutputAmount = outputAmount - feeAmount - protocolFeeAmount;\n    }","metadata":{}}],["47",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The `changeFeeQuote` function calculates the fee required to change a given amount of Non-Fungible Tokens (NFTs) based on the current `changeFee`. The function takes `inputAmount` as a parameter, which represents the amount of NFTs to change multiplied by 1e18. It returns two values: `feeAmount` and `protocolFeeAmount`.\n\nFirst, the function calculates the exponent based on the base token decimals. If the base token is zero, the exponent is set to 14 (18 - 4). Otherwise, the exponent is calculated as the difference between the base token's decimals and 4. This is done to maintain 4 decimals of precision in the fee calculation.\n\nNext, the function calculates the fee per NFT by multiplying the `changeFee` with 10 raised to the power of the exponent. This ensures that the fee per NFT has the same precision as the `changeFee`.\n\nThe `feeAmount` is then calculated by multiplying the `inputAmount` with the fee per NFT and dividing the result by 1e18. This scales the fee amount according to the input amount of NFTs.\n\nFinally, the `protocolFeeAmount` is calculated by multiplying the `feeAmount` with the protocol fee rate (obtained from the Factory contract) and dividing the result by 10,000. This calculates the portion of the fee that goes to the protocol.\n\nIn summary, the `changeFeeQuote` function calculates the fee and protocol fee amounts for changing a given amount of NFTs based on the current `changeFee` and the base token decimals.\n\nSection Content: /// @notice Returns the fee required to change a given amount of NFTs. The fee is based on the current changeFee\n    /// (which contains 4 decimals of precision) multiplied by some exponent depending on the base token decimals.\n    /// @param inputAmount The amount of NFTs to change multiplied by 1e18.\n    /// @return feeAmount The fee amount.\n    /// @return protocolFeeAmount The protocol fee amount.\n    function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n        uint256 feePerNft = changeFee * 10 ** exponent;\n\n        feeAmount = inputAmount * feePerNft / 1e18;\n        protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n    }","metadata":{}}],["48",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `price()` that returns the price of a pool with 18 decimals of accuracy. The function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe function calculates the price by first determining the exponent to be used for scaling the result. This is done by checking if the `baseToken` address is equal to the zero address (i.e., the Ethereum native currency, Ether). If it is, the exponent is set to 18, otherwise, it is set to 36 minus the number of decimals of the `baseToken` as defined in its ERC20 contract.\n\nNext, the function calculates the price by multiplying the `virtualBaseTokenReserves` by 10 raised to the power of the previously calculated exponent. This result is then divided by the `virtualNftReserves` to obtain the final price.\n\nFinally, the function returns the calculated price as a `uint256` value.\n\nSection Content: /// @notice Returns the price of the pool to 18 decimals of accuracy.\n    /// @return price The price of the pool.\n    function price() public view returns (uint256) {\n        // ensure that the exponent is always to 18 decimals of accuracy\n        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals());\n        return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\n    }","metadata":{}}],["49",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a Solidity function named `flashFee` that is part of a smart contract. This function is responsible for returning the fee required to perform a flash swap of a specific Non-Fungible Token (NFT).\n\nThe function takes two input parameters:\n\n1. `address`: This is the Ethereum address associated with the NFT.\n2. `uint256`: This is an unsigned integer representing the unique identifier of the NFT.\n\nThe function is marked as `public`, which means it can be called by any external entity, and `view`, which indicates that it does not modify the state of the contract. The `view` keyword ensures that the function only reads data from the blockchain and does not make any changes.\n\nThe function returns a single output parameter:\n\n1. `uint256 feeAmount`: This is an unsigned integer representing the fee amount required to perform the flash swap of the given NFT.\n\nInside the function, the fee amount is obtained from a variable named `changeFee`. This variable is likely defined elsewhere in the smart contract and represents the current fee for flash swaps. The function simply returns the value of this variable as the fee amount.\n\nIn summary, the `flashFee` function provides a way for external entities to query the fee required to perform a flash swap of a specific NFT by providing the NFT's associated address and unique identifier. The function returns the fee amount as an unsigned integer.\n\nSection Content: /// @notice Returns the fee required to flash swap a given NFT.\n    /// @return feeAmount The fee amount.\n    function flashFee(address, uint256) public view returns (uint256) {\n        return changeFee;\n    }","metadata":{}}],["50",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a part of a smart contract written in Solidity language for the Ethereum blockchain. It defines a function called `flashFeeToken()` which is a public and view function, meaning it can be called by anyone and does not modify the state of the contract.\n\nThe purpose of this function is to return the address of the token that is used to pay the flash fee. In this specific implementation, the function simply returns the value of a variable called `baseToken`. The `baseToken` variable is assumed to be defined elsewhere in the contract and holds the address of the token used for paying the flash fee.\n\nThe function signature specifies that it returns a value of type `address`, which is a 20-byte value representing the address of an Ethereum account or a smart contract. In this case, it represents the address of the token contract used for paying the flash fee.\n\nSection Content: /// @notice Returns the token that is used to pay the flash fee.\n    function flashFeeToken() public view returns (address) {\n        return baseToken;\n    }","metadata":{}}],["51",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function definition in a smart contract, written in Solidity programming language. The function is named `availableForFlashLoan` and it is used to determine if a specific Non-Fungible Token (NFT) is available for a flash loan.\n\nThe function takes two input parameters:\n\n1. `address token`: This parameter represents the address of the NFT contract. It is of type `address`, which is a 160-bit identifier for a specific Ethereum account.\n\n2. `uint256 tokenId`: This parameter represents the unique identifier of the NFT within the contract. It is of type `uint256`, which is an unsigned 256-bit integer.\n\nThe function is marked as `public`, meaning it can be called from any external contract or account, and `view`, which indicates that it does not modify the state of the contract. This allows the function to be called without incurring any gas costs.\n\nThe function returns a single output:\n\n1. `bool available`: This is a boolean value that indicates whether the specified NFT is available for a flash loan or not.\n\nThe function works by querying the state of the NFT contract and checking if the given NFT (identified by its `tokenId`) is available for a flash loan. The result is then returned as a boolean value.\n\nSection Content: /// @notice Returns whether or not an NFT is available for a flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @return available Whether or not the NFT is available for a flash loan.\n    function availableForFlashLoan(address token, uint256 tokenId) public view returns (bool) {","metadata":{}}],["52",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is a function that checks if a specific Non-Fungible Token (NFT) is owned by the current smart contract. It does this by interacting with the ERC721 standard, which is a widely used standard for creating and managing NFTs on the Ethereum blockchain.\n\nThe function first attempts to call the `ownerOf` function from the ERC721 smart contract, which is identified by the `token` address. The `ownerOf` function takes a `tokenId` as its argument, which is a unique identifier for the NFT within the ERC721 contract. The `ownerOf` function returns the address of the current owner of the NFT.\n\nThe function then checks if the returned owner address (`result`) is equal to the address of the current smart contract (`address(this)`). If the addresses match, it means that the NFT is owned by the current smart contract, and the function returns `true`. If the addresses do not match, the function returns `false`, indicating that the NFT is not owned by the current smart contract.\n\nAdditionally, the function is wrapped in a `try-catch` block. This is used to handle any errors that may occur while calling the `ownerOf` function from the ERC721 contract. If an error occurs, the catch block is executed, and the function returns `false`. This ensures that the function does not throw an error and instead provides a safe way to determine if the NFT is owned by the current smart contract.\n\nSection Content: // return if the NFT is owned by this contract\n        try ERC721(token).ownerOf(tokenId) returns (address result) {\n            return result == address(this);\n        } catch {\n            return false;\n        }\n    }","metadata":{}}],["53",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given content is a function definition in a smart contract, written in Solidity programming language, for a blockchain-based application. The function is named `_getRoyalty` and is used to calculate the royalty fee and the recipient address for a given Non-Fungible Token (NFT) and its sale price. The function fetches the royalty information from the Manifold registry.\n\nThe function takes two input parameters:\n\n1. `tokenId`: A `uint256` data type representing the unique identifier of the NFT.\n2. `salePrice`: A `uint256` data type representing the sale price of the NFT.\n\nThe function returns two output values:\n\n1. `royaltyFee`: A `uint256` data type representing the royalty fee to be paid.\n2. `recipient`: An `address` data type representing the address to which the royalty fee should be paid.\n\nThe function is marked as `internal`, which means it can only be called from within the same contract or contracts derived from it. It is also marked as `view`, which indicates that it does not modify the state of the contract and can be executed without incurring any gas costs.\n\nInside the function, the royalty lookup address is fetched by calling the `getRoyaltyLookupAddress` function of the `IRoyaltyRegistry` interface, passing the `nft` address as an argument. The `IRoyaltyRegistry` interface is a contract that defines the functions for interacting with the Manifold registry, which stores the royalty information for NFTs.\n\nSection Content: /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function _getRoyalty(uint256 tokenId, uint256 salePrice)\n        internal\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);","metadata":{}}],["54",{"pageContent":"File Context: The Private Pool, a customizable NFT Automated Market Maker smart contract, facilitates trading, depositing, and withdrawing of NFTs and base tokens while earning fees, and offers advanced features like concentrated liquidity, custom fee rates, stolen NFT filtering, and support for royalties and flash loans.\n\nSection Summary: The given code snippet is written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. It checks if a specific contract supports the ERC-2981 interface, which is a standard for handling royalty payments in Non-Fungible Tokens (NFTs).\n\n1. First, the code checks if the contract at the `lookupAddress` supports the ERC-2981 interface by calling the `supportsInterface` function with the interface ID of ERC-2981. The interface ID is obtained using `type(IERC2981).interfaceId`. If the contract supports the interface, the code proceeds to the next step.\n\n2. The royalty information for a specific token (identified by `tokenId`) is retrieved by calling the `royaltyInfo` function of the ERC-2981 contract at the `lookupAddress`. The function returns two values: the recipient address (`recipient`) and the royalty fee (`royaltyFee`) as a percentage of the sale price (`salePrice`).\n\n3. The code then checks if the calculated royalty fee is greater than the sale price of the token. If it is, the transaction is reverted with an `InvalidRoyaltyFee` error message. This ensures that the royalty fee does not exceed the actual sale price of the token.\n\nIn summary, this code snippet is used to verify if a contract supports the ERC-2981 royalty standard, retrieve the royalty information for a specific NFT, and ensure that the royalty fee does not exceed the token's sale price.\n\nSection Content: if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}","metadata":{}}],["55",{"pageContent":"File Context: The PrivatePoolMetadata contract creates NFT metadata for private pools by incorporating functions that provide tokenURI, JSON-encoded attributes, and SVG images, while utilizing libraries like Strings, Base64, ERC20, and ERC721.\n\nSection Summary: The Private Pool Metadata contract, authored by out.eth (@outdoteth), is designed to generate Non-Fungible Token (NFT) metadata for private pools. NFTs are unique digital assets that can represent various types of content, such as art, music, or virtual real estate. Metadata is the information that describes the attributes and characteristics of these NFTs.\n\nIn this contract, the primary purpose is to create and manage metadata for private pools, which are exclusive groups or communities within a blockchain ecosystem. These private pools may have specific requirements for membership, such as holding a certain amount of tokens or possessing a particular NFT.\n\nThe contract begins with the declaration of the `PrivatePoolMetadata` contract, which inherits from the base contract. The contract includes various functions and data structures to manage the metadata generation process.\n\nKey components of the contract include:\n\n1. Data Structures: The contract defines several data structures to store information about the private pools and their associated metadata. These structures include mappings to store the pool's metadata, as well as arrays to keep track of the pool's members and their respective NFTs.\n\n2. Constructor: The constructor function initializes the contract by setting the initial values for the contract's variables and data structures. This includes the contract's owner, the base URI for the metadata, and any other necessary parameters.\n\n3. Metadata Generation: The contract includes functions to generate metadata for the private pools. This process involves creating a unique identifier for each pool, as well as generating a JSON object that contains the pool's attributes and characteristics. The metadata is then stored in the contract's data structures and can be accessed by the pool's members.\n\n4. Access Control: The contract includes various access control mechanisms to ensure that only authorized users can interact with the contract's functions. This includes modifiers to restrict access to the contract's owner, as well as functions to add or remove members from the private pools.\n\n5. Utility Functions: The contract also includes several utility functions to help manage the metadata generation process. These functions include methods to retrieve the metadata for a specific pool, as well as functions to update the base URI for the metadata.\n\nIn summary, the Private Pool Metadata contract is a specialized contract designed to generate and manage NFT metadata for private pools within a blockchain ecosystem. The contract includes various data structures, functions, and access control mechanisms to ensure the secure and efficient generation of metadata for these exclusive communities.\n\nSection Content: /// @title Private Pool Metadata\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to generate NFT metadata for private pools.\ncontract PrivatePoolMetadata {","metadata":{}}],["56",{"pageContent":"File Context: The PrivatePoolMetadata contract creates NFT metadata for private pools by incorporating functions that provide tokenURI, JSON-encoded attributes, and SVG images, while utilizing libraries like Strings, Base64, ERC20, and ERC721.\n\nSection Summary: The given code snippet is a Solidity function named `tokenURI` that takes a single input parameter, `tokenId`, of type `uint256`. The function is marked as `public` and `view`, meaning it can be called by anyone and does not modify the contract's state. The function returns a `string` in memory.\n\nThe purpose of this function is to return the tokenURI for a private pool with its metadata. The metadata is constructed using the `abi.encodePacked` function, which concatenates the input arguments into a single bytes array. The metadata includes the following properties:\n\n1. \"name\": A string that concatenates \"Private Pool \" with the `tokenId` converted to a string using the `Strings.toString` function.\n2. \"description\": A static string \"Caviar private pool AMM position.\"\n3. \"image\": A data URI that represents an SVG image encoded in base64 format. The SVG image is generated by calling the `svg` function with the `tokenId` as its argument, and the result is encoded using the `Base64.encode` function.\n4. \"attributes\": An array of attributes obtained by calling the `attributes` function with the `tokenId` as its argument.\n\nFinally, the metadata bytes array is converted to a JSON string and encoded in base64 format using the `Base64.encode` function. The resulting string is concatenated with the \"data:application/json;base64,\" prefix to form the final tokenURI, which is returned by the function.\n\nSection Content: /// @notice Returns the tokenURI for a pool with it's metadata.\n    /// @param tokenId The private pool's token ID.\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // forgefmt: disable-next-item\n        bytes memory metadata = abi.encodePacked(\n            \"{\",\n                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',\n                '\"description\": \"Caviar private pool AMM position.\",',\n                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',\n                '\"attributes\": [',\n                    attributes(tokenId),\n                \"]\",\n            \"}\"\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }","metadata":{}}],["57",{"pageContent":"File Context: The PrivatePoolMetadata contract creates NFT metadata for private pools by incorporating functions that provide tokenURI, JSON-encoded attributes, and SVG images, while utilizing libraries like Strings, Base64, ERC20, and ERC721.\n\nSection Summary: The given code snippet is a Solidity function named `attributes` that returns the attributes of a private pool encoded as a JSON string. The function takes a single input parameter, `tokenId`, which represents the private pool's token ID.\n\nFirst, the function creates a `PrivatePool` object named `privatePool` by casting the `tokenId` to an address and making it payable. Then, it initializes a bytes array named `_attributes` and encodes the attributes of the private pool using the `abi.encodePacked` function. The attributes include:\n\n1. Pool address: The address of the private pool.\n2. Base token: The address of the base token in the private pool.\n3. NFT: The address of the NFT in the private pool.\n4. Virtual base token reserves: The virtual reserves of the base token in the private pool.\n5. Virtual NFT reserves: The virtual reserves of the NFT in the private pool.\n6. Fee rate (bps): The fee rate of the private pool in basis points.\n7. NFT balance: The balance of the NFT in the private pool.\n8. Base token balance: The balance of the base token in the private pool.\n\nEach attribute is encoded using the `trait` function, which takes two parameters: the attribute name and its value. The attributes are separated by commas to form a JSON string.\n\nFinally, the function returns the `_attributes` bytes array as a string.\n\nSection Content: /// @notice Returns the attributes for a pool encoded as json.\n    /// @param tokenId The private pool's token ID.\n    function attributes(uint256 tokenId) public view returns (string memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // forgefmt: disable-next-item\n        bytes memory _attributes = abi.encodePacked(\n            trait(\"Pool address\", Strings.toHexString(address(privatePool))), ',',\n            trait(\"Base token\", Strings.toHexString(privatePool.baseToken())), ',',\n            trait(\"NFT\", Strings.toHexString(privatePool.nft())), ',',\n            trait(\"Virtual base token reserves\",Strings.toString(privatePool.virtualBaseTokenReserves())), ',',\n            trait(\"Virtual NFT reserves\", Strings.toString(privatePool.virtualNftReserves())), ',',\n            trait(\"Fee rate (bps): \", Strings.toString(privatePool.feeRate())), ',',\n            trait(\"NFT balance\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool)))), ',',\n            trait(\"Base token balance\",  Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))))\n        );\n\n        return string(_attributes);\n    }","metadata":{}}],["58",{"pageContent":"File Context: The PrivatePoolMetadata contract creates NFT metadata for private pools by incorporating functions that provide tokenURI, JSON-encoded attributes, and SVG images, while utilizing libraries like Strings, Base64, ERC20, and ERC721.\n\nSection Summary: The given code snippet is a Solidity function named `svg` that takes a `tokenId` as input and returns an SVG image in bytes format. The function is designed to generate an SVG image containing information about a private pool in an Automated Market Maker (AMM) system called Caviar.\n\nThe function first creates a `PrivatePool` object using the provided `tokenId`. It then constructs the SVG image in three separate scopes to avoid stack too deep errors. The SVG image is built using the `abi.encodePacked` function, which concatenates the input arguments into a single bytes array.\n\nIn the first scope, the SVG image is initialized with a black background, white fill, and a serif font. It includes the following text elements:\n1. \"Caviar AMM private pool position\"\n2. \"Private pool: \" followed by the hexadecimal representation of the `privatePool` address\n3. \"Base token: \" followed by the hexadecimal representation of the `baseToken` address\n4. \"NFT: \" followed by the hexadecimal representation of the `nft` address\n\nIn the second scope, the SVG image is updated with the following text elements:\n1. \"Virtual base token reserves: \" followed by the string representation of the `virtualBaseTokenReserves` value\n2. \"Virtual NFT reserves: \" followed by the string representation of the `virtualNftReserves` value\n3. \"Fee rate (bps): \" followed by the string representation of the `feeRate` value\n\nIn the third scope, the SVG image is finalized with the following text elements:\n1. \"NFT balance: \" followed by the string representation of the NFT balance of the `privatePool` address\n2. \"Base token balance: \" followed by the string representation of the base token balance of the `privatePool` address\n\nFinally, the function returns the constructed SVG image in bytes format.\n\nSection Content: /// @notice Returns an svg image for a pool.\n    /// @param tokenId The private pool's token ID.\n    function svg(uint256 tokenId) public view returns (bytes memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // break up svg building into multiple scopes to avoid stack too deep errors\n        bytes memory _svg;\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:black;fill:white;font-family:serif;\">',\n                    '<text x=\"24px\" y=\"24px\" font-size=\"12\">',\n                        \"Caviar AMM private pool position\",\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"48px\" font-size=\"12\">',\n                        \"Private pool: \", Strings.toHexString(address(privatePool)),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"72px\" font-size=\"12\">',\n                        \"Base token: \", Strings.toHexString(privatePool.baseToken()),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"96px\" font-size=\"12\">',\n                        \"NFT: \", Strings.toHexString(privatePool.nft()),\n                    \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"120px\" font-size=\"12\">',\n                    \"Virtual base token reserves: \", Strings.toString(privatePool.virtualBaseTokenReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"144px\" font-size=\"12\">',\n                    \"Virtual NFT reserves: \", Strings.toString(privatePool.virtualNftReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"168px\" font-size=\"12\">',\n                    \"Fee rate (bps): \", Strings.toString(privatePool.feeRate()),\n                \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg, \n                    '<text x=\"24px\" y=\"192px\" font-size=\"12\">',\n                        \"NFT balance: \", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"216px\" font-size=\"12\">',\n                        \"Base token balance: \", Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                \"</svg>\"\n            );\n        }\n\n        return _svg;\n    }","metadata":{}}],["59",{"pageContent":"File Context: The PrivatePoolMetadata contract creates NFT metadata for private pools by incorporating functions that provide tokenURI, JSON-encoded attributes, and SVG images, while utilizing libraries like Strings, Base64, ERC20, and ERC721.\n\nSection Summary: The given code snippet is a function named `trait` written in Solidity, a programming language used for implementing smart contracts on the Ethereum blockchain. This function takes two input parameters, both of type `string memory`: `traitType` and `value`. The function is marked as `internal`, meaning it can only be called from within the same contract or contracts derived from it, and `pure`, which indicates that it does not modify the contract's state or access any external data.\n\nThe purpose of this function is to generate a JSON-formatted string representing a trait object with two properties: \"trait_type\" and \"value\". The values of these properties are derived from the input parameters `traitType` and `value`, respectively.\n\nTo achieve this, the function uses the `abi.encodePacked` function, which is part of the Ethereum Application Binary Interface (ABI). This function takes a variable number of arguments and returns a tightly packed byte array representation of the input data. In this case, the input data consists of a series of string literals and the input parameters, concatenated together to form the desired JSON structure.\n\nAfter encoding the data, the function converts the resulting byte array back into a string using the `string` keyword. Finally, the resulting JSON-formatted string is returned as the output of the function.\n\nSection Content: function trait(string memory traitType, string memory value) internal pure returns (string memory) {\n        // forgefmt: disable-next-item\n        return string(\n            abi.encodePacked(\n                '{ \"trait_type\": \"', traitType, '\",', '\"value\": \"', value, '\" }'\n            )\n        );\n    }\n}","metadata":{}}]]